[{"title":"DES-Study","url":"/2023/04/13/DES-Study/","content":"DES-Study强加密算法（基于以下两种本源操作）：\n（1）混淆（Confusion）：是一种使密钥与密文之间的关系尽可能模糊的加密操作。如今实 现混淆常用的一个元素就是替换；这个元素在DES和AES中都有使用。 \n（2）扩散（Diffusion）：是一种为了隐藏明文的统计属性而将一个明文符号的影响扩散到 多个密文符号的加密操作。最简单的扩散元素就是位置换，它常用于DES中；而AES则使用更高级的 Mixcolumn 操作。 \n1.DefineDES是一种使用56位密钥对64位长分组进行加密的密码（如图3-3）。\n\nDES是一种对称密码，即其加密过程和解密过程使用相同的密钥。与几乎所有现代分组加密一样，DES也是一种迭代算法。DES对明文中每个分组的加密过程都包含16轮，且每轮的操作完全相同。图3-4显示了DES的轮结构。每轮都会使用不同的子密钥，并且所有子密钥k；都从主密钥k中推导而来的。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.Feistel网络每轮中仅加密输入为的一半，未加密右半部分，用的是伪随机数产生器的输出对左半部分进行XOR操作。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Crypto"]},{"title":"SYC三面","url":"/2022/12/16/SYC/","content":"1.对于Task代码注释的补齐1.1 Task：from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytesimport gmpy2 as gpimport randomfrom flag import flagflag = bytes_to_long(flag)p = getPrime(100)    #说明含义q = getPrime(100)    #说明含义n = p * qclist = []for i in bin(flag)[2:]:    #说明含义    while True:        x = random.randint(1, n)   #说明含义        if gp.gcd(x, n) == 1:   #说明含义            c = (pow(3, int(i) + x * 2, n) * x**2) % n                 clist.append(c)            breakprint(n)print(clist)&#x27;&#x27;&#x27;1254676922968308054473282588201432441748387886551758353389559[112490766735794793494258589897687977797993914062877995369853, 423825989606899409733986824741778284626898537704684650054048, 1239912440099782777043012567198356769914426423982980091061342, 1078272043845620437375344423460688188703277391763226546180151, 159286594418951337823608883690981934876156746053051292254402, 189434397083734065502133592439774066008070864031834709620441, 264105932521685455831442874483122006851812174082486446496525, 252479590298382195780257510632414277760400686563367629394825, 34602153293813328946647556336715300088648653636913843351330, 808692976248223555967993480457680585654329233137701900525232, 836623390705731389723338030121423143060093415003999783847569, 1218829648463542488706300570862499177531816513847669694517865, 571795296699927140597629733281737316938588378300113684751321, 324408602401500017634991400429058861929441907523133040616718, 652309276856121062936275131393396513436481452168222192943617, 135368324264829776566203256490111602190045577103623626459391, 677807894471260530035795635544578014296111908610448488780236, 1135708831589387209825610411788217272141435421502826225558333, 196882176169680492388044653063809988445336200851553236565493, 1130705847039352086713022625138307016610235729598245321418537, 974627899979016730650505688458957247745733629797568884460037, 948987355716018600108888773982169186615279073844787201014331, 364200727831752453880724784142441918092136276002472196567297, 811786724825671349602848333002825903390189436235744947667153, 248544601758659627780643527412918707686666534454807514221527, 1078860601713092925823762998344218082511712606733279204236487, 634851505432770176888905188832078431577879067601938324607512, 232972021265122845242665536151391828176473610240017058444456, 1080796896535347345799923528377657622102130648424673730618155, 622059452832122796944248249707923610120342427983134655552340, 837257289852652447556360719449396492271622453092839975184158, 626327369687614106133688347844033161113612134573404258486630, 1233019194503373412608053469954621323121044455057773900406773, 912564467902216938034173803480737819092198560216579817988291, 408076399689155479697691914877522087726703540593136498587215, 1118745562641959211267518507476218888452509349041078337285098, 1103228775032586830415033772993541541820163005491285279882940, 680899077364553221002722115625274809744677788062477442312086, 355349436487753936000721704075588637048102593449252106813298, 5254361838244723184679801326407268664182654715017847086461, 480145671282471097574354032682584083826945502763658946101104, 249136810947175342894562520096603076879372702701088690594445, 175216547555975039599856545426098941943382367602172941744494, 436310864447848960706296122266108102033486860525693191197797, 342620466614509535208918527767209905005823047382938223113086, 369848992268737575958936185907214270590887322936419642815242, 278575045025661827978388874494219837629182438978526195181637, 1189171180780533071473125545247289861677955100195126109964590, 256190182678715266654387215899616014762531664768736561586327, 719160215933023695898776016718481385742508618676368640641809, 147033122794177086112261858085593706727904275426698884436011, 247466503394960387825735598976068779045757078494832316444804, 787155643450160361724955357286670519256662665704845721250609, 112101120505278148126370035869523081506090979629681063614381, 890009544685851814191758439205974159586245412054287515881584, 1168625756997945588141764967298286550498540363325170551587334, 946031342434770434479581499217378781992921204179509449159996, 759124753621557368233069144948668001126536400499520990700641, 930584421635842804698880452391670787414151645249729141739148, 140981825203074314092967178062754008486703246602401550271041, 880126454149733441805446179826584472107299085899567279467558, 510129631452465708304688340114214360026947205003705062663759, 857274757020001316639221394675820731579775247610619594760511, 444486969413575687285961819261097401974268741167841964919716, 645830958128126799221416466698967430939726760487764050203821, 128864469762235652994228226148325614187747349331618451490354, 732913002124581119538173953534485652651112140400076340646452, 1245672039639609341331477592944058028011275464117654972595670, 1160765030758624190775369713232721901616189349905945190302338, 745734132091942990384796294800038299023052878196943617322617, 34973161572808799782240527358912894045293050940490682156733, 507586651070816931641904112686082840821460472219390068396982, 359195216122538975934588740641220005777478961423841727365432, 60506687352654743312206686911057762445232526009857863834444, 402036521271253699065227780662896890228371046068283711170220, 465427226677337673103293964961886503610313835775181975449721, 925246962888172144515172444374190859841851825972285013006527, 542176614893876361668218387162168517498644799220587472896002, 852215132196560596695876248813488364201491362280912035912061, 945548964927065532651141821562204387565145712002346337639711, 736943822066388892909878515650831955490636214039062998720510, 766357526983761241394182000478355475617711906398422036954152, 77156525593382594092608158744099524034892127423492520631820, 562562817542804973601572838378263130638457829485887327130286, 768093992370198202822524520006977816845162154854939167515517, 1099957424762490943973557935337350760135180754563993547358098, 698816668614997174913438496891169625976027534942525487303513, 417641699919584202170293946436276552973997395211792288687960, 1006229610175567855209117721408416419896921240126676949824724, 4206431689326446028142220658552064336105749936096602165359, 893846509909828693967573302731018066461118006150050253703744, 878425189026235350891203121924637130803808920422558040493294, 730047416245095988472212050949689633327186823542036387345181, 648095719945750715387983948406690533087473721929975873848169, 213513454359755001454814601053555627585345770061082141021326, 350001050012957205656929492039628823072469208940960439158263, 1016858635000037892730835311903706149371704230428070443107320, 1040987439471207869975679257301693610464700899302787643642354, 1194690615352550474729309715449838057220521596135246725909553, 508165053077110820797186371383859674371399129952105597675096, 266494438294281492504556232035584920066331725618646155019547, 28469482072427012244441092412738741355431846649166066368980, 790175775999108776289865518368056397969387298334297622465909, 590581138260907253939363764832940322585129285968275409510634, 221909012579985462013325803334419731308959816500415305934495, 1063780559219791515938747204569742799329237935871594345400252, 977747525495509380693721486866821791065499754056415279744653, 346306061371595730004513789139807509540063462412619321003626, 456103179467597859705969406860196938169100856240100927540401, 969300078509189631808517876996065933181606409375207150288464, 1029806631220370012120597683927351131622576733031694535189521, 344896431603140401163996810922500893279239069499717183710501, 430000423804197030568046280589772094106128395099434235915031, 700179843567016021775399107572964843751703290591400960796112, 961227906080189143689698720420426659986080298413605666115640, 607209606799750473714271393200060455739097869884727178692312, 106958847163040842225140399905505511449479709017540851084532, 953369942103273809257762268859167463617831445026988544378658, 428269440686506672744282327102546440435442014650795927162711, 56621803434665963032193024056111306570802155743250152849716, 800707635631355839166448276143596444307614901816577459076131, 1032256515703247765067950588859299047987257001987777631061065, 813725055801254665600156259482200403981770576173968929131487, 940024839745068011043019236327963504645352520797347949823455, 1065005324140908547287467504568283884363143527586278243210801, 1087828777506290663525994551834233065465427418753806182842291, 668387132001968449612224853010931354244797738682007519611989, 563185246196177998134932666270526715161378776103340983046580, 148292872313931508344196679476720973752571125303712466045656, 413889563851226543249984374872220761253120628252088546262699, 853542105910386365929770611480736086723126396438880650918917, 59730458840715910492468261806200793684923819793480597554146, 792260492800286127199649276659137441324248689470594987965190, 753608630500639136668081531883097047491651258191552267413126, 33514911499472634865669915075769163328171019557849259474018, 634963859228206842307837566519244534650818456901841184879977, 219354096455968590219445072777282329948785844491217770978344, 1123377226439583158729762969668999276741275445803396272436031, 357765295513680388973981712560200525235334734759663454993805, 385868499980630535766019957877752149506518574529845752144666, 138578212294299392480319417966870656714476525885983752756188, 1110526796192425688386237355263892073046060477008920073455044, 244699783645221387947312903861559688207612147588246639081699, 583209905862562678600202085212425597809036630416117298854978, 1207854793808762194414317661151529169444903662139065050090746, 1127506983223466275821900811940356395242309493951089427884032, 526185119576631048584313761548704536031634598332129570964689, 266882032196696984660521486449809902101615921156569537960109, 1188118705564450461919200724390473040524626320052324478509883, 682831747455078454647149830819696088960233603851250102828667, 669419928942561433130809268138650695825596612075801278942980, 1077750630919867687880983437504767304166615787212813240073843, 486023540111308483450127320955599047045479654684477043315645, 409429366346146233850088863324915025465847596238000661872172, 779883595226131237594759409249289551033410304517183865388408, 1155872225708857920911178110668279174877878422508206228579940, 411063490066038942009369947241345843238439795078686488373864, 1243453053541946030699872676712518536022061850799945414120045, 871711034820169700581685353768658469631429266493677466057997, 601920686459160120670719526703980120744719013393032353678765, 329932100141177850249406090412821976994089707958551194468769, 558327299751202100333335353826111016492585371503632197870640, 113444032302978611299580451314055133491399096282744687816086, 152525914892717139057165748051966776217223953242540511499945, 965404850400527912039904270871065001313018148780552532312669, 313557099445185696402013375071955475516203519824979749629786, 952254159335810337756614972813240144837526566801182319987154]&#x27;&#x27;&#x27;\n\n\n\n\n\n\n\n\n\n\n\n1.2 注释与补齐：from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytesimport gmpy2 as gpimport randomfrom flag import flag  #flag未知flag = bytes_to_long(flag)#getPrime来自Crypto库中的Util.number模块，其作用是随机获得一个N比特位的素数，同时进行检验，确保正确性  p = getPrime(100)   #随机获得一个100比特位的素数，并将它的值赋值给pq = getPrime(100)   #随机获得一个100比特位的素数，并将它的值赋值给qn = p * qclist = []for i in bin(flag)[2:]:    #将flag转为二进制数，获取从偏移为2到末尾的数，再历遍所有可能    while True:        x = random.randint(1, n)   #生成在1与n之间的整数x(1&lt;=x&lt;=n)        if gp.gcd(x, n) == 1:   #引用gp.gcd函数，判断x与n是否互质            c = (pow(3, int(i) + x * 2, n) * x**2) % n                 clist.append(c)  #将c添加到clist列表末尾            breakprint(n)print(clist)#给出n与若干组c的值&#x27;&#x27;&#x27;1254676922968308054473282588201432441748387886551758353389559[112490766735794793494258589897687977797993914062877995369853, 423825989606899409733986824741778284626898537704684650054048, 1239912440099782777043012567198356769914426423982980091061342, 1078272043845620437375344423460688188703277391763226546180151, 159286594418951337823608883690981934876156746053051292254402, 189434397083734065502133592439774066008070864031834709620441, 264105932521685455831442874483122006851812174082486446496525, 252479590298382195780257510632414277760400686563367629394825, 34602153293813328946647556336715300088648653636913843351330, 808692976248223555967993480457680585654329233137701900525232, 836623390705731389723338030121423143060093415003999783847569, 1218829648463542488706300570862499177531816513847669694517865, 571795296699927140597629733281737316938588378300113684751321, 324408602401500017634991400429058861929441907523133040616718, 652309276856121062936275131393396513436481452168222192943617, 135368324264829776566203256490111602190045577103623626459391, 677807894471260530035795635544578014296111908610448488780236, 1135708831589387209825610411788217272141435421502826225558333, 196882176169680492388044653063809988445336200851553236565493, 1130705847039352086713022625138307016610235729598245321418537, 974627899979016730650505688458957247745733629797568884460037, 948987355716018600108888773982169186615279073844787201014331, 364200727831752453880724784142441918092136276002472196567297, 811786724825671349602848333002825903390189436235744947667153, 248544601758659627780643527412918707686666534454807514221527, 1078860601713092925823762998344218082511712606733279204236487, 634851505432770176888905188832078431577879067601938324607512, 232972021265122845242665536151391828176473610240017058444456, 1080796896535347345799923528377657622102130648424673730618155, 622059452832122796944248249707923610120342427983134655552340, 837257289852652447556360719449396492271622453092839975184158, 626327369687614106133688347844033161113612134573404258486630, 1233019194503373412608053469954621323121044455057773900406773, 912564467902216938034173803480737819092198560216579817988291, 408076399689155479697691914877522087726703540593136498587215, 1118745562641959211267518507476218888452509349041078337285098, 1103228775032586830415033772993541541820163005491285279882940, 680899077364553221002722115625274809744677788062477442312086, 355349436487753936000721704075588637048102593449252106813298, 5254361838244723184679801326407268664182654715017847086461, 480145671282471097574354032682584083826945502763658946101104, 249136810947175342894562520096603076879372702701088690594445, 175216547555975039599856545426098941943382367602172941744494, 436310864447848960706296122266108102033486860525693191197797, 342620466614509535208918527767209905005823047382938223113086, 369848992268737575958936185907214270590887322936419642815242, 278575045025661827978388874494219837629182438978526195181637, 1189171180780533071473125545247289861677955100195126109964590, 256190182678715266654387215899616014762531664768736561586327, 719160215933023695898776016718481385742508618676368640641809, 147033122794177086112261858085593706727904275426698884436011, 247466503394960387825735598976068779045757078494832316444804, 787155643450160361724955357286670519256662665704845721250609, 112101120505278148126370035869523081506090979629681063614381, 890009544685851814191758439205974159586245412054287515881584, 1168625756997945588141764967298286550498540363325170551587334, 946031342434770434479581499217378781992921204179509449159996, 759124753621557368233069144948668001126536400499520990700641, 930584421635842804698880452391670787414151645249729141739148, 140981825203074314092967178062754008486703246602401550271041, 880126454149733441805446179826584472107299085899567279467558, 510129631452465708304688340114214360026947205003705062663759, 857274757020001316639221394675820731579775247610619594760511, 444486969413575687285961819261097401974268741167841964919716, 645830958128126799221416466698967430939726760487764050203821, 128864469762235652994228226148325614187747349331618451490354, 732913002124581119538173953534485652651112140400076340646452, 1245672039639609341331477592944058028011275464117654972595670, 1160765030758624190775369713232721901616189349905945190302338, 745734132091942990384796294800038299023052878196943617322617, 34973161572808799782240527358912894045293050940490682156733, 507586651070816931641904112686082840821460472219390068396982, 359195216122538975934588740641220005777478961423841727365432, 60506687352654743312206686911057762445232526009857863834444, 402036521271253699065227780662896890228371046068283711170220, 465427226677337673103293964961886503610313835775181975449721, 925246962888172144515172444374190859841851825972285013006527, 542176614893876361668218387162168517498644799220587472896002, 852215132196560596695876248813488364201491362280912035912061, 945548964927065532651141821562204387565145712002346337639711, 736943822066388892909878515650831955490636214039062998720510, 766357526983761241394182000478355475617711906398422036954152, 77156525593382594092608158744099524034892127423492520631820, 562562817542804973601572838378263130638457829485887327130286, 768093992370198202822524520006977816845162154854939167515517, 1099957424762490943973557935337350760135180754563993547358098, 698816668614997174913438496891169625976027534942525487303513, 417641699919584202170293946436276552973997395211792288687960, 1006229610175567855209117721408416419896921240126676949824724, 4206431689326446028142220658552064336105749936096602165359, 893846509909828693967573302731018066461118006150050253703744, 878425189026235350891203121924637130803808920422558040493294, 730047416245095988472212050949689633327186823542036387345181, 648095719945750715387983948406690533087473721929975873848169, 213513454359755001454814601053555627585345770061082141021326, 350001050012957205656929492039628823072469208940960439158263, 1016858635000037892730835311903706149371704230428070443107320, 1040987439471207869975679257301693610464700899302787643642354, 1194690615352550474729309715449838057220521596135246725909553, 508165053077110820797186371383859674371399129952105597675096, 266494438294281492504556232035584920066331725618646155019547, 28469482072427012244441092412738741355431846649166066368980, 790175775999108776289865518368056397969387298334297622465909, 590581138260907253939363764832940322585129285968275409510634, 221909012579985462013325803334419731308959816500415305934495, 1063780559219791515938747204569742799329237935871594345400252, 977747525495509380693721486866821791065499754056415279744653, 346306061371595730004513789139807509540063462412619321003626, 456103179467597859705969406860196938169100856240100927540401, 969300078509189631808517876996065933181606409375207150288464, 1029806631220370012120597683927351131622576733031694535189521, 344896431603140401163996810922500893279239069499717183710501, 430000423804197030568046280589772094106128395099434235915031, 700179843567016021775399107572964843751703290591400960796112, 961227906080189143689698720420426659986080298413605666115640, 607209606799750473714271393200060455739097869884727178692312, 106958847163040842225140399905505511449479709017540851084532, 953369942103273809257762268859167463617831445026988544378658, 428269440686506672744282327102546440435442014650795927162711, 56621803434665963032193024056111306570802155743250152849716, 800707635631355839166448276143596444307614901816577459076131, 1032256515703247765067950588859299047987257001987777631061065, 813725055801254665600156259482200403981770576173968929131487, 940024839745068011043019236327963504645352520797347949823455, 1065005324140908547287467504568283884363143527586278243210801, 1087828777506290663525994551834233065465427418753806182842291, 668387132001968449612224853010931354244797738682007519611989, 563185246196177998134932666270526715161378776103340983046580, 148292872313931508344196679476720973752571125303712466045656, 413889563851226543249984374872220761253120628252088546262699, 853542105910386365929770611480736086723126396438880650918917, 59730458840715910492468261806200793684923819793480597554146, 792260492800286127199649276659137441324248689470594987965190, 753608630500639136668081531883097047491651258191552267413126, 33514911499472634865669915075769163328171019557849259474018, 634963859228206842307837566519244534650818456901841184879977, 219354096455968590219445072777282329948785844491217770978344, 1123377226439583158729762969668999276741275445803396272436031, 357765295513680388973981712560200525235334734759663454993805, 385868499980630535766019957877752149506518574529845752144666, 138578212294299392480319417966870656714476525885983752756188, 1110526796192425688386237355263892073046060477008920073455044, 244699783645221387947312903861559688207612147588246639081699, 583209905862562678600202085212425597809036630416117298854978, 1207854793808762194414317661151529169444903662139065050090746, 1127506983223466275821900811940356395242309493951089427884032, 526185119576631048584313761548704536031634598332129570964689, 266882032196696984660521486449809902101615921156569537960109, 1188118705564450461919200724390473040524626320052324478509883, 682831747455078454647149830819696088960233603851250102828667, 669419928942561433130809268138650695825596612075801278942980, 1077750630919867687880983437504767304166615787212813240073843, 486023540111308483450127320955599047045479654684477043315645, 409429366346146233850088863324915025465847596238000661872172, 779883595226131237594759409249289551033410304517183865388408, 1155872225708857920911178110668279174877878422508206228579940, 411063490066038942009369947241345843238439795078686488373864, 1243453053541946030699872676712518536022061850799945414120045, 871711034820169700581685353768658469631429266493677466057997, 601920686459160120670719526703980120744719013393032353678765, 329932100141177850249406090412821976994089707958551194468769, 558327299751202100333335353826111016492585371503632197870640, 113444032302978611299580451314055133491399096282744687816086, 152525914892717139057165748051966776217223953242540511499945, 965404850400527912039904270871065001313018148780552532312669, 313557099445185696402013375071955475516203519824979749629786, 952254159335810337756614972813240144837526566801182319987154]&#x27;&#x27;&#x27;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.Paper‘s notes2.1 关于数论：\n论文中会自主定义一些乘法群、域\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.2 中国剩余定理与二次剩余：2.2.1 中国剩余定理：\n\n\n\n\n\n\n\n\n\n\n\n中国剩余定理公式：\n\n设正整数两两互素，则同余方程组\n​               \n有整数解。并且在模下的解是唯一的，解为\n​                \n其中，而为模的逆元。\n\n中国剩余定理学习笔记 - MashiroSky - 博客园 (cnblogs.com)\n2.2.2 二次剩余：1. 二次剩余定理：对于n和素数p来说，存在x使\n 方程  x^2≡n(mod p)    \n成立\n2. 引入符号：勒让德符号，这个符号里有两个值，一个是n,一个是p。假设p为奇素数，且n无法整除p时，有以下定义\n\n\n\n\n\n\n\n\n\n\n\n类似于paper中的雅可比符号\n\n3. 证明：\n(5条消息) 二次剩余定理详解_gerayking的博客-CSDN博客_二次剩余定理\n2.3 笔记整理：2.3.1 算法：1. 判断x是否为二次剩余\n\n\n\n\n\n\n\n\n\n\n\n\n\n2. 用N已知的因子p、q判断模N下数x是否为二次剩余\n\n\n\n\n\n\n\n\n\n\n\n\n\n3. 已知条件\n\n\n\n\n\n\n\n\n\n\n\n\n\n4. 加密算法\n\n\n\n\n\n\n\n\n\n\n\n\n\n5. 解密算法由于接收者已知私钥：p、q，他就不需要另外单独的解密算法，通过判断c是否为二次剩余，他就可以知道密文为0还是1。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.3.2 命题：1. 二次剩余\n2. 雅可比符号\n3. 雅可比乘法性质\n4. 二次剩余的复合运算\n5. 二次剩余与雅可比的分布\n\n6. 雅可比的复合运算\n3. Task解题3.1 题目模型：本task的模型是 Goldwasser-Micali Cryprosystem，即GM公钥加密系统\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.2解题思路：3.2.1 题目分析：from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytesimport gmpy2 as gpimport randomfrom flag import flagflag = bytes_to_long(flag)p = getPrime(100)   q = getPrime(100)    n = p * qclist = []for i in bin(flag)[2:]:        while True:        x = random.randint(1, n)          if gp.gcd(x, n) == 1:              c = (pow(3, int(i) + x * 2, n) * x**2) % n                 clist.append(c)            breakprint(n)print(clist)&#x27;&#x27;&#x27;1254676922968308054473282588201432441748387886551758353389559[112490766735794793494258589897687977797993914062877995369853, 423825989606899409733986824741778284626898537704684650054048, 1239912440099782777043012567198356769914426423982980091061342, 1078272043845620437375344423460688188703277391763226546180151, 159286594418951337823608883690981934876156746053051292254402, 189434397083734065502133592439774066008070864031834709620441, 264105932521685455831442874483122006851812174082486446496525, 252479590298382195780257510632414277760400686563367629394825, 34602153293813328946647556336715300088648653636913843351330, 808692976248223555967993480457680585654329233137701900525232, 836623390705731389723338030121423143060093415003999783847569, 1218829648463542488706300570862499177531816513847669694517865, 571795296699927140597629733281737316938588378300113684751321, 324408602401500017634991400429058861929441907523133040616718, 652309276856121062936275131393396513436481452168222192943617, 135368324264829776566203256490111602190045577103623626459391, 677807894471260530035795635544578014296111908610448488780236, 1135708831589387209825610411788217272141435421502826225558333, 196882176169680492388044653063809988445336200851553236565493, 1130705847039352086713022625138307016610235729598245321418537, 974627899979016730650505688458957247745733629797568884460037, 948987355716018600108888773982169186615279073844787201014331, 364200727831752453880724784142441918092136276002472196567297, 811786724825671349602848333002825903390189436235744947667153, 248544601758659627780643527412918707686666534454807514221527, 1078860601713092925823762998344218082511712606733279204236487, 634851505432770176888905188832078431577879067601938324607512, 232972021265122845242665536151391828176473610240017058444456, 1080796896535347345799923528377657622102130648424673730618155, 622059452832122796944248249707923610120342427983134655552340, 837257289852652447556360719449396492271622453092839975184158, 626327369687614106133688347844033161113612134573404258486630, 1233019194503373412608053469954621323121044455057773900406773, 912564467902216938034173803480737819092198560216579817988291, 408076399689155479697691914877522087726703540593136498587215, 1118745562641959211267518507476218888452509349041078337285098, 1103228775032586830415033772993541541820163005491285279882940, 680899077364553221002722115625274809744677788062477442312086, 355349436487753936000721704075588637048102593449252106813298, 5254361838244723184679801326407268664182654715017847086461, 480145671282471097574354032682584083826945502763658946101104, 249136810947175342894562520096603076879372702701088690594445, 175216547555975039599856545426098941943382367602172941744494, 436310864447848960706296122266108102033486860525693191197797, 342620466614509535208918527767209905005823047382938223113086, 369848992268737575958936185907214270590887322936419642815242, 278575045025661827978388874494219837629182438978526195181637, 1189171180780533071473125545247289861677955100195126109964590, 256190182678715266654387215899616014762531664768736561586327, 719160215933023695898776016718481385742508618676368640641809, 147033122794177086112261858085593706727904275426698884436011, 247466503394960387825735598976068779045757078494832316444804, 787155643450160361724955357286670519256662665704845721250609, 112101120505278148126370035869523081506090979629681063614381, 890009544685851814191758439205974159586245412054287515881584, 1168625756997945588141764967298286550498540363325170551587334, 946031342434770434479581499217378781992921204179509449159996, 759124753621557368233069144948668001126536400499520990700641, 930584421635842804698880452391670787414151645249729141739148, 140981825203074314092967178062754008486703246602401550271041, 880126454149733441805446179826584472107299085899567279467558, 510129631452465708304688340114214360026947205003705062663759, 857274757020001316639221394675820731579775247610619594760511, 444486969413575687285961819261097401974268741167841964919716, 645830958128126799221416466698967430939726760487764050203821, 128864469762235652994228226148325614187747349331618451490354, 732913002124581119538173953534485652651112140400076340646452, 1245672039639609341331477592944058028011275464117654972595670, 1160765030758624190775369713232721901616189349905945190302338, 745734132091942990384796294800038299023052878196943617322617, 34973161572808799782240527358912894045293050940490682156733, 507586651070816931641904112686082840821460472219390068396982, 359195216122538975934588740641220005777478961423841727365432, 60506687352654743312206686911057762445232526009857863834444, 402036521271253699065227780662896890228371046068283711170220, 465427226677337673103293964961886503610313835775181975449721, 925246962888172144515172444374190859841851825972285013006527, 542176614893876361668218387162168517498644799220587472896002, 852215132196560596695876248813488364201491362280912035912061, 945548964927065532651141821562204387565145712002346337639711, 736943822066388892909878515650831955490636214039062998720510, 766357526983761241394182000478355475617711906398422036954152, 77156525593382594092608158744099524034892127423492520631820, 562562817542804973601572838378263130638457829485887327130286, 768093992370198202822524520006977816845162154854939167515517, 1099957424762490943973557935337350760135180754563993547358098, 698816668614997174913438496891169625976027534942525487303513, 417641699919584202170293946436276552973997395211792288687960, 1006229610175567855209117721408416419896921240126676949824724, 4206431689326446028142220658552064336105749936096602165359, 893846509909828693967573302731018066461118006150050253703744, 878425189026235350891203121924637130803808920422558040493294, 730047416245095988472212050949689633327186823542036387345181, 648095719945750715387983948406690533087473721929975873848169, 213513454359755001454814601053555627585345770061082141021326, 350001050012957205656929492039628823072469208940960439158263, 1016858635000037892730835311903706149371704230428070443107320, 1040987439471207869975679257301693610464700899302787643642354, 1194690615352550474729309715449838057220521596135246725909553, 508165053077110820797186371383859674371399129952105597675096, 266494438294281492504556232035584920066331725618646155019547, 28469482072427012244441092412738741355431846649166066368980, 790175775999108776289865518368056397969387298334297622465909, 590581138260907253939363764832940322585129285968275409510634, 221909012579985462013325803334419731308959816500415305934495, 1063780559219791515938747204569742799329237935871594345400252, 977747525495509380693721486866821791065499754056415279744653, 346306061371595730004513789139807509540063462412619321003626, 456103179467597859705969406860196938169100856240100927540401, 969300078509189631808517876996065933181606409375207150288464, 1029806631220370012120597683927351131622576733031694535189521, 344896431603140401163996810922500893279239069499717183710501, 430000423804197030568046280589772094106128395099434235915031, 700179843567016021775399107572964843751703290591400960796112, 961227906080189143689698720420426659986080298413605666115640, 607209606799750473714271393200060455739097869884727178692312, 106958847163040842225140399905505511449479709017540851084532, 953369942103273809257762268859167463617831445026988544378658, 428269440686506672744282327102546440435442014650795927162711, 56621803434665963032193024056111306570802155743250152849716, 800707635631355839166448276143596444307614901816577459076131, 1032256515703247765067950588859299047987257001987777631061065, 813725055801254665600156259482200403981770576173968929131487, 940024839745068011043019236327963504645352520797347949823455, 1065005324140908547287467504568283884363143527586278243210801, 1087828777506290663525994551834233065465427418753806182842291, 668387132001968449612224853010931354244797738682007519611989, 563185246196177998134932666270526715161378776103340983046580, 148292872313931508344196679476720973752571125303712466045656, 413889563851226543249984374872220761253120628252088546262699, 853542105910386365929770611480736086723126396438880650918917, 59730458840715910492468261806200793684923819793480597554146, 792260492800286127199649276659137441324248689470594987965190, 753608630500639136668081531883097047491651258191552267413126, 33514911499472634865669915075769163328171019557849259474018, 634963859228206842307837566519244534650818456901841184879977, 219354096455968590219445072777282329948785844491217770978344, 1123377226439583158729762969668999276741275445803396272436031, 357765295513680388973981712560200525235334734759663454993805, 385868499980630535766019957877752149506518574529845752144666, 138578212294299392480319417966870656714476525885983752756188, 1110526796192425688386237355263892073046060477008920073455044, 244699783645221387947312903861559688207612147588246639081699, 583209905862562678600202085212425597809036630416117298854978, 1207854793808762194414317661151529169444903662139065050090746, 1127506983223466275821900811940356395242309493951089427884032, 526185119576631048584313761548704536031634598332129570964689, 266882032196696984660521486449809902101615921156569537960109, 1188118705564450461919200724390473040524626320052324478509883, 682831747455078454647149830819696088960233603851250102828667, 669419928942561433130809268138650695825596612075801278942980, 1077750630919867687880983437504767304166615787212813240073843, 486023540111308483450127320955599047045479654684477043315645, 409429366346146233850088863324915025465847596238000661872172, 779883595226131237594759409249289551033410304517183865388408, 1155872225708857920911178110668279174877878422508206228579940, 411063490066038942009369947241345843238439795078686488373864, 1243453053541946030699872676712518536022061850799945414120045, 871711034820169700581685353768658469631429266493677466057997, 601920686459160120670719526703980120744719013393032353678765, 329932100141177850249406090412821976994089707958551194468769, 558327299751202100333335353826111016492585371503632197870640, 113444032302978611299580451314055133491399096282744687816086, 152525914892717139057165748051966776217223953242540511499945, 965404850400527912039904270871065001313018148780552532312669, 313557099445185696402013375071955475516203519824979749629786, 952254159335810337756614972813240144837526566801182319987154]&#x27;&#x27;&#x27;\n\n\n\nfor i in bin(flag)[2:]:        #历遍转化为二进制数的flag，即逐位获得flag的二进制位    while True:        x = random.randint(1, n)          #在（1，n）的范围内随机选择用于加密信息的x        if gp.gcd(x, n) == 1:              c = (pow(3, int(i) + x * 2, n) * x**2) % n                 clist.append(c)            break\n\n\n\n\n\n我们观察到本task的模型是 Goldwasser-Micali Cryprosystem，c的加密方式也已经给出，并且在clist数组内列出了每个c的值。\nc是这样加密的：c&#x3D;(3^(int(i)+2x)*x^2)%n \n仔细观察上式，发现当i&#x3D;0时情况特殊。若i&#x3D;0,则c&#x3D;(3^x*x)^2%n\n而此时c是模n的二次剩余。\n$$总结一下，当c是模n的二次剩余，即J_n(c)&#x3D;1时，i&#x3D;0$$\n$$那么相反，当c是模n的非二次剩余，即J_n(c)&#x3D;-1时，i&#x3D;1$$\n3.2.2 破解流程：我们先列出已知条件，即n与clist中若干组加密的c的值\nn=1254676922968308054473282588201432441748387886551758353389559clist=[&#x27;&#x27;&#x27;&#x27;&#x27;&#x27; ]\n\n\n\n\n\n\n\n通过分析，我们发现能够在仅知道公钥n的条件下，通过jacobi判断c是否为二次剩余对flag进行还原。\n攻击设计如下\nflag=&#x27;&#x27;#历遍给出的若干组cfor c in clist:   #判断“二次剩余”，逐个还原flag的二进制数\tif gp.jacobi(c,n)==1:\t\tflag+=&#x27;0&#x27;\tif  gp.jacobi(c,n)==-1:\t\t\tflag+=&#x27;1&#x27;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.2.3 攻击脚本：#GM脚本import gmpy2 as gpfrom libnum import*n=1254676922968308054473282588201432441748387886551758353389559clist=[112490766735794793494258589897687977797993914062877995369853, 423825989606899409733986824741778284626898537704684650054048, 1239912440099782777043012567198356769914426423982980091061342, 1078272043845620437375344423460688188703277391763226546180151, 159286594418951337823608883690981934876156746053051292254402, 189434397083734065502133592439774066008070864031834709620441, 264105932521685455831442874483122006851812174082486446496525, 252479590298382195780257510632414277760400686563367629394825, 34602153293813328946647556336715300088648653636913843351330, 808692976248223555967993480457680585654329233137701900525232, 836623390705731389723338030121423143060093415003999783847569, 1218829648463542488706300570862499177531816513847669694517865, 571795296699927140597629733281737316938588378300113684751321, 324408602401500017634991400429058861929441907523133040616718, 652309276856121062936275131393396513436481452168222192943617, 135368324264829776566203256490111602190045577103623626459391, 677807894471260530035795635544578014296111908610448488780236, 1135708831589387209825610411788217272141435421502826225558333, 196882176169680492388044653063809988445336200851553236565493, 1130705847039352086713022625138307016610235729598245321418537, 974627899979016730650505688458957247745733629797568884460037, 948987355716018600108888773982169186615279073844787201014331, 364200727831752453880724784142441918092136276002472196567297, 811786724825671349602848333002825903390189436235744947667153, 248544601758659627780643527412918707686666534454807514221527, 1078860601713092925823762998344218082511712606733279204236487, 634851505432770176888905188832078431577879067601938324607512, 232972021265122845242665536151391828176473610240017058444456, 1080796896535347345799923528377657622102130648424673730618155, 622059452832122796944248249707923610120342427983134655552340, 837257289852652447556360719449396492271622453092839975184158, 626327369687614106133688347844033161113612134573404258486630, 1233019194503373412608053469954621323121044455057773900406773, 912564467902216938034173803480737819092198560216579817988291, 408076399689155479697691914877522087726703540593136498587215, 1118745562641959211267518507476218888452509349041078337285098, 1103228775032586830415033772993541541820163005491285279882940, 680899077364553221002722115625274809744677788062477442312086, 355349436487753936000721704075588637048102593449252106813298, 5254361838244723184679801326407268664182654715017847086461, 480145671282471097574354032682584083826945502763658946101104, 249136810947175342894562520096603076879372702701088690594445, 175216547555975039599856545426098941943382367602172941744494, 436310864447848960706296122266108102033486860525693191197797, 342620466614509535208918527767209905005823047382938223113086, 369848992268737575958936185907214270590887322936419642815242, 278575045025661827978388874494219837629182438978526195181637, 1189171180780533071473125545247289861677955100195126109964590, 256190182678715266654387215899616014762531664768736561586327, 719160215933023695898776016718481385742508618676368640641809, 147033122794177086112261858085593706727904275426698884436011, 247466503394960387825735598976068779045757078494832316444804, 787155643450160361724955357286670519256662665704845721250609, 112101120505278148126370035869523081506090979629681063614381, 890009544685851814191758439205974159586245412054287515881584, 1168625756997945588141764967298286550498540363325170551587334, 946031342434770434479581499217378781992921204179509449159996, 759124753621557368233069144948668001126536400499520990700641, 930584421635842804698880452391670787414151645249729141739148, 140981825203074314092967178062754008486703246602401550271041, 880126454149733441805446179826584472107299085899567279467558, 510129631452465708304688340114214360026947205003705062663759, 857274757020001316639221394675820731579775247610619594760511, 444486969413575687285961819261097401974268741167841964919716, 645830958128126799221416466698967430939726760487764050203821, 128864469762235652994228226148325614187747349331618451490354, 732913002124581119538173953534485652651112140400076340646452, 1245672039639609341331477592944058028011275464117654972595670, 1160765030758624190775369713232721901616189349905945190302338, 745734132091942990384796294800038299023052878196943617322617, 34973161572808799782240527358912894045293050940490682156733, 507586651070816931641904112686082840821460472219390068396982, 359195216122538975934588740641220005777478961423841727365432, 60506687352654743312206686911057762445232526009857863834444, 402036521271253699065227780662896890228371046068283711170220, 465427226677337673103293964961886503610313835775181975449721, 925246962888172144515172444374190859841851825972285013006527, 542176614893876361668218387162168517498644799220587472896002, 852215132196560596695876248813488364201491362280912035912061, 945548964927065532651141821562204387565145712002346337639711, 736943822066388892909878515650831955490636214039062998720510, 766357526983761241394182000478355475617711906398422036954152, 77156525593382594092608158744099524034892127423492520631820, 562562817542804973601572838378263130638457829485887327130286, 768093992370198202822524520006977816845162154854939167515517, 1099957424762490943973557935337350760135180754563993547358098, 698816668614997174913438496891169625976027534942525487303513, 417641699919584202170293946436276552973997395211792288687960, 1006229610175567855209117721408416419896921240126676949824724, 4206431689326446028142220658552064336105749936096602165359, 893846509909828693967573302731018066461118006150050253703744, 878425189026235350891203121924637130803808920422558040493294, 730047416245095988472212050949689633327186823542036387345181, 648095719945750715387983948406690533087473721929975873848169, 213513454359755001454814601053555627585345770061082141021326, 350001050012957205656929492039628823072469208940960439158263, 1016858635000037892730835311903706149371704230428070443107320, 1040987439471207869975679257301693610464700899302787643642354, 1194690615352550474729309715449838057220521596135246725909553, 508165053077110820797186371383859674371399129952105597675096, 266494438294281492504556232035584920066331725618646155019547, 28469482072427012244441092412738741355431846649166066368980, 790175775999108776289865518368056397969387298334297622465909, 590581138260907253939363764832940322585129285968275409510634, 221909012579985462013325803334419731308959816500415305934495, 1063780559219791515938747204569742799329237935871594345400252, 977747525495509380693721486866821791065499754056415279744653, 346306061371595730004513789139807509540063462412619321003626, 456103179467597859705969406860196938169100856240100927540401, 969300078509189631808517876996065933181606409375207150288464, 1029806631220370012120597683927351131622576733031694535189521, 344896431603140401163996810922500893279239069499717183710501, 430000423804197030568046280589772094106128395099434235915031, 700179843567016021775399107572964843751703290591400960796112, 961227906080189143689698720420426659986080298413605666115640, 607209606799750473714271393200060455739097869884727178692312, 106958847163040842225140399905505511449479709017540851084532, 953369942103273809257762268859167463617831445026988544378658, 428269440686506672744282327102546440435442014650795927162711, 56621803434665963032193024056111306570802155743250152849716, 800707635631355839166448276143596444307614901816577459076131, 1032256515703247765067950588859299047987257001987777631061065, 813725055801254665600156259482200403981770576173968929131487, 940024839745068011043019236327963504645352520797347949823455, 1065005324140908547287467504568283884363143527586278243210801, 1087828777506290663525994551834233065465427418753806182842291, 668387132001968449612224853010931354244797738682007519611989, 563185246196177998134932666270526715161378776103340983046580, 148292872313931508344196679476720973752571125303712466045656, 413889563851226543249984374872220761253120628252088546262699, 853542105910386365929770611480736086723126396438880650918917, 59730458840715910492468261806200793684923819793480597554146, 792260492800286127199649276659137441324248689470594987965190, 753608630500639136668081531883097047491651258191552267413126, 33514911499472634865669915075769163328171019557849259474018, 634963859228206842307837566519244534650818456901841184879977, 219354096455968590219445072777282329948785844491217770978344, 1123377226439583158729762969668999276741275445803396272436031, 357765295513680388973981712560200525235334734759663454993805, 385868499980630535766019957877752149506518574529845752144666, 138578212294299392480319417966870656714476525885983752756188, 1110526796192425688386237355263892073046060477008920073455044, 244699783645221387947312903861559688207612147588246639081699, 583209905862562678600202085212425597809036630416117298854978, 1207854793808762194414317661151529169444903662139065050090746, 1127506983223466275821900811940356395242309493951089427884032, 526185119576631048584313761548704536031634598332129570964689, 266882032196696984660521486449809902101615921156569537960109, 1188118705564450461919200724390473040524626320052324478509883, 682831747455078454647149830819696088960233603851250102828667, 669419928942561433130809268138650695825596612075801278942980, 1077750630919867687880983437504767304166615787212813240073843, 486023540111308483450127320955599047045479654684477043315645, 409429366346146233850088863324915025465847596238000661872172, 779883595226131237594759409249289551033410304517183865388408, 1155872225708857920911178110668279174877878422508206228579940, 411063490066038942009369947241345843238439795078686488373864, 1243453053541946030699872676712518536022061850799945414120045, 871711034820169700581685353768658469631429266493677466057997, 601920686459160120670719526703980120744719013393032353678765, 329932100141177850249406090412821976994089707958551194468769, 558327299751202100333335353826111016492585371503632197870640, 113444032302978611299580451314055133491399096282744687816086, 152525914892717139057165748051966776217223953242540511499945, 965404850400527912039904270871065001313018148780552532312669, 313557099445185696402013375071955475516203519824979749629786, 952254159335810337756614972813240144837526566801182319987154]flag=&#x27;&#x27;for c in clist:\tif gp.jacobi(c,n)==1:\t\tflag+=&#x27;0&#x27;\tif  gp.jacobi(c,n)==-1:\t\t\tflag+=&#x27;1&#x27;\t\tprint(&#x27;flag二进制:&#x27;,flag)#二进制转化成十进制f=int(flag,2)print(&#x27;flag十进制:&#x27;,f)print(n2s(f))\n\n\n\n\n\n运行结果：\n\n顺利得到flag：\nSYC{run_to_the_light}\n","tags":["面试小结"]},{"title":"Hgame-2023-note","url":"/2023/01/17/Hgame-2023-note/","content":"WEEK1RSATASK：\nfrom Crypto.Util.number import *flag = open('flag.txt', 'rb').read()p = getPrime(512)q = getPrime(512)n=p*qe = 65537m = bytes_to_long(flag)c = pow(m, e, n)print(f\"c={c}\")print(f\"n={n}\")\"\"\"c=110674792674017748243232351185896019660434718342001686906527789876264976328686134101972125493938434992787002915562500475480693297360867681000092725583284616353543422388489208114545007138606543678040798651836027433383282177081034151589935024292017207209056829250152219183518400364871109559825679273502274955582n=135127138348299757374196447062640858416920350098320099993115949719051354213545596643216739555453946196078110834726375475981791223069451364024181952818056802089567064926510294124594174478123216516600368334763849206942942824711531334239106807454086389211139153023662266125937481669520771879355089997671125020789\"\"\"\n\n\n\nWP：\n直接分解N，求解\n#HGAME-RSAfrom Crypto.Util.number import *import gmpy2  n=135127138348299757374196447062640858416920350098320099993115949719051354213545596643216739555453946196078110834726375475981791223069451364024181952818056802089567064926510294124594174478123216516600368334763849206942942824711531334239106807454086389211139153023662266125937481669520771879355089997671125020789e=65537c=110674792674017748243232351185896019660434718342001686906527789876264976328686134101972125493938434992787002915562500475480693297360867681000092725583284616353543422388489208114545007138606543678040798651836027433383282177081034151589935024292017207209056829250152219183518400364871109559825679273502274955582p=11239134987804993586763559028187245057652550219515201768644770733869088185320740938450178816138394844329723311433549899499795775655921261664087997097294813q=12022912661420941592569751731802639375088427463430162252113082619617837010913002515450223656942836378041122163833359097910935638423464006252814266959128953phi=(p-1)*(q-1)d=gmpy2.invert(e,phi)m=pow(c,d,n)print(m)print(long_to_bytes(m))\n\nflag:  hgame{factordb.com_is_strong!}\nMORSE+Task:\n学校突然放假了，tr0uble正在开开心心的收拾东西准备回家，但是手机铃声突然响起，tr0uble接起电话，但是只听到滴答滴答的声音。努力学习密码学的tr0uble一听就知道这是什么，于是马上记录下来并花了亿点时间成功破译了，但是怎么看这都不像是人能看懂的，还没等tr0uble反应过来，又一通电话打来，依然是滴答滴答的声音。tr0uble想到兔兔也在学习密码学，于是不负责任地把密文都交给了兔兔，兔兔收到密文后随便看了一眼就不屑地说”这么简单都不会？自己解去，别耽误我抢车票”。 \nEncrypted_message:\n5Yeg5Liq5pif5pyf5YmN77yM5oiR5Lus5pS25Yiw5LiA5Liq56We56eY55qE5raI5oGv44CC5L2G5piv6L+Z5Liq5raI5oGv6KKr6YeN6YeN5Yqg5a+G77yM5oiR5Lus5LiN55+l6YGT5a6D55qE55yf5q2j5ZCr5LmJ5piv5LuA5LmI44CC5ZSv5LiA55+l6YGT55qE5L+h5oGv5piv5YWz5LqO5a+G6ZKl55qE77ya4oCc5Y+q5pyJ5YCS552A57+76L+H5Y2B5YWr5bGC55qE56+x56yG5omN6IO95oq16L6+5YyX5qyn56We6K+d55qE57uI54K54oCd44CC\nbase64解密后得到：\n几个星期前，我们收到一个神秘的消息。但是这个消息被重重加密，我们不知道它的真正含义是什么。唯一知道的信息是关于密钥的：“只有倒着翻过十八层的篱笆才能抵达北欧神话的终点”。\n使用Audacity解析Morse得到加密信息：\n0223e_priibly__honwa_jmgh_fgkcqaoqtmfr\n逆序：\nrfmtqoaqckgf_hgmj_awnoh__ylbiirp_e3220\nW型栅栏密码：\ndef generate_w(string, n):     '''将字符排列成w型'''    array = [['.']*len(string) for i in range(n)] #生成初始矩阵    row =0    upflag = False    for col in range(len(string)): #在矩阵上按w型画出string        array[row][col] = string[col]        if row == n-1:            upflag = True        if row == 0:            upflag = False        if upflag:            row -= 1        else:            row += 1    return arraydef decode(string, n):    '''解密'''    array = generate_w(string, n)    sub = 0    for row in range(n): #将w型字符按行的顺序依次替换为string        for col in range(len(string)):            if array[row][col] != '.':                array[row][col] = string[sub]                sub += 1    msg = []    for col in range(len(string)): #以列的顺序依次连接各字符        for row in range(n):            if array[row][col] != '.':                msg.append(array[row][col])    return array, msgdef crack_cipher(string):    for n in range(2,len(string)):        print(str(n)+'栏:'+''.join(decode(string,n)[1]))if __name__ == \"__main__\":    string = \"rfmtqoaqckgf_hgmj_awnoh__ylbiirp_e3220\"    crack_cipher(string)#18栏: rmocfhm_wo_ybipe2023_ril_hnajg_katfqqg\n\n最后维吉尼亚密码解密：\nKey: vidar\nx def phase5(n1, c1, n2, c2, n3, c3):    r = CRT([c1, c2, c3], [n1, n2, n3])    m = int(r)^(1/3)    print(hex(m)[2:])    n1 = 78642188663937191491235684351005990853149481644703243255021321296087539054265733392095095639539412823093600710316645130404423641473150336492175402885270861906530337207734106926328737198871118125840680572148601743121884788919989184318198417654263598170932154428514561079675550090698019678767738203477097731989c1 = 23419685303892339080979695469481275906709035609088426118328601771163101123641599051556995351678670765521269546319724616458499631461037359417701720430452076029312714313804716888119910334476982840024696320503747736428099717113471541651211596481005191146454458591558743268791485623924245960696651150688621664860n2 = 98174485544103863705821086588292917749386955237408645745685476234349659452606822650329076955303471252833860010724515777826660887118742978051231030080666542833950748806944312437614585352818344599399156268450521239843157288915059003487783576003027303399985723834248634230998110618288843582573006048070816520647c2 = 72080679612442543693944655041130370753964497034378634203383617624269927191363529233872659451561571441107920350406295389613006330637565645758727103723546610079332161151567096389071050158035757745766399510575237344950873632114050632573903701015749830874081198250578516967517980592506626547273178363503100507676n3 = 91638855323231795590642755267985988356764327384001022396221901964430032527111968159623063760057482761918901490239790230176524505469897183382928646349163030620342744192731246392941227433195249399795012672172947919435254998997253131826888070173526892674308708289629739522194864912899817994807268945141349669311c3 = 22149989692509889061584875630258740744292355239822482581889060656197919681655781672277545701325284646570773490123892626601106871432216449814891757715588851851459306683123591338089745675044763551335899599807235257516935037356212345033087798267959242561085752109746935300735969972249665700075907145744305255616​phase5(n1,c1,n2,c2,n3,c3)# 464c41477b325e3872736138633566336366663462633039353334396665633635666332323633653837387dpython\nStream CipherTask:\n很喜欢李小龙先生的一句话”Be water my friend”，但是这条小溪的水好像太多了。\nfrom flag import flagassert type(flag) == byteskey = [int.from_bytes(b\"Be water\", 'big'), int.from_bytes(b\"my friend\", 'big')]def stream(i):    if i==0:        return key[0]    elif i==1:        return key[1]    else:        return (stream(i-2)*7 + stream(i-1)*4)enc = b\"\"for i in range(len(flag)):    water = stream((i//2)**6) % 256    enc += bytes([water ^ flag[i]])print(enc)# b'\\x1a\\x15\\x05\\t\\x17\\tu\"-\\x06lm\\x01-\\xc7\\xcc2\\x1eXA\\x1c\\x15\\xb7\\xdb\\x06\\x13\\xaf\\xa1-\\x0b\\xd4\\x91-\\x06\\x8b\\xd4-\\x1e\\xab\\xaa\\x15-\\xf0\\xed\\x1f\\x17\\x1bY'\n\n\n\n\n\n\n\nwp:\n参考官方wp: 这道题给了⼤家⼀个跑不出来的程序，需要优化程序得到flag。优化⽅法还挺多的，预期是⽤矩阵快速幂的⽅法。\n回到本题，根据递归函数可以得到stream的递推式 S[ i ] = 4 ∗ S [ i − 1] + 7 ∗ S [ i − 2]\n类似于斐波那契数列，只不过增加了系数。 考虑⽤斐波那契矩阵和矩阵快速幂优化\nenc = b'\\x1a\\x15\\x05\\t\\x17\\t\\xf5\\xa2-\\x06\\xec\\xed\\x01-\\xc7\\xcc2\\x1eXA\\x1c\\x157[\\x06\\x13/!-\\x0b\\xd4\\x91-\\x06\\x8b\\xd4-\\x1e+*\\x15-pm\\x1f\\x17\\x1bY'def mul(a, b):   c = [[0, 0], [0, 0]]   for i in range(2):      for j in range(2):         for k in range(2):            c[i][j] += (a[i][k] * b[k][j]) % 256            c[i][j] %= 256   return c def power(n):   if n==1: return key[1] % 256   if n==0: return key[0] % 256   res = [[1, 0], [0, 1]]   A = [[4, 7], [1, 0]]   while n:      if n &amp; 1: res = mul(A, res)      A = mul(A, A)      n &gt;&gt;= 1   return (res[1][0] * key[1] + res[1][1] * key[0]) % 256flag = b''for i in range(0, len(enc)):   water = power((i//2)**6)   flag += bytes([water ^ enc[i]])print(flag)\n\n\n\nfrom flag import flag        #flag未知assert type(flag) == bytes   #assert要求表达式的布尔值必须为真，说明flag的数据形式为byteskey = [int.from_bytes(b\"Be water\", 'big'), int.from_bytes(b\"my friend\", 'big')]#key=[4784265876259235186,2019423192753765707364]def stream(i):    if i==0:        return key[0]   #key[0]=4784265876259235186    elif i==1:        return key[1]   #key[1]=2019423192753765707364    else:        return (stream(i-2)*7 + stream(i-1)*4)enc = b\"\"for i in range(len(flag)):       water = stream((i//2)**6) % 256     #地板除向下取整 114 110    enc += bytes([water ^ flag[i]])print(enc)# b'\\x1a\\x15\\x05\\t\\x17\\tu\"-\\x06lm\\x01-\\xc7\\xcc2\\x1eXA\\x1c\\x15\\xb7\\xdb\\x06\\x13\\xaf\\xa1-\\x0b\\xd4\\x91-\\x06\\x8b\\xd4-\\x1e\\xab\\xaa\\x15-\\xf0\\xed\\x1f\\x17\\x1bY' \n\n\n\n\n\n\n\n\n\n","tags":["CTF小试"]},{"title":"Hello World","url":"/2022/12/16/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"Python-study","url":"/2023/02/24/Python-study/","content":"Python学习笔记(Python教程 - 廖雪峰的官方网站 (liaoxuefeng.com) )By：jrl\n一、Python基础1.多行注释：\n2.变量：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.除法：\n4.Unicode与Utf-8：\nUnicode虽然范围广，可以编码汉字，但是占存储空间大，所以转为Utf-8储存。\n\n5.字符编码：由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。\n\n\n文件开头一般写入的注释：\n#!/usr/bin/env python3# -*- coding: utf-8 -*-\n\n\n\n\n6.格式化字符串的方法：1）使用占位符\n'Age: %s. Gender: %s' % (25, True)'growth rate: %d %%' % 7   # %%转义字符 表示一个%\n\n\n\n\n\n\n\n2）foramt()\n3）f-strng\n\n7.list与tuple(1)listPython内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。\n#egclassmates = ['Michael', 'Bob', 'Tracy']len(classmates)  #获得list元素的个数classmates[0]   #用索引来访问list中每一个位置的元素classmates[-1]  #访问最后一个元素的位置classmates.append('Adam')  # append() 可以往list中追加元素到末尾classmates.insert(1, 'Jack')  #也可以把元素插入到指定的位置classmates.pop()  # pop(i) 删除list末尾的元素\n\n\n\n(2)tuple另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改\nclassmates = ('Michael', 'Bob', 'Tracy')t = () #或者()  定义空tuplet=(1,) #定义只有一个元素的tuple\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n8.条件判断elif(else if)\nage = 20if age &gt;= 6:    print('teenager')elif age &gt;= 18:    print('adult')else:    print('kid')\n\n\n\ninput()的返回类型是str,str不能直接与整数比较，须转化\ns = input('birth: ')birth = int(s)if birth &lt; 2000:    print('00前')else:    print('00后')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.循环(1)for  in  循环#历遍list或者tulpe中的元素names = ['Michael', 'Bob', 'Tracy']for name in names:    print(name)        #求和    sum = 0for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:    sum = sum + xprint(sum)\n\n\n\n当须历遍的范围过大时，可使用range()函数\nlist(range(5))    #[0, 1, 2, 3, 4]  0-4sum = 0for x in range(101):    sum = sum + xprint(sum)\n\n\n\n\n\n(2)while循环只要条件满足，就不断循环，条件不满足时退出循环\nsum = 0n = 99while n &gt; 0:    sum = sum + n    n = n - 2print(sum)\n\n\n\n\n\nbreak\n在循环中，break语句可以提前退出循环\nn = 1while n &lt;= 100:    if n &gt; 10: # 当n = 11时，条件满足，执行break语句        break # break语句会结束当前循环    print(n)    n = n + 1print('END')\n\n\n\n\n\ncontinue\n在循环过程中，也可以通过continue语句，跳过当前的这次循环，直接开始下一次循环。\nn = 0while n &lt; 10:    n = n + 1    if n % 2 == 0: # 如果n是偶数，执行continue语句        continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行    print(n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n10.dict和set(1)dictPython内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。\n先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢，给定一个名字，比如'Michael'，dict在内部就可以直接计算出Michael对应的存放成绩的“页码”，也就是95这个数字存放的内存地址，直接取出来，所以速度非常快。\n#初始化d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}d['Adam'] = 67#查找d['Michael']#删除#要删除一个key，用pop(key)方法，对应的value也会从dict中删除： d.pop('Bob')\n\n\n\n由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉，如果key不存在，dict就会报错要避免key不存在的错误，有两种办法\n一是通过in判断key是否存在：\n'Thomas' in d\n\n二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value：\nd.get('Thomas')d.get('Thomas', -1)\n\n要删除一个key，用pop(key)方法，对应的value也会从dict中删除： d.pop('Bob')\n\n\n\n\n\ndict与list比较请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。\n和list比较，dict有以下几个特点：\n\n查找和插入的速度极快，不会随着key的增加而变慢；\n需要占用大量的内存，内存浪费多。\n\n而list相反：\n\n查找和插入的时间随着元素的增加而增加；\n占用空间小，浪费内存很少。\n\n所以，dict是用空间来换取时间的一种方法。\ndict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。\n这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。\n要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：\n(2)set set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。\n#要创建一个set，需要提供一个list作为输入集合：s = set([1, 2, 3])#注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的     重复元素在set中自动被过滤：s = set([1, 1, 2, 2, 3, 3])                #  &gt;&gt; s    {1, 2, 3}#通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果：s.add(4)#通过remove(key)方法可以删除元素：s.remove(4)#set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：&gt;&gt;&gt; s1 = set([1, 2, 3])&gt;&gt;&gt; s2 = set([2, 3, 4])&gt;&gt;&gt; s1 &amp; s2{2, 3}&gt;&gt;&gt; s1 | s2{1, 2, 3, 4}\n\n\n\n\n\nset与dict比较set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。\n不可变对象str是不变对象，而list是可变对象\n#对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：a = ['c', 'b', 'a']&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a['a', 'b', 'c']#对于不可变对象，比如str，对str进行操作呢：&gt;&gt;&gt; a = 'abc'&gt;&gt;&gt; a.replace('a', 'A')'Abc'&gt;&gt;&gt; a'abc'#replace并不是真的改变了变量a所指向的字符串\"abc\"，而是创建了一个新的变量b，指向\"Abc\"\n\n\n二、函数1.调用函数可以通过官网来调查函数： http://docs.python.org/3/library/functions.html#abs \n也可以在交互式命令行通过help(),查看函数的帮助信息。\n#eg: 数据类型转换&gt;&gt;&gt; int('123')123&gt;&gt;&gt; int(12.34)12&gt;&gt;&gt; float('12.34')12.34&gt;&gt;&gt; str(1.23)'1.23'&gt;&gt;&gt; str(100)'100'&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool('')False\n\n函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：\n&gt;&gt;&gt; a = abs # 变量a指向abs函数&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.定义函数在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。\n我们以自定义一个求绝对值的my_abs函数为例：\ndef my_abs(x):    if x &gt;= 0:        return x    else:        return -x         ''' 请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。return None可以简写为return。 '''# 如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目录下启动Python解释器，用from abstest import my_abs来导入my_abs()函数，注意abstest是文件名（不含.py扩展名）：\n\n\n\n交互式环境\n\n(1)空函数如果想定义一个什么事也不做的空函数，可以用pass语句：\ndef nop():    pass# pass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。# pass还可以用在其他语句里，比如：if age &gt;= 18:    pass\n\n\n\n\n\n(2)参数检查调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError：\n&gt;&gt;&gt; my_abs(1, 2)Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: my_abs() takes 1 positional argument but 2 were given\n\n\n\n但是如果参数类型不对，Python解释器就无法帮我们检查。试试my_abs和内置函数abs的差别：\n&gt;&gt;&gt; my_abs('A')Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;  File \"&lt;stdin&gt;\", line 2, in my_absTypeError: unorderable types: str() &gt;= int()&gt;&gt;&gt; abs('A')Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: bad operand type for abs(): 'str'\n\n\n\n当传入了不恰当的参数时，内置函数abs会检查出参数错误，而我们定义的my_abs没有参数检查，会导致if语句出错，出错信息和abs不一样。所以，这个函数定义不够完善。\n让我们修改一下my_abs的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数isinstance()实现：\ndef my_abs(x):    if not isinstance(x, (int, float)):        raise TypeError('bad operand type')    if x &gt;= 0:        return x    else:        return -x\n\n\n\n添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误：\n&gt;&gt;&gt; my_abs('A')Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;  File \"&lt;stdin&gt;\", line 3, in my_absTypeError: bad operand type\n\n\n\n\n\n\n\n\n\n\n\n(3)关于返回值Python中的返回值是唯一的\nEg： 在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标：\nimport mathdef move(x, y, step, angle=0):    nx = x + step * math.cos(angle)    ny = y - step * math.sin(angle)    return nx, ny\n\n然后，我们就可以同时获得返回值：\n&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print(x, y)151.96152422706632 70.0\n\n但其实这只是一种假象，Python函数返回的仍然是单一值：\n&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print(r)(151.96152422706632, 70.0)\n\n原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。\n3.函数的参数Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。\n(1)位置参数我们先写一个计算x2的函数\n对于power(x)函数，参数x就是一个位置参数\n修改后的power(x, n)函数有两个参数：x和n，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数x和n。\ndef power(x, n):    s = 1    while n &gt; 0:        n = n - 1        s = s * x    return s\n\n\n\n\n\n(2)默认参数新的power(x, n)函数定义没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用：\n&gt;&gt;&gt; power(5)Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: power() missing 1 required positional argument: 'n'\n\n这个时候，默认参数就排上用场了。由于我们经常计算x2，所以，完全可以把第二个参数n的默认值设定为2：\ndef power(x, n=2):    s = 1    while n &gt; 0:        n = n - 1        s = s * x    return s\n\n而对于n &gt; 2的其他情况，就必须明确地传入n，比如power(5, 3)。\n从上面的例子可以看出，默认参数可以简化函数的调用。设置默认参数时，有几点要注意：\n一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；\n二是如何设置默认参数。\n当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。\n使用默认参数有什么好处？最大的好处是能降低调用函数的难度。\n举个例子，我们写个一年级小学生注册的函数，需要传入name和gender两个参数：\ndef enroll(name, gender):    print('name:', name)    print('gender:', gender)   #如果要继续传入年龄、城市等信息怎么办？这样会使得调用函数的复杂度大大增加。我们可以把年龄和城市设为默认参数，这样，大多数学生注册时不需要提供年龄和城市，只提供必须的两个参数：def enroll(name, gender, age=6, city='Beijing'):    print('name:', name)    print('gender:', gender)    print('age:', age)    print('city:', city)       #只有与默认参数不符的学生才需要提供额外的信息：enroll('Bob', 'M', 7)enroll('Adam', 'M', city='Tianjin')#也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用enroll('Adam', 'M', city='Tianjin')，意思是，city参数用传进去的值，其他默认参数继续使用默认值。\n\n\n\n默认函数最大的坑：\n#先定义一个函数，传入一个list，添加一个END再返回：def add_end(L=[]):    L.append('END')    return L#当你正常调用时，结果似乎不错：&gt;&gt;&gt; add_end([1, 2, 3])[1, 2, 3, 'END']&gt;&gt;&gt; add_end(['x', 'y', 'z'])['x', 'y', 'z', 'END']#当你使用默认参数调用时，一开始结果也是对的：&gt;&gt;&gt; add_end()['END']#但是，再次调用add_end()时，结果就不对了：&gt;&gt;&gt; add_end()['END', 'END']&gt;&gt;&gt; add_end()['END', 'END', 'END']\n\n这是因为：\nPython函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。\n 定义默认参数要牢记一点：默认参数必须指向不变对象！\n#要修改上面的例子，我们可以用None这个不变对象来实现：def add_end(L=None):    if L is None:        L = []    L.append('END')    return L#为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。\n\n\n\n\n\n\n\n\n\n(3)可变参数在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。\n我们以数学题为例子，给定一组数字a，b，c……，请计算a2 + b2 + c2 + ……。\n要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下：\ndef calc(numbers):    sum = 0    for n in numbers:        sum = sum + n * n    return sum#但是调用的时候，需要先组装出一个list或tuple：&gt;&gt;&gt; calc([1, 2, 3])14&gt;&gt;&gt; calc((1, 3, 5, 7))84\n\n\n\n我们把函数的参数改为可变参数：\nPython允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去：\n*nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。\n#调用该函数时，可以传入任意个参数，包括0个参数：&gt;&gt;&gt; calc(1, 2)5&gt;&gt;&gt; calc()0def calc(*numbers):    sum = 0    for n in numbers:        sum = sum + n * n    return sum\n\n\n\n\n\n\n\n\n\n(4)关键字参数","categories":["Programming"],"tags":["Python"]},{"title":"C-Study-1","url":"/2023/02/20/C-Study-1/","content":"C-STUDY-1一、指针（(14条消息) C语言指针详解(经典,非常详细)_liu100m的博客-CSDN博客_c语言指针用法详解 ）1.指针类型的意义指针类型决定了：指针解引用的权限有多大，以及“+1”时走的步长(int,4字节  char，1字节，因为只跳过一个字符)\n#include&lt;stdio.h&gt;int main(){    int arr[10]={0};    int*p=arr;    for(int i=0;i&lt;10;i++)               //整形数据占4字节，若换成 char*p则无法将arr中的元素全赋值为0    {        *(p+i)=0;    }    for(int i=0;i&lt;10;i++)    {        printf(\"%d\\n\",arr[i]);    }    return 0;}\n\n记得将指针初始化，若不知道则赋值为空指针\nint*p=NULL;   //此时仍然无法赋值，因为NULL不属于个人\n2.指针的运算指针-指针  得到的是两个指针间元素的个数  (前提是指针类型相同且指向同一空间)\n指针+指针   无意义\n#include&lt;stdio.h&gt;int main(){    int arr[10]={1,2,3,4,5,6,7,8,9,10};    printf(\"%d\\n\",&amp;arr[9]-&amp;arr[0]);    return 0;}\n\n\n\n\n\n\n\n3.指针与数组数组名是数组首元素的首地址\n#include&lt;stdio.h&gt;int main(){  int arr[10]={0,1,2,3,4,5,6,7,8,9};  printf(\"%p\",arr);   //等价于  printf(\"%p\",&amp;arr[0]);  return 0;}\n\n\n\n\n\n\n\n4.二级指针#include&lt;stdio.h&gt;int main(){    int a=7;    int*p=&amp;a;      //p是指针变量，一级指针    int**pa=&amp;p;   //pa也是指针变量，二级指针   &amp;pa取出pa在内存中的起始地址    return 0；}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n二、文件((14条消息) C语言文件操作（含详细步骤）_zjruiiiiii的博客-CSDN博客_c语言文件操作 )\n三、链表((14条消息) C语言链表超详解_rivencode的博客-CSDN博客 )\n？\n","categories":["Programming"],"tags":["C-study"]},{"title":"Summary","url":"/2023/06/18/Summary/","content":"一 、RSA1.1 What is RSA1.1.1 Define RSA： 1977年，麻省理工学院的 Ron Rivest、Adi Shamir 和 Leonard Adleman 共同提出了一种非对称加密\n算法，用他们三人的姓氏缩写命名为 RSA。RSA 既不是惟一，也不是最早的非对称加密算法。但它是使\n用最广泛，因而也是最重要的非对称加密算法。\n1.1.2 Basic principle：eg：假设Alice和Bob要在网上进行加密通信，他们要怎么应用RSA来加密和解密信息呢？步骤如下：\n1.随机选择两个不相同的素数 p , q。\n2.将p , q 相乘，记为n &#x3D; p × q 。\n3.计算n的欧拉函数φ( n )，欧拉函数证明，当 p , q 为不相同的素数时，φ(n)&#x3D;(p−1)(q−1) 。\n4.随机选择一个整数 e ，满足两个条件：φ(n)与e互质,且1&lt;e&lt;φ(n) 。\n5.计算e对于φ(n) 的模反元素d，也就是说找到一个d满足 ed &#x3D; 1 mod φ(n)。这个式子等价于\ned−1&#x3D;kφ(n)，实际上就是对于方程ed−kφ(n)&#x3D;1求(d,k)的整数解。这个方程可以用扩展欧几里得算法求\n解。\n6.最终把(e,n)封装成公钥,(d,n)封装成私钥。\n公钥与私钥的产生 ：\n1.随机选择两个不同大质数 p 和 q，计算 N&#x3D;p×q\n2.根据欧拉函数，求得 φ(N)&#x3D;φ(p)φ(q)&#x3D;(p−1)(q−1)\n3.选择一个小于 φ(N)φ(N) 的整数 e，使 e 和 φ(N)互质。并求得 e 关于 φ(N) 的模反元素，命名为 d，有\ned≡1(mod φ(N))\n4.将 p 和 q 的记录销毁，此时，(N,e))是公钥，(N,d) 是私钥。\n消息加密：\n首先需要将消息 以一个双方约定好的格式转化为一个小于 N，且与 N 互质的整数 m。如果消息太长，\n可以将消息分为几段，这也就是我们所说的块加密，后对于每一部分利用如下公式加密：\nm^e≡c (mod N)\n消息解密：\n利用密钥d进行解密。\nc^d≡m (modN)\n正确性证明:\n即我们要证m^ed≡m mod N，已知ed≡1 mod ϕ(N)，那么 ed&#x3D;kϕ(N)+1，即需要证明\nm^kϕ(N)+1≡m mod N\n这里我们分两种情况证明\n第一种情况 gcd(m,N)&#x3D;1，那么 m^ϕ(N)≡1 mod N，因此原式成立。\n第二种情况 gcd(m,N)≠1，那么 m 必然是 p 或者 q的倍数，并且 n&#x3D;mn&#x3D;m 小于 N。我们假设\nm&#x3D;xp\n那么x必然小于 q，又由于q是素数。那么\nm^{kϕ(N)+1}&#x3D;m+uqm&#x3D;m+uqxp&#x3D;m+uxN\n所以原式成立。\n1.1.3 Summariz：欧拉函数与小费马定理\n(https://blog.csdn.net/weixin_30302609/article/details/96312617?ops_request_misc=%7B%22request%5Fid%22%3A%22166827222816782391833081%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=166827222816782391833081&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-96312617-null-null.142\nhttp://blog.csdn.net/boksic/article/details/6912381\n1.2 Tools and third-party libaries1.2.1 RSA-tool :使用rsatool工具计算d的值，直接填入p,q,把e &#x3D; 65537转换为16进制在再填入，再点击Calc.D,即可获得\nD的值。在已知d的情况下，我们可以使用此工具将d分解为两个质数p,q，便于解出密文。但前提是已知\n的d不是一个非常大的整数，因为大整数很难被分解。\n1.2.2 Python :Python中的第三方库中有许多有用的函数，通过调用不同的函数，可以进行高效的数学运算，这对于\nRSA问题有极大的帮助，能大大提高破解的效率。\n如 gmpy2\ngmpy2.invert(x,m)求大整数x模m的逆元\nprint(gmpy2.invert(4, 23)) # eg:46 ≡ 1 mod 23 –&gt; 6**gmpy2.powmod(x,y,m)求大整数x的y次幂模m取余\n1.3 Eg analyze1.3.1 Easy RSA:from Geek Challenge 2022:\nn&#x3D;\n6998481475728885783197750918520850086672477175656162927968781930122248321872866\n3\ne&#x3D; 65537\nc&#x3D;\n6767284506351741544248617509644866461758157956488531184232610787180559569745470\n1\n思路分析：\n题目中给出了n,e,c\n通过观察发现n较小，可以尝试将其分解为p,q，再调用gmpy.2函数解出d,进而解出flag\n代码如下：\nprint(gmpy2.powmod(3, 3, 5)) # eg: 333 mod 5 –&gt; 2 \nprint(gmpy2.powmod(3, 2, 5)) # eg: 3*3 mod 5 –&gt; 4 \nimport gmpy2 \nimport binascii \ne &#x3D; 65537从而解出flag:\nb’SYC{5t4rt_R5A_ls_1t_3a5y?}’\n1.3.2 Crypto–RSA:from Crypto.Util.number import *import gmpy2 as gpflag = b&#x27;xxxxxxxxx&#x27;m=bytes_to_long(flag)p = getPrime(1024)q = getPrime(1024)n = p*q*qphi = q*(p-1)*(q-1)e = 0x10001d = gp.invert(e,phi)c1 = gp.powmod(m,e,n)c2 = gp.powmod(d,e,n)print(c1)print(c2)print(n)&#x27;&#x27;&#x27;14509379790282216731965263256391304920435944160691429937132813276173793784148298520477299169344655838268721129596612507243272811458526087788248191753718534890942856041592962539985956564079887975146491666585807765209871888037151776115227608751460887262303306387556335682644976813531560028668655343582938424513443366495975004969678298240376753135034068427887193962225383594250883659757016400948044532691983148400120793146984804396122299969130456660593233184448173499438760467678006235132399370083206401606340646709053994403659316278177783139867306487788815996588005473022366137802701321068676233903137034749449975584204315740369097122521500465517531264362750200962081675477858875972327525301089556747574239109066966798877771707160055371923883082199967563095816246054788154410985010523623215930953782040387272785539118194123321123587625079895916754686084365932640580302428247003702061562681653408452239029912633217914665483249427610379108377189670613441955119794879945650448935619329207591863347850074406758945501668606322978730084004775948741225498242596510429069890188734971463262832207338509259636158197186473231084030611277970142135506452566914392952406514161769385333654288558315100417373198672146898364766659160370806483032661626096448246797827676729581606342709969920561820508157704645093523526223435723687574259355146223059724195082108488756975882551413208621693276649009903367179575066266673604798237758134158822234458880819086205540111304355202712376749562740802613008613260404056634272076658688987063643965272417337144452612006574056543705738274650069505346656886598742666804826134021330227393996894520875426566412750432339683501873858961170671028054994435471915730331430660759838018535742232100958947763805959195826897767808212953005533895883805276594215123977864023845045386538171770379069368278128946732848722324244150864229348629158013373287002712425388307525352609100624748000272472736874666500547841318591852594619595724087209914853196867692948250150501764076446154470673884523284309784517787183054246280337398098853243684127104584733672924352341481572093454807255602936733377039997650201840331363344239719297203152251916861311582291699460040753803661345073084832894779090488743449087119526126541942853573076715474894397009565884537900866295889520532273851131982999253534600891259155672158005086674638844910604020655531132043490450001206903667855774008230185435154887685054704162605627162865608268235359819470906793478144795375880249991003056592569994537140155966341660560671914544355445680021310815797523132967939090744815795215539133448449248304650191105105400480778072455609675366453408226825706923640521370456175259373003734277093133962318272307543941384223016249143554311711183964923672359210163040661231350422086972190979806820525109574548334715135305259&#x27;&#x27;&#x27;\n\n\n\n\n\n\n\n分析：1.p与q都是随机的1024位的二进制数，这使得n会变得非常大，加之大正整数是很难分解的，所以这道\n题并不是通过分解n来求解的。\n2.e &#x3D; 0x10001 十六进制转换为十进制及e&#x3D;65537\n3.n &#x3D; pqq\nphi &#x3D; q*(p-1)*(q-1)\n观察发现n与phi有公因子q\n4.c1 &#x3D; gp.powmod(m,e,n) 即 m^e&#x3D;k1pq*q+c1 *\nc2 &#x3D; gp.powmod(d,e,n) 即**d^e&#x3D;k2pqq+c2\n解题思路：\n 1.题目给出了一组c1,c2,n的值，泄露了d的信息，即d^e mod n。同时我们发现phi与n有公因子\nq,n&#x3D;pqq,phi&#x3D;(p-1)(q-1)q。\n2.(d^e mod n )*(e^e mod n) mod n&#x3D; (de)^e mod n&#x3D;(kphi+1)^e mod n。\n3.那么我们现在的想法就是设法求出q,再将n分解为p,q，接着就可以通过逆元求解出d的值。\n4.这样我们就知道c即c1,n,d的值，进而解出m，破译密文。\n二、Hash2.1 What is Hash2.1.1 Hash and background: Hash,一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过\n散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空\n间通常远小于输入的空间。它其实就是一个算法，最简单的算法就是加减乘除，比方，我设计个数字算\n法，输入+7&#x3D;输出，比如我输入1，输出为8；输入2，输出为9。\n哈希算法不过是一个更为复杂的运算，它的输入可以是字符串，可以是数据，可以是任何文件，经过哈\n希运算后，变成一个固定长度的输出，该输出就是哈希值。但是哈希算法有一个很大的特点，就是你不\n能从结果推算出输入,所以又称为不可逆的算法。\n安全，这是Hash的最大优点！\n2.1.2 Hash’s advantages:1.不可逆：在具备编码功能的同时，哈希算法也作为一种加密算法存在。即，你无法通过分析哈希值计\n算出源文件的样子，换句话说：你不可能通过观察香肠的纹理推测出猪原来的样子。\n2.计算极快：20G高清电影和一个5K文本文件复杂度相同，计算量都极小，可以在0.1秒内得出结果。也\n就是说，不管猪有多肥，骨头多硬，做成香肠都只要眨眨眼的时间。\n2.1.3 Applied fields:哈希算法的不可逆特性使其在以下领域使用广泛\n1.密码，我们日常使用的各种电子密码本质上都是基于hash的，你不用担心支付宝的工作人员会把你的\n密码泄漏给第三方，因为你的登录密码是先经过 hash+各种复杂算法得出密文后 再存进支付宝的数据库\n里的2.文件完整性校验，通过对文件进行hash，得出一段hash值 ，这样文件内容以后被修改了，hash值就\n会变。 MD5 Hash算法的”数字指纹”特性，使它成为应用最广泛的一种文件完整性校验和(Checksum)算\n法，不少Unix系统有提供计算md5 checksum的命令。\n3.数字签名，数字签名技术是将摘要信息用发送者的私钥加密，与原文一起传送给接收者。接收者只有\n用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与解\n密的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息\n被修改过，因此数字签名能够验证信息的完整性。\n此外，hash算法在区块链领域也使用广泛。\n2.2 Eg analyze(MD5 in Hash)2.2.1 MD5MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过一些列的处理后，\n算法输出由四个32位分组组成的128位散列值。具体的步骤如下所示：\n1、填充\n如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得对512求余结果等于448。填充\n的方法是填充一个1和n个0。填充完成后，信息的长度为N*512+448\n2、记录信息长度\n用64位内存来存储填充前信息长度。这64位加在第一步结果的后面，这样信息长度就变为N512 + 448 +\n*64 &#x3D; (N+1)*512\n3、装入标准的幻数（四个整数）\n标准的幻数（物理顺序）是（A&#x3D;(01234567)16，B&#x3D;(89ABCDEF)16，C&#x3D;(FEDCBA98)16，D&#x3D;\n(76543210)16）。如果在程序中定义应该是（A&#x3D;0X67452301L，B&#x3D;0XEFCDAB89L，\nC&#x3D;0X98BADCFEL，D&#x3D;0X10325476L)。\n2.2.2 Crypto–md5:一个名为Hacker的人想给小彭加德育分，但是需要小彭的学号和寝室号才能完成加分。\nHacker自己只找到了学号和寝室号对应的md5值，聪明的你能帮助Hacker拿到学号和寝室号吗？\n学号：71c5a9bd7cc3a8e563efe4171f07b427\n寝室号：cb1592d95b7e3846451eab3728eeaa51\n分析：\nmd5是一种信息摘要算法，不可反向解密，不同长度的内容加密后都是32位。它是单向密码体制，从明\n文到密文的不可逆映射，只有加密过程没有解密过程，所以我们没法通过运算来解开密文得到明文。由\n于md5是一种散列函数，运用Hash算法，在计算过程中原文会随机丢失，仅仅根据MD5的计算过程和\n得到的最终结果，是无法逆向计算出明文的。\n1.题目中的MD5密文并未加入盐作为干扰，都是标准的32位密文，解密时并没有非常困难，可以通过考\n虑穷举法进行暴力求解。\n2.通过迭代组合形成若干明文组，再将明文组进行utf-8编码成密文，然后与题目中的密文进行比较，当\n两者一致时即“破译”成功，输出得到flag。\n脚本如下：\n1.引用hash\n给定范围\n运用for循环进行枚举\n2.学号的格式为：19XXXXXXXX\n我们发现已经给出部分明文，我们只需要解出剩下的8位明文即可，即设置8个变量\n#coding: utf-8 import hashlib dic = &#x27;0123456789&#x27; for i in range(1000):a,b,c,d,e,f,g\n\n\n\n\n\n3.接着组成密文组t \nt =&#x27;19&#x27;+str(a)+str(b)+str(c)+str(d)+str(e)+str(f)+str(g)+str(h)\n\n4.进行MD5算法，utf-8编码，所得密文与原密文比对，正确即输出，得到flag\nmd5 = hashlib.md5(t.encode(&#x27;utf-8&#x27;)).hexdigest() if md5[:32] == &#x27;71c5a9bd7cc3a8e563efe4171f07b427&#x27;: print (t)\n\n\n\n\n\n\n\n\n\n运行\n#coding: utf-8 import hashlib dic = &#x27;0123456789&#x27; for i in range(1000):     for a in dic:         for b in dic:             for c in dic:                 for d in dic:                     for e in dic:                        for f in dic:                            for g in dic:                                 for h in dic:                                     t =&#x27;19&#x27;+str(a)+str(b)+str(c)+str(d)+str(e)+str(f)+str(g)+str(h)                                     md5 = hashlib.md5(t.encode(&#x27;utf-8&#x27;)).hexdigest()                                     if md5[:32] == &#x27;71c5a9bd7cc3a8e563efe4171f07b427&#x27;:                                         print (t)                                        break\n\n求解完学号，寝室号的解密也是类似的：\n注意到寝室号格式为：XX-XXXX\n那么在组合时注意加入字符‘-’即可\n#coding: utf-8import hashlib from tqdm import tqdm for i in tqdm(range(1000)): pass dic = &#x27;0123456789&#x27; for i in range(1000):         for a in dic:           for b in dic:             for c in dic:               for d in dic:                 for e in dic:                   for f in dic:                                   t =str(a)+str(b)+&#x27;-&#x27;+str(c)+str(d)+str(e)+str(f)                                   md5 = hashlib.md5(t.encode(&#x27;utf-8&#x27;)).hexdigest() #print t if md5[:32] == &#x27;cb1592d95b7e3846451eab3728eeaa51&#x27;: print (t)\n\n\n\n\n\n综上，flag为\nSYC{1919114514,81-2048}\n三、ECC3.1 What is ECC  ECC与RSA一样都属于非对称加密算法，但是，与传统的基于大质数分解难题的加密算法不同，该加密方式基于 “离散对数” 这种数学难题。\n椭圆曲线加密（Elliptic Curve Cryptography），ECC加密算法是一种公钥加密技术，以椭圆曲线理论为基础。利用有限域上椭圆曲线的点构成的Abel群离散对数难解性，实现加密、解密和数字签名。将椭圆曲线中的加法运算与离散对数中的模乘运算相对应，就可以建立基于椭圆曲线的对应密码体制。\n这里我不了解什么是群，什么是圆锥曲线理论，所以去CSDN了一下。\n3.1.1 关于群：\n3.1.2 EIgamal：\n\n实例密钥生成选取素数p&#x3D;150001，本原元a&#x3D;7，密钥113\n\n\n\np&#x3D;150001a&#x3D;7d&#x3D;113ad%p66436Ly&#x3D;ad%pprint y66436\n\n\n\n由公式可得公钥为y&#x3D;66436\n 加密，明文为m&#x3D;809,随机整数为k&#x3D;1000\n\n\n\nm&#x3D;809k&#x3D;1000c1&#x3D;ak%pc190429Lc2&#x3D;m*yk%pc215061L\n\n\n\n得到密文为(c1,c2)&#x3D;(90429,15061)\n解密\n根据公式m1&#x3D;c2&#x2F;c1y%p，但其中有模逆运算，不能直接计算，可以用扩展欧几里得算法,先求c1y的模逆\n\n\n\nextended_gcd(c1**d%p,p)(-69199L, 2147L)\n\n\n\n我们所需要的是正数，所以加上p，-69199+p&#x3D;80802\n然后就可以\n\n\n\n80802*c2%p809L\n\n\n\n正是刚开始的明文809\n(https://blog.csdn.net/boksic/article/details/7014386)\n3.1.3 椭圆曲线(Elliptic curve):\n\n\n(3条消息) 椭圆曲线入门详解_boksic的博客-CSDN博客_怎么求解椭圆曲线的全部解点\n3.1.4 ECC and background:我们知道，RSA算法的优势就是算法原理简单，可以很容易的构造。但是缺点也很明显，需要足够长的密钥长度来保证数据的安全性。\n\n而现在移动终端的数目在逐渐增多，越来越多的运算是在移动终端上进行的，而移动终端的计算能力有限，超级计算机的计算能力在不断增强。按照摩尔定律，计算机处理器的性能，每两年就会翻一番。\n\n这就必然导致了一个矛盾：\n\n由此，ECC加密算法应运而生。引文链接：https://blog.csdn.net/xuanli4845/article/details/115907886\n3.2 ECC’s advantagesECC主要优势是可以使用更小的密钥并提供相当高等级的安全。ECC164位的密钥产生一个安全级，相当于RSA 1024位密钥提供的保密强度，而且计算量较小，处理速度更快，存储空间和传输带宽占用较少。目前我国居民二代身份证正在使用 256 位的椭圆曲线密码，虚拟货币比特币也选择ECC作为加密算法。对于ECC加密算法的优点，那就是性能上的提升，同样的密钥长度，基于ECC加密要比基于RSA安全很多。\n总结来说就是ECC算法能在短时间内达到RSA的加密效果，同时ECC的密钥更短，存储效率高，通信效率高。\n3.3 ECC’s principle3.3.1 Define ECC:在有限域Fp中定义一个椭圆曲线，常用y2&#x3D;x3+ax+b\nFp中只有p个元素，p为素数Fp中，a+b≡c (mod p)，a×b≡c (mod p)，a&#x2F;b≡c (mod p)4a^3+27b^2≠0　(mod p)  a，b是小于p的非负整数x，y属于0到p-1间的证书，曲线标记为Ep（a，b）阶：椭圆曲线上一点P，存在正整数n，使得nP&#x3D;O∞，则n为P的阶，若n不存在，则P是无限阶的，有限域上定义的椭圆曲线上所有点的阶都存在。\n椭圆曲线难题\nK&#x3D;kG，其中K,G为Ep（a,b）上的点，k为小于n的整数，n是点G的阶，给定k和G，计算K容易，但是给定K和G，求k就很难了！\n因此，设K为公钥，k为私钥，G为基点。\n加密过程A选定一条椭圆曲线Ep（a,b），并取曲线上一点作为基点GA选择一个私钥k，并生成公钥K&#x3D;kGA将Ep（a,b）和k，G发送给BB收到后将明文编码到Ep（a,b）上一点M，并产生一个随机数rB计算点C1&#x3D;M+rK，C2&#x3D;rGB将C1，C2传给AA计算C1-kC2&#x3D;M+rkG-krG&#x3D;MA对M解码得到明文攻击者只能得到Ep（a,b），G，K，C1，C2，没有k就无法得到M。\n签名验签流程A选定一条椭圆曲线Ep（a，b），并取曲线上一点作为基点GA选择一个私钥k，并生成公钥K&#x3D;kGA产生一个随机数r，计算R(x,y)&#x3D;rGA计算Hash&#x3D;SHA(M)，M‘&#x3D;M(modp)A计算S&#x3D;（Hash+M’k）&#x2F;r(modp)B获得S和M’，Ep(a,b)，K，R(x,y)B计算Hash&#x3D;SHA(M)，M’&#x3D;M(modp)B计算R’&#x3D;（Hash*G+M’K）&#x2F;S&#x3D;(HashG+M’*kG)*r&#x2F;(Hash+M’k)&#x3D;rG&#x3D;R（x,y），若R’&#x3D;R，则验签成功。https://blog.csdn.net/leo_wonty/article/details/7366418\n3.3.2 Eg:Eg1\n\n(3条消息) 椭圆曲线密码算术（ECC）原理_Soul fragments的博客-CSDN博客_ecc原理\n(3条消息) ECC椭圆曲线加解密原理详解(配图)_NFTDigger的博客-CSDN博客_椭圆曲线加密算法原理\nEg2\n\nECC椭圆曲线详解(有具体实例) - Kalafinaian - 博客园 (cnblogs.com)\n3.4 Crypto–ECC阿鲁为了保护自己的qq，使用椭圆曲线加密了自己的qq密码。嘉然觉得这样并不安全，于是决定拿到阿鲁的qq密码证明此事。发现阿鲁的QQ密码就是椭圆曲线的公钥坐标之和。现已知椭圆曲线各参数：\na &#x3D; 2546417962\nb &#x3D; 33279036350\np &#x3D; 190540091407103\n私钥: k &#x3D; 3068869\nG &#x3D; (25040232765915, 122045618759262)\n求公钥K(x, y)\nflag是SYC{}包上x+y的sha256值\nAnalyze:1.通过观察题目我们发现，已知椭圆曲线加密Ep(a,b)参数为\na &#x3D; 2546417962\nb &#x3D; 33279036350\np &#x3D; 190540091407103\n私钥: k &#x3D; 3068869\nG &#x3D; (25040232765915, 122045618759262)\n需要求解的是公钥K(x,y)的横坐标与纵坐标之和的sha256的值\n2.我们已知k与G，求解公钥K相对较简单。但是，如果知道G与K，反过来求解k就会变得很困难。阿鲁为了保护自己的qq，使用椭圆曲线加密了自己的qq密码，其QQ密码为公钥K(x,y)的横坐标与纵坐标之和，这么做显然是不够安全的，我们只需要解出公钥K就“破译”成功。\n\n\n\n根据椭圆曲线上的点的加法运算\n\n我们就计算能得到公钥K，拿到flag\nSolve process：1.写入已知数据\nGx = 25040232765915Gy = 122045618759262a = 2546417962b = 33279036350p = 190540091407103k = 3068869x = Gxy = Gy\n\n\n\n\n\n2.分根据P、Q两点是否重合，进行分类\nfor i in range(k-1):    #若P、Q两点重合    if (x==Gx and y==Gy):        inv = pow(2*Gy, p-2,p)           temp = (3*Gx*Gx+a)*inv%p         #若P、Q两点不重合    else:        inv = pow((x-Gx), p-2,p)        temp = (y-Gy)*inv%p\n\n\n\n\n\n3.再通过椭圆曲线上的加法运算算出公钥K\n xr = (temp*temp-Gx-x)%p    yr = (temp*(x-xr)-y)%p #print(i,xr,yr)    x = xr    y = yrprint(x+y)\n\n\n\n\n\n\n\n\n\n脚本如下：\n#输入已知数据Gx = 25040232765915Gy = 122045618759262a = 2546417962b = 33279036350p = 190540091407103k = 3068869x = Gxy = Gyfor i in range(k-1):    #分类计算K的值    #若P、Q两点重合    if (x==Gx and y==Gy):        inv = pow(2*Gy, p-2,p)   #费马小定理(1/2/Gy)%p=(2Gy)^p-2 %p        temp = (3*Gx*Gx+a)*inv%p         #若P、Q两点不重合    else:        inv = pow((x-Gx), p-2,p)        temp = (y-Gy)*inv%p    xr = (temp*temp-Gx-x)%p    yr = (temp*(x-xr)-y)%p #print(i,xr,yr)    x = xr    y = yrprint(x+y)\n\n\n\n\nQQ:196301645356440\n4.sha256\n#Hash.sha256import hashlibhash=hashlib.sha256();hash.update(bytes(&#x27;196301645356440&#x27;,encoding=&#x27;utf-8&#x27;))print(hash.hexdigest())\n\n得到sha256后的值：a6c50a41e9ff4678ff94a17e893f434952a32b2e70c78dfb726c4d78b4303471\n\n所以，flag为\nSYC{a6c50a41e9ff4678ff94a17e893f434952a32b2e70c78dfb726c4d78b4303471}\n四、Coppersmith&amp;Lattice-based Cryptography4.1 Define4.1.1 Coppersmith：Coppersmith定理攻击，也是针对n\nCoppersmith定理指出在一个e阶的mod n多项式f(x)中，如果有一个根小于n^1&#x2F;e，就可以运用一个O(log n)的算法求出这些根。\n这个定理可以应用于rsa算法。如果e &#x3D; 3并且在明文当中只有三分之二的比特是已知的，这种算法可以求出明文中所有的比特。\n\n4.1.2 Lattice-based Cryptography：Background：\n随着当下量子计算机的研制的迅速进展，量子算法亦是相应得以巨大突破。在量子计算模型下，经典数论假设的密码体系（如大整数分解，计算有限域&#x2F;椭圆曲线上的离散对数问题等），存在多项式时间（PPT）的量子算法，换而言之，经典数论密码体系受到了极大的冲击，将有可能成为旧时代的眼泪。因此，能够抵抗量子计算机攻击的密码——“后量子”或“抗量子”密码便应运而生。\n目前, 用于构建后量子密码系统的常见数学技巧包括：1.杂凑函数,多变量方程(在构造签名方案时较有优势)2.纠错码(更合适构造加密方案)3.格(最通用的一类, 几乎所有经典密码概念都可以在格密码中实现)4.超奇异椭圆曲线同源问题(当下较新的一类, 目前其中较受关注的有密钥交换和签名方案的构造,计算效率很低,还达不到实用性的要求)\n\n(3条消息) 格密码学习笔记（一）_中科院大学网安学院五班的博客-CSDN博客_格密码\n4.2 Crypto–Latticefrom Crypto.Util.number import * import gmpy2 as gp from secret import flag m = bytes_to_long(flag) p = getPrime(1024) q = gp.next_prime(p^getPrime(300)) n = p*q*q  e = 65537 c = gp.powmod(m,e,n) print(&#x27;n =&#x27;,n) print(&#x27;c =&#x27;,c) &#x27;&#x27;&#x27;n = 1657441819757560493500517852783955669448453505565270030410061904903034812851838667903292681076179721746140392331192685190606078940084193957290326586494942522658447994684113206242147782786486488436062862050720479488907160079456425398688762594497865325047151851509869420955094484022711893914207287322595902861633185849920399826569309062936190162679696321445993297117512458125412547050580265204485812236589358129086671672828599162645076611983958397948578920439799452386250795654988454192963915928293305164506837479627943346663261467474305586884553923408358862832788883664773346582688933735310806488603282226770159631772761229230574671474094221451870770630961493950451576998259008044822492004077759659701132437773984472438535462757118722089434990869144816129748753152891554265248737014747786223673274064575777197461593456413962892395208072539632132385626016349698916261814365453919077654267526533803349663404621106450916027162399c = 1593553679265125861785993192995912696703111560484695970440496248832386885660325028592530874649060028886120763183422597047360806209458935841437245811877714862968196063554261763749466409879047920508168205393706964912523940426199563334512062879052144213846731434858189341622618689853479805825788008893681015249513342688073719536077558806766432484683211750233531164855481666588757851308926988995968945742356896847523781439112333434449743267160262042077831263329769226240475721901216575639399568420398732862655239671453285258560223566086632412820111497447791858015410203252987331230298565756895805839776628672153301485185711776486346696438675451218026201460790552063913385567753045113924570385856031061350493346154777923602808727275442959100197205924675240921131973487280067779126475375849306092292239336121622197137677170815075931160633100612695431123755384954524364124384771024043229892682507314656508989478323824687786447911936&#x27;&#x27;&#x27;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n五、Discrete Log5.1 What is Discrete Log离散对数被誉为当代密码学领域的三大基础之一。1976年，Diffifie和Hellman提出了一种密钥协商协议， 产生了首个离散对数系统模型；8年后，ElGamal提出了基于离散对数系统的公钥加密和签名方法，并奠定了离散对数密码学基础。从那时起，围绕离散对数系统产生了不少研究成果，本文阐述离散对数的基本概念，然后介绍基于离散对数的ElGamal的公钥加密方法和数字签名方法（DSA）。\n5.1.1 Define Discrete Log:\n\n定义\n当模 m有原根时，设 a为模 m的一个原根，则当$$ak≡x(mod m)时： Indx≡k(mod ϕ(m))$$，此处的 Indx为 x以整数 a为底，模 ϕ(m)时的离散对数值.\n性质\n离散对数和一般的对数有着相类似的性质：\n\n示例\n对模5，ϕ(5)&#x3D;5−1&#x3D;4.有个原根是2. 因为\n\n离散对数概念 - 瀚海星空 - 周海汉博客 (abloz.com)\n5.2 Crypto–Discrete Logimport gmpy2 as gp from Crypto.Util.number import * from Crypto.Cipher import AES  import random from secret import flag,key def ts(g,p):    return gp.powmod(g,(p-1)//2,p) == 1     class ELG():    def __init__(self,m):        self.m = m      def creation(self):        global p,g                         while True:            p = 2              pr = []             for i in range(10):                 a = getPrime(20)                pr.append(a)                 p *= a**random.randint(1,4)             if isPrime(p+1):                break           p += 1          print(&#x27;p =&#x27;,p)         print(&#x27;pr =&#x27;,pr)         g = 2        while True :            g+=1             if ts(g,p):                break         print(&#x27;g =&#x27;,g)         priv_a = random.randint(1,p-1)         pub_A = gp.powmod(g,priv_a,p)                         print(&#x27;pub =&#x27;,pub_A)         return priv_a,pub_A                 def enc(self,m,pub):        k = random.randint(2&lt;&lt;100,2&lt;&lt;200)          c1 = gp.powmod(g,k,p)         c2 = (m * gp.powmod(pub,k,p)) % p         return c1,c2      def conn(self):         priv,pub = self.creation()         c1,c2 = self.enc(self.m,pub)         return c1,c2        DEBUG = True if DEBUG:     aes = AES.new(key,AES.MODE_ECB)      elg = ELG(bytes_to_long(flag))     c1,c2 = elg.conn()     print(&#x27;c1 =&#x27;,c1)     print(&#x27;c2 =&#x27;,c2)     c = aes.encrypt(flag)      print(&#x27;cipher =&#x27;,bytes_to_long(c))    &#x27;&#x27;&#x27;p = 240311898144666004845993472603553263322756300779157768701176199291766409589743098329948576886913307536581636947347700640539029536089210573230307671485961868117315471159814486642321020898269103855126517533262247331484819745914498053780059371263306840883425781625061104966618125509054939865409539648498696187295927g = 5pub = 134285622222383211593143419284735141120812420703242474727692334574646766372588113350683719458438557808968651014501757534179743215386357063432496866596113430845534517856556614675236061221959886358825348089193378086912994104626194570995572907279789332330634572963965215940753665380396874414753113588963071439984133c1 = 59866977306496443433230989875501170590733738724206572571973692325202707443627775293269002455283846854135556345025196628657530983549383681055008873942332984996831735632074040992205674787686019847478343708531796808561868062324972209667292857694231350874772127330748101130540816455846043028497370515427917876173767c2 = 189736523869687408218680256920128645519881608991064724826055201457101208294761171595467115162913230133265415706153044192480307701067740580637047863932982867754412493322841249939735690673297501484346546496379585941155099078148120702397606052034259931372433234626469922863663420459070532806854867523903923301588710cipher = 106965036567008443490243813427422441161051668015352122219256553139516361341928&#x27;&#x27;&#x27; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n六、Inverse6.1 What is inverse6.6.1 Define inverse:Inverse，即逆元。\n我们都知道倒数的概念，逆元可以说是扩大了概念的倒数。在模运算中，若ab≡1（mod m)，则称b为模m下a的逆元。\n求解公式(a&#x2F;b)%m 时，因b可能会过大，会出现爆精度的情况，所以需变除法为乘法：\n6.1.2 Inverse’s application：那么逆元有什么用呢？(a + b) % p &#x3D; (a%p + b%p) %p （对）(a - b) % p &#x3D; (a%p - b%p) %p （对）(a * b) % p &#x3D; (a%p * b%p) %p （对）(a &#x2F; b) % p &#x3D; (a%p &#x2F; b%p) %p （错）在求余的过程中我们发现只有除法是不能分开运算的，而当a过大时，在计算除法过程中可能会造成比较大的精度损失，所以对于这种情况我们一般会把式子转换成那么(a &#x2F; b) % p &#x3D; (a * inv(b) ) % p &#x3D; (a % p * inv(b) % p) % p来进行计算。这样就解决了除法不能分开计算的问题。需要注意只有a和p互质，a才有关于p的逆元\nhttps://blog.csdn.net/weixin_45757507/article/details/107506285\n6.1.3  Achieve ways：1.费马小定理\n费马小定理：(3条消息) 费马小定理及其应用_不见月光见星光的博客-CSDN博客_费马小定理应用\n费马小定理(Fermat’s little theorem)是数论中的一个重要定理，在1636年提出。\n如果p是一个质数，而整数a不是p的倍数，则有a^（p-1）≡1（mod p）费马小定理规定了p一定为一个质数，所以a和p一定互质那么双方在modp的意义下同时除a可得a^(p-2) ≡1&#x2F;a (mod p)也就是a^(p-2) ≡ inv(a) (mod p)所以inv(a) &#x3D; a^(p-2) (mod p)\n2.扩展欧几里得算法求逆元\n欧几里得算法：(3条消息) 欧几里得算法原理_ltrbless的博客-CSDN博客_欧几里得算法\n如果gcd（a，p）&#x3D;1；那么就有ax+py&#x3D;1双方同时modp就有ax≡1（modp）因为py是p的倍数全部约掉了此时x就是a的逆元所以只需解出该情况下的扩展欧几里得方程的解问题就解决了\n6.2 Inverse–Coding参考书目以及参考的资料：\n《An Introduction to Mathematical Cryptography》\n(3条消息) Python在GF(2⁸)有限域上求解多项式的乘法逆元——基于扩展欧几里得算法_海绵菌的博客-CSDN博客_有限域多项式乘法\n","tags":["面试小结"]},{"title":"Buu-Crypto","url":"/2023/06/18/Buu-Crypto/","content":"BuuCTF刷题记录-Crypto1.异性相吸TASK：\n最近出现了一个奇葩观点，说性别都不一样，怎么能谈恋爱？为了证明这个观点错误，请大家证明异性是相吸的。 \nkey:asadsasdasdasdasdasdasdasdasdasdqwesqf密文：ἇ̀Ј唒ဃ塔屋䩘卖剄䐃堂ن䝔嘅均ቄ䩝ᬔ\n\n\n\nWP：\n\n用010打开两个文件，获得他们的二进制数，再进行异或\n\nfrom Crypto.Util.number import long_to_bytesa = '0110000101110011011000010110010001110011011000010111001101100100011000010111001101100100011000010111001101100100011000010111001101100100011000010111001101100100011000010111001101100100011000010111001101100100011000010111001101100100011000010111001101100100011100010111011101100101011100110111000101100110'b = '0000011100011111000000000000001100001000000001000001001001010101000000110001000001010100010110000100101101011100010110000100101001010110010100110100010001010010000000110100010000000010010110000100011000000110010101000100011100000101010101100100011101010111010001000001001001011101010010100001010000011011'c = ''for i in range(len(a)):    if(a[i] == b[i]):        c+='0'    else:        c+='1'print(c)#0110011001101100011000010110011101111011011001010110000100110001011000100110001100110000001110010011100000111000001110010011100100110010001100100011011100110110011000100011011101100110001110010011010101100010001101010011010001100001001101110011010000110011001101010110010100111000001110010110010101111101print(long_to_bytes(13040004482825639027998127915416848738127988052104145969389882111109559127041106665604212093))#flag{ea1bc0988992276b7f95b54a7435e89e}\n\n\n\n\n\n\n\n\n\n2.RSA（证书公钥解析）TASK：\n\n题目给了两个附件，没遇到过，了解后知道是证书公钥解析类型的题目。（证书公钥解析 - CNW - 博客园 (cnblogs.com) ）\nWP：\n\npub-key:\n\n-----BEGIN PUBLIC KEY-----MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMAzLFxkrkcYL2wch21CM2kQVFpY9+7+/AvKr1rzQczdAgMBAAE=-----END PUBLIC KEY-----\n\n\n\n\n\n\n公钥解析后就是基本的RSA，脚本如下：\n\nimport gmpy2import libnumfrom Crypto.Util.number import *import rsae= 65537n= 86934482296048119190666062003494800588905656017203025617216654058378322103517p= 285960468890451637935629440372639283459q= 304008741604601924494328155975272418463d= 81176168860169991027846870170527607562179635470395365333547868786951080991441key = rsa.PrivateKey(n,e,d,q,p)         #在pkcs标准中,pkcs#1规定,私钥包含(n,e,d,p,q)with open(\"D:\\CTF\\\\buu\\\\0eaf8d6c-3fe5-4549-9e81-94ac42535e7b\\\\flag.enc\",\"rb\") as f:  #以二进制读模式，读取密文    f = f.read()    print(rsa.decrypt(f,key))           # f:公钥加密结果  key:私钥\n\n得到flag：  flag{decrypt_256}\n3.RSA1（dp,dq泄露）TASK：\np = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852\n\n题目给出了p,q,dp,dq,c \n考虑使用crt，欧拉定理求解\nWP：\n\n推导过程如下：\n\n\n\nfrom gmpy2 import invertfrom libnum import*p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852#n=p*qI = invert(q,p)            #求p的逆元mp = pow(c,dp,p)           #求幂取模运算mq = pow(c,dq,q)           #求幂取模运算m = int((((mp-mq)*I)%p)*q+mq) m=m%nprint(n2s(m))             \n\n解出flag： noxCTF{W31c0m3_70_Ch1n470wn}\n","tags":["CTF小试"]},{"title":"Theorem","url":"/2023/07/08/Theorem/","content":"Theorem in Crypto一、Fermat’s Little Theorem（费马小定理）1.定理内容如果p是质数，并且a不是p的倍数。那么就有\n对于正整数a和p，如果有，那么称x的最小整数解为a模p的逆元\n由上面的结论我们可以得到a的逆元其实就是  对于这个数我们可以使用快速幂来计算结果\n2.费马小定理的运用 费马小定理可以用来解决求组合数的问题，在求解组合数的时候，我们虽然可以通过使用杨辉三角来进行求解，但是在一些情况下我们经常需要去求解一个组合数的模，但是那些阶乘超过了我们的运算范围，也需要对它们进行取模，可是这个时候上下同时进行取模的结果是错误的结果。下面我们来进行 a b m o d   p \\frac{a}{b}mod\\space pba\n mod p 的正确求解操作\n 首先有一个前提条件是a mod b = 0 a/b = m\n 假设存在一个数使得ax%p = m\n 由于模运算对于乘法是有效的，所以两边同时乘上b，得到a%p = (m%p)*(b%p)%p\n 两边再同时乘以x，得到m%p = (mb)*x%p，得到 1 = bx%p, 所以我们可以知道这个x其实就是b的逆元，基于这个结论我们可以得到求解的逆元 所以对于组合数对于p的逆元\n在RSA的ctf题目中总有其用武之地\n二、Chinese remainder theorem（中国剩余定理）1.定理内容在《孙子算经》中有这样一个问题：“今有物不知其数，三三数之剩二（除以3余2），五五数之剩三（除以5余3），七七数之剩二（除以7余2），问物几何？”这个问题称为“孙子问题”，该问题的一般解法国际上称为“中国剩余定理”。具体解法分三步：\n\n\n找出三个数：从3和5的公倍数中找出被7除余1的最小数15，从3和7的公倍数中找出被5除余1 的最小数21，最后从5和7的公倍数中找出除3余1的最小数70。\n用15乘以2（2为最终结果除以7的余数），用21乘以3（3为最终结果除以5的余数），同理，用70乘以2（2为最终结果除以3的余数），然后把三个乘积相加15∗2+21∗3+70∗215∗2+21∗3+70∗2得到和233。\n用233除以3，5，7三个数的最小公倍数105，得到余数23，即233%105=23233%105=23。这个余数23就是符合条件的最小数。\n\n\n\n　　就这么简单。我们在感叹神奇的同时不禁想知道古人是如何想到这个方法的，有什么基本的数学依据吗？\n　　我们将“孙子问题”拆分成几个简单的小问题，从零开始，试图揣测古人是如何推导出这个解法的。\n　　首先，我们假设n1是满足除以3余2的一个数，比如2，5，8等等，也就是满足3∗k+2（k&gt;=0）的一个任意数。同样，我们假设n2是满足除以5余3的一个数，n3是满足除以7余2的一个数。\n　　有了前面的假设，我们先从n1这个角度出发，已知n1满足除以3余2，能不能使得n1+n2的和仍然满足除以3余2？进而使得n1+n2+n3的和仍然满足除以3余2？\n　　这就牵涉到一个最基本数学定理，如果有a%b=c，则有(a+k∗b)%b=c(k为非零整数)，换句话说，如果一个除法运算的余数为c�，那么被除数与k倍的除数相加（或相减）的和（差）再与除数相除，余数不变。这个是很好证明的。\n　　以此定理为依据，如果n2是3的倍数，n1+n2就依然满足除以3余2。同理，如果n3也是3的倍数，那么n1+n2+n3的和就满足除以3余2。这是从n1的角度考虑的，再从n2，n3的角度出发，我们可推导出以下三点：\n\n\n为使n1+n2+n3的和满足除以3余2，n2和n3必须是3的倍数。\n为使n1+n2+n3的和满足除以5余3，n1和n3必须是5的倍数。\n为使n1+n2+n3的和满足除以7余2，n1和n2必须是7的倍数。\n\n\n\n　　因此，为使n1+n2+n3的和作为“孙子问题”的一个最终解，需满足：\n\n\nn1除以3余2，且是5和7的公倍数。\nn2除以5余3，且是3和7的公倍数。\nn3除以7余2，且是3和5的公倍数。\n\n\n\n　　所以，孙子问题解法的本质是从5和7的公倍数中找一个除以3余2的数n1，从3和7的公倍数中找一个除以5余3的数n2，从3和5的公倍数中找一个除以7余2的数n3，再将三个数相加得到解。在求n1，n2，n3时又用了一个小技巧，以n1为例，并非从5和7的公倍数中直接找一个除以3余2的数，而是先找一个除以3余1的数，再乘以2。也就是先求出5和7的公倍数模3下的逆元，再用逆元去乘余数。\n　　这里又有一个数学公式，如果a%b=c，那么(a∗k)%b=a%b+a%b+…+a%b=c+c+…+c=k∗c(k&gt;0),也就是说，如果一个除法的余数为c�，那么被除数的k倍与除数相除的余数为k∗c。展开式中已证明。\n　　最后，我们还要清楚一点，n1+n2+n3只是问题的一个解，并不是最小的解。如何得到最小解？我们只需要从中最大限度的减掉掉3，5，7的公倍数105即可。道理就是前面讲过的定理“如果a%b=c，则有所以（n1+n2+n3）%105（就是最终的最小解。\n　　这样一来就得到了中国剩余定理的公式：\n\n设正整数两两互素，则同余方程组\n​               \n有整数解。并且在模下的解是唯一的，解为\n​                \n其中，而为模的逆元。\n\n\n2.中国剩余定理扩展——求解模数不互质情况下的线性方程组：　　普通的中国剩余定理要求所有的互素，那么如果不互素呢，怎么求解同余方程组？\n　　这种情况就采用两两合并的思想，假设要合并如下两个方程：\n\n\n　　那么得到：\n\n\n　　我们需要求出一个最小的x使它满足：\n\n\n　　那么x1和x2就要尽可能的小，于是我们用扩展欧几里得算法求出x1的最小正整数解，将它代回a1+m1x1，得到x的一个特解x’，当然也是最小正整数解。\n　　所以x的通解一定是x′加上lcm(m1,m2)∗k，这样才能保证x模m1和m2的余数是a1和a2。由此，我们把这个x′当做新的方程的余数，把lcm(m1,m2)当做新的方程的模数。（这一段是关键）\n　　合并完成：\n\n\n\n\n\n\n\n\n","categories":["Crypto"],"tags":["Crypto"]},{"title":"MCU-Study","url":"/2023/07/15/MCU-Study/","content":"Contents\n[TOC]\nPart1–初识MCU一、Preparation1. Two applicationsKeil5（编写程序）\n\n\n\n(1)从官网下载Keil5\n\n\n(2)从License Magement中复制你的CID并将其输入keygen中激活\n\n\n\n\n\n注意，以管理员身份运行程序，否则权限不够。  AND    在打开Keygen或者下载前，关闭防火墙，否则有一定概率误杀\n\n\n\n(3)点击Generate，完成激活\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStc-isp（下载程序）这个自行搜索下载\n\n\n在成功下载之后，一般来说无法直接读取或识别外接的C51，这个时候需要安装相应的driver：\n\n\n\n\n\n\n这时候如果在任务管理器中能够能看到USB-SERIAL，说明驱动安装成功，C51已被读取。\n\n\n\n\n\n\n\n\nx def phase5(n1, c1, n2, c2, n3, c3):    r = CRT([c1, c2, c3], [n1, n2, n3])    m = int(r)^(1/3)    print(hex(m)[2:])    n1 = 78642188663937191491235684351005990853149481644703243255021321296087539054265733392095095639539412823093600710316645130404423641473150336492175402885270861906530337207734106926328737198871118125840680572148601743121884788919989184318198417654263598170932154428514561079675550090698019678767738203477097731989c1 = 23419685303892339080979695469481275906709035609088426118328601771163101123641599051556995351678670765521269546319724616458499631461037359417701720430452076029312714313804716888119910334476982840024696320503747736428099717113471541651211596481005191146454458591558743268791485623924245960696651150688621664860n2 = 98174485544103863705821086588292917749386955237408645745685476234349659452606822650329076955303471252833860010724515777826660887118742978051231030080666542833950748806944312437614585352818344599399156268450521239843157288915059003487783576003027303399985723834248634230998110618288843582573006048070816520647c2 = 72080679612442543693944655041130370753964497034378634203383617624269927191363529233872659451561571441107920350406295389613006330637565645758727103723546610079332161151567096389071050158035757745766399510575237344950873632114050632573903701015749830874081198250578516967517980592506626547273178363503100507676n3 = 91638855323231795590642755267985988356764327384001022396221901964430032527111968159623063760057482761918901490239790230176524505469897183382928646349163030620342744192731246392941227433195249399795012672172947919435254998997253131826888070173526892674308708289629739522194864912899817994807268945141349669311c3 = 22149989692509889061584875630258740744292355239822482581889060656197919681655781672277545701325284646570773490123892626601106871432216449814891757715588851851459306683123591338089745675044763551335899599807235257516935037356212345033087798267959242561085752109746935300735969972249665700075907145744305255616​phase5(n1,c1,n2,c2,n3,c3)# 464c41477b325e3872736138633566336366663462633039353334396665633635666332323633653837387dpython\n二、About  MCU1. Brief introduction单片机，英文Micro ControIIer Unit ， 简称MCU\n\n内部集成了CPU 、RAM 、ROM 、定时器、中断系统、通讯接口等一系列电脑的常用硬件功能\n单片机的任务是信息采集（ 依靠传感器） 、处理（ 依靠CPU) 和硬件设备（ 例如电机， LED 等） 的控制\n单片机跟计算机相比， 单片机算是一个袖珍版计算机， 一个芯片就能构成完整的计算机系统。但在性能上， 与计算机相差甚远， 但单片机成本低、体积小、结构简单， 在生活和工业控制领域大有所用。同时， 学习使用单片机是了解计算机原理与结构的最佳选择\n\n51单片机：指80年代Intel开发的8051内核的单片机的统称。\n\n\n\n\n\n\n*类比电脑内存条*：RAM（Random Access Memory，随机存取存储器）是计算机中的一种主要存储设备，用于临时存储和快速访问数据。它是计算机的一个重要组成部分，用于存储正在执行的程序和数据。\nRAM与计算机的硬盘驱动器（或固态驱动器）不同，后者用于长期存储数据，而RAM是一种易失性存储器，意味着其存储的数据在断电或重新启动后会被清除。这是因为RAM是基于电子器件和电路构建的，需要持续的电源供应来保持存储的数据。\nRAM被分为主存储器（Main Memory）和高速缓存（Cache Memory）。主存储器是计算机直接访问的存储区域，用于存储正在运行的程序和数据。它的存取速度比硬盘驱动器等次要存储设备要快得多。高速缓存是位于CPU内部的一种更快速的存储器，用于临时存储处理器频繁访问的数据，以提高计算机的性能。\nRAM的容量通常以兆字节（MB）或千兆字节（GB）进行衡量。较大容量的RAM可以容纳更多的程序和数据，从而提供更好的性能和多任务处理能力。计算机的RAM容量可以根据需要进行扩展或升级。\n总之，RAM是一种临时存储设备，用于存储正在执行的程序和数据，提供计算机的实时访问能力。它在计算机的性能和多任务处理方面起着重要的作用。\n*类比电脑硬盘*：ROM（Read-Only Memory）是一种计算机芯片或存储设备中的一种存储器类型。与随机访问存储器（RAM）相比，ROM在断电后能够保持其存储的数据不变，因此也被称为非易失性存储器。ROM的数据一般是由制造厂商在生产过程中预先写入的，并且用户无法对其进行修改。这意味着ROM中存储的内容是只读的，无法被擦除或重写。\nROM有多种不同类型，包括：\n\nPROM（Programmable Read-Only Memory，可编程只读存储器）：这种ROM允许用户在一次性编程之前将数据写入其中。一旦编程完成，数据将永久固化在芯片中，不可更改。\nEPROM（Erasable Programmable Read-Only Memory，可擦除可编程只读存储器）：这种ROM允许用户通过使用特定设备将其数据擦除，然后再次编程。擦除通常通过使用紫外线光线或电子擦除器来进行。\nEEPROM（Electrically Erasable Programmable Read-Only Memory，电可擦除可编程只读存储器）：EEPROM与EPROM类似，但是擦除操作可以通过电源供电而不需要其他特殊设备。EEPROM的擦除和编程可以在特定的操作条件下进行。\n\nROM的应用非常广泛，它被用于存储启动引导程序、固件、芯片内的固定数据以及其他一些需要在断电后保持不变的数据。有些游戏机、手机和电脑主板中也使用ROM存储固件或操作系统。总之，ROM在计算机和电子设备中起到了重要的作用，并且因其稳定性和数据不易丢失的特点而受到广泛使用。\n2. Application field单片机的使用领域已十分广泛， 如智能仪表、实时工控、通讯设备、导航系统、家用电器等。各种产品一旦用上了单片机， 就能起到使产品升级换代的功效， 常在产品名称前冠以形容词——“智能型”，如智能型洗衣机等。\n3. Naming rules\n\n\n\n\n\n\n\n\n\n4. Structure单片机内部结构图：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n单片机管脚图：\n\n\n例如 Vcc代表 + 极，Gnd代表 - 极\n单片机的最小系统：\n\n\n电容——过滤因为电源不稳定产生的电磁波\n复位电路（中间的）——复位电路通常用来清除存储器中的数据、关闭所有开关和重置相关的逻辑电路。它可以在系统启动时，或在错误发生时，通过将相关电路重新初始化，确保系统处于可控状态。\n晶振（左下角）——用于时钟电路和振荡电路中，以稳定电子设备的工作频率。晶振的主要原理是利用压电效应，在晶体振荡器中产生稳定的振荡信号。推动程序往下进行的关键。\nPart2–编写MCU一、Light up LED \n\nLED，全称为Light Emitting Diode（发光二极管），是一种固体电子器件，可以将电能直接转化为光能。相对于传统的光源，如白炽灯和荧光灯，LED具有更高的能效、更长的使用寿命和更大的可靠性。\nLED的工作原理是基于半导体材料的特性。当电流通过LED时，电子和空穴在半导体材料中重新组合，产生能量释放，从而产生可见光。不同半导体材料的能带结构决定了LED发出的光的颜色。\nLED具有许多优点。首先，LED保存能量且效率高，相比传统光源，LED产生的光功率更大，但消耗的电能更少。其次，LED寿命长，通常可以达到数万个小时，远远超过传统光源。此外，LED具有快速开启和关闭的特性，并且可以根据需要调节亮度，因此被广泛应用于照明和显示领域。\nLED在各个领域有广泛的应用。在照明领域，LED被用于家庭照明、商业照明和街道照明等。由于其高效节能的特性，LED也被用于太阳能照明和绿色建筑项目中。在电子显示领域，LED用于制造各种显示屏，如电视、计算机显示器和手机屏幕。此外，LED还常用于车辆照明、室内装饰、电子设备指示灯等。\n1. 点亮一个LED首先观察MCU里的LED模块\n\n\n\n\n\n\n右边图片中的RP9、RP10是两个电阻                                                                          102=1k(10*10^2)元器件上的标号以此类推\n\n\nP2口下的寄存器控制LED：       1–5V  不亮              0–0V  亮\n\n\n创建一个Project，在列表里的Atmel下选择AT89C52\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n在该文件夹下创建一个C的文件，以便进一步编写程序\n\n\n\n\n\n\n\n 3.编写控制LED的代码\n#include &lt;REGX52.H&gt;void main(){\tP2=0xFE;  }\n\n\n\n\n\n\n\n4.将文件保存为hex格式，以便烧入\n\n\n\n\n\n\n\n\n5.用stc-isp将程序烧入进MCU中，尝试运行\n选择相应的单片机型号与串口号，并打开已写好的程序文件\n\n\n\n\n然后点击下载，重启单片机，发现成功点亮LED\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2. LED闪烁重复(1)中的操作步骤，新建一个Project\n其实要完成闪烁只需要写一个while循环就可以了\n#include &lt;REGX52.H&gt;void main(){\t\twhile(1)\t{\t\tP2=0xFE;\t\tP2=0xFF;\t}}\n\n但这个时候发现LED闪烁周期过快，肉眼无法观察到明显现象，这个时候需要加大周期，即加入延时函数。\n#include &lt;REGX52.H&gt;#include &lt;INTRINS.H&gt;void Delay500ms()\t\t//@12.000MHz{\tunsigned char i, j, k;\t_nop_();\ti = 4;\tj = 205;\tk = 187;\tdo\t{\t\tdo\t\t{\t\t\twhile (--k);\t\t} while (--j);\t} while (--i);}void main(){\t\twhile(1)\t{\t\tP2=0xFE;          //0xAA    左右闪烁\t\tDelay500ms();\t\tP2=0xFF;          //0x55\t\tDelay500ms();\t}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3. LED流水灯有了“前车之鉴”，再写流水灯其实就很简单了，逻辑是一样的。\n#include &lt;REGX52.H&gt;#include &lt;INTRINS.H&gt;void Delay250ms()\t\t//@12.000MHz{\tunsigned char i, j, k;\t_nop_();\ti = 2;\tj = 231;\tk = 91;\tdo\t{\t\tdo\t\t{\t\t\twhile (--k);\t\t} while (--j);\t} while (--i);}void main(){\twhile(1)\t{\t\tP2=0xFE;          \t\tDelay250ms();\t\tP2=0xFD;          \t\tDelay250ms();\t\tP2=0xFB;\t\tDelay250ms();\t\tP2=0xF7;\t\tDelay250ms();\t\tP2=0xEF;\t\tDelay250ms();\t\tP2=0xDF;\t\tDelay250ms();\t\tP2=0xBF;\t\tDelay250ms();\t\tP2=0x7F;\t\tDelay250ms();\t}}\n\n\n\nPro版本：\n#include &lt;REGX52.H&gt;int n=50;void Delay1ms(unsigned int xms)    //@12.000MHz{\tunsigned char i,j;\twhile(xms)\t{\t\ti=2;\t  j=239;\t\tdo\t\t{\t\t\twhile(--j);\t\t} while(--i);\t\txms--;\t}}void main(){\twhile(1)\t{\t\tP2=0xFE;          \t\tDelay1ms(n);\t\tP2=0xFD;          \t\tDelay1ms(n);\t\tP2=0xFB;\t    Delay1ms(n);\t\tP2=0xF7;\t\tDelay1ms(n);\t\tP2=0xEF;\t\tDelay1ms(n);\t\tP2=0xDF;\t\tDelay1ms(n);\t\tP2=0xBF;\t\tDelay1ms(n);\t\tP2=0x7F;\t\tDelay1ms(n);\t}}\n\n\n\n\n\n\n\n\n\n\n\n二、Individual key\n\nC51上的独立按键：底座+金属弹片+   +\n不按下时4个引脚两两连接，按下去时4个引脚同时连接\n\n\n独立按键：\n\n\n4个独立按键一端接 -极，另一端接I/O口（I/O口默认高电平）\n寄存器检测I/O口电平\n1. 独立按键控制LED亮灭sfr：整个8位的寄存器         \n 寄存器中P2表示8位一体，不可单独控制单独位次\n\n\n发现sbit可控制单独位次\n\n\n\n\n\n\n\n\n#include &lt;REGX52.H&gt; void main() {\t//P2=0xFE;\t\t    \t   \twhile(1)  //单独控制P2的第0根管脚\t{\t\tif(P3_1==0)\t\t{\t\t\tP2_0=0;     //读取K1口寄存器\t\t}\t\t\t\telse\t\t\t{\t\t\tP2_0=1;\t\t}\t\t\t\t} }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2. 独立按键控制LED状态\n\n\n\n\n\n#include &lt;REGX52.H&gt;void Delay(unsigned int xms)\t\t//@12.000MHz{\tunsigned char i, j;\twhile(xms)\t{\t\ti = 2;\t\tj = 239;\t\tdo\t\t{\t\t\twhile (--j);\t\t} while (--i);\t\txms--;\t}}void main(){\twhile(1)\t{\t\tif(P3_1==0)   //检测按键是否按下，按下不操作，松手才开始操作（类比于电脑主表操作原理）\t\t{\t\t\tDelay(20);  \t\t\twhile(P3_1==0);\t\t\tDelay(20);\t\t\t\t\t\t\tP2_0=~P2_0;  //按位取反 P2_0只有一位，按位取反在0,1间变化\t\t}\t}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n3. 独立按键控制LED显示二进制项目的创建以及准备工作就不再赘述\n主要是利用 unsigned char 类型（0—255）与寄存器同样为8位的特性，来间接表示LED二进制\n#include &lt;REGX52.H&gt;void Delay(unsigned int xms)\t\t//@12.000MHz{\tunsigned char i, j;\twhile(xms--)\t{\t\ti = 12;\t\tj = 169;  \t\tdo\t\t{\t\t\twhile (--j);\t\t} while (--i);\t}}void main(){\tunsigned char LEDNum=0;\twhile(1)\t{\t\tif(P3_1==0)\t\t{\t\t\tDelay(20);\t\t\twhile(P3_1==0);\t\t\tDelay(20);\t\t\t\tLEDNum++;   //P2++;不行\t\t\tP2=~LEDNum;\t\t}\t}\t}\n\nP2=1111 1111     //P2口默认高电平\nP2++  会使端口溢出，P2变成 0000 0000\n再次取反P2将保持原样，即P2=1111 1111 ，表现为D1—D8全灭      \n4. 独立按键控制LED移位\n\n项目预期：按下P3_1（左1），实现LED从左向右移位1\n​                    按下P3_0（左2)，实现LED从右向左移位1                             \n\n\n[^如图所示]: \n\n\n实现移位的代码如下，主要使用C语言中的位运算：**&lt;&lt; 按位左移** 与 &gt;&gt;按位右移\nP3_1口闭合，左移\n#include &lt;REGX52.H&gt;void Delay(unsigned int xms);unsigned char LEDNum=0;  void main(){\t\twhile(1)\t{\t\tif(P3_1==0)\t\t{\t\t\tDelay(20);\t\t\twhile(P3_1==0);\t\t\tDelay(20);\t\t\t\t\t\tif(LEDNum&gt;7)\t\t\t{\t\t\t\tLEDNum=0;\t\t\t}\t\t\tP2=~(0x01&lt;&lt;LEDNum);    \t\t\tLEDNum++;\t\t}\t}}void Delay(unsigned int xms)\t\t//@12.000MHz{\tunsigned char i, j;\twhile(xms--)\t{\t\ti = 12;\t\tj = 169;  \t\tdo\t\t{\t\t\twhile (--j);\t\t} while (--i);\t}}\n\n与左移逻辑一样，加上右移，完善代码，实现项目预期\n#include &lt;REGX52.H&gt;void Delay(unsigned int xms);   //申明函数unsigned char LEDNum=0;   //8位的全局变量void main(){\tP2=~0x01;        //点亮D1\twhile(1)\t{\t\tif(P3_1==0)    //判断按键是否按下\t\t{\t\t\tDelay(20);             //检测按键状态，即手是否在按下按键后抬起。若未抬起，则按键处于闭合状态，执行while死循环，防止误触\t\t\twhile(P3_1==0);  \t\t\tDelay(20);\t\t\t\t\t\tLEDNum++;\t\t\tif(LEDNum&gt;=8)\t\t\t{\t\t\t\tLEDNum=0;\t\t\t}\t\t\tP2=~(0x01&lt;&lt;LEDNum);\t\t}\t\t\t\tif(P3_0==0)      //判断按键是否按下\t\t{\t\t\tDelay(20);\t\t\twhile(P3_0==0);\t\t\tDelay(20);\t\t\t\t\t\tif(LEDNum==0)\t\t\t{\t\t\t\tLEDNum=7;\t\t\t}\t\t\telse\t\t\t{\t\t\tLEDNum--;  //自减，实现右移\t\t\t}\t\t\tP2=~(0x01&lt;&lt;LEDNum);\t\t}\t}}//延时函数void Delay(unsigned int xms)\t\t//@12.000MHz{\tunsigned char i, j;\twhile(xms--)\t{\t\ti = 12;\t\tj = 169;  \t\tdo\t\t{\t\t\twhile (--j);\t\t} while (--i);\t}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n三、Static digitron display(1)数码管介绍\n\n\n控制数码管显示：\n138译码器和数码管，两者共同作用下控制数码管的显示\n\n\n\n\n(2)数码管引脚定义：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1. 静态数码管显示目标是使数码管的第三位单独显示数字“6”\n步骤为：\n1.控制138译码器选中LED6（标号从右到左）     Y5—101\n2.给予P0口段码数据，经过信号缓冲，再传输至公共段码端\n\n\n\n\n\n\n总共有以下几种实现方式：\n1.共阴极连接\n\n\n2.共阳极连接：\n\n\n\n\n\n\n\n\n\n\n代码如下：\n//第三位数码(LED6)管显示“6”#include &lt;REGX52.H&gt;void main(){\t\tP2_4=1;    // 101=5   LED6由Y5口控制，通过P_2,P_3,P_4口控制Y5输出低电平来点亮LED6\tP2_3=0;\tP2_2=1;\tP0=0x7D;\twhile(1)\t{\t\t}}\n\n\n\n\n\n完整的静态显示代码：\n#include &lt;REGX52.H&gt;unsigned char NixieTable[]={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71,0x00};void Nixie(unsigned char Location,Number); //首先控制P2口选中LED1~8中之一，再给P0口断码数据，选择显示的数字void main(){\t\tNixie(2,3);\twhile(1)\t{\t\t\t}}void Nixie(unsigned char Location,Number){\tswitch(Location)\t{\t\tcase 1:P2_4=1;P2_3=1;P2_2=1;break;\t\tcase 2:P2_4=1;P2_3=1;P2_2=0;break;\t\tcase 3:P2_4=1;P2_3=0;P2_2=1;break;\t\tcase 4:P2_4=1;P2_3=0;P2_2=0;break;\t\tcase 5:P2_4=0;P2_3=1;P2_2=1;break;\t\tcase 6:P2_4=0;P2_3=1;P2_2=0;break;\t\tcase 7:P2_4=0;P2_3=0;P2_2=1;break;\t\tcase 8:P2_4=0;P2_3=0;P2_2=0;break;\t\t\t}\tP0=NixieTable[Number];}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2. 动态数码管显示利用辉光现象造成的人眼视觉残留，不断扫描数码管，来动态显示多位数字。\n可看成静态数码管的快随迭代显示。\n控制原理\n\nLED1–8的一端直接连在138译码器的输出端\n\n\n\n\n\n\n(1) 138译码器：实际上就是用3个输入口控制8个输出口,以达到减少I/O口的目的，进而提高工作效率\n\n\nP2_3口，P2_4 口，P2_5口，是”二进制“\n\n\n\n\n\n\n\n\n(2) 74HC245：74HC245（双向数据缓冲器）其实是芯片，筛选弱信号通过芯片，过滤掉强信号\n因为低电平的驱动能力强（LED在低电平驱动时远亮与被高电平驱动时）\n\n\n\n\n排阻：\n\n\n\n\n\n\n\n\n\n动态显示原理控制数码管单独静态显示：\n\n\n动态数码管显示就是轮流“静态”显示，利用人的视觉残留从而实现动态效果\n\n\n\n\n\n\n消影即使能够利用视觉残留达成动态显示的效果，实际上依旧存在”窜位“问题\n视觉上”1、2、3“，依旧在闪烁\n这时就需要消影\n\n\n\n\n\n\n\n\n\n\n\n\n综述\n\n\n\n\n\n\n\n\n\n单片机直接扫描数码管：\n#include &lt;REGX52.H&gt;// 段码表unsigned char NixieTable[]={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71,0x00};// 动态数码管显示函数void Nixie(unsigned char Location,Number); // 延时函数void Delay(unsigned int xms);void main(){\t\t\twhile(1)\t{\t\tNixie(1,1);\t\t//Delay(0.002);\t\tNixie(2,2);\t\t//Delay(0.002);\t\tNixie(3,3);\t\t//Delay(0.002);\t}}void Nixie(unsigned char Location,Number){\tswitch(Location)\t{\t\tcase 1:P2_4=1;P2_3=1;P2_2=1;break;\t\tcase 2:P2_4=1;P2_3=1;P2_2=0;break;\t\tcase 3:P2_4=1;P2_3=0;P2_2=1;break;\t\tcase 4:P2_4=1;P2_3=0;P2_2=0;break;\t\tcase 5:P2_4=0;P2_3=1;P2_2=1;break;\t\tcase 6:P2_4=0;P2_3=1;P2_2=0;break;\t\tcase 7:P2_4=0;P2_3=0;P2_2=1;break;\t\tcase 8:P2_4=0;P2_3=0;P2_2=0;break;\t\t\t}\tP0=NixieTable[Number];\tDelay(1);\tP0=0x00;  //消影，即在段选和位选之间加入清零操作   排除窜位影响，即使窜位也没关系}void Delay(unsigned int xms)\t\t//@12.000MHz{\tunsigned char i, j;\twhile(xms--)\t{\t\ti = 2;\t\tj = 239;  \t\tdo\t\t{\t\t\twhile (--j);\t\t} while (--i);\t}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n四、模块化编程及LCD1602调试工具1.模块化编程(1) 介绍模块化的编程可以提升效率，避免主函数显得冗长，使代码容易阅读。\n\n\n\n\n\n\n\n\n(2) 框图表示模块化编程即使就是一个预编译的过程，例如在C语言中经常使用的 \n You can't use 'macro parameter character #' in math mode #include&lt;stido.h&gt; 头文件\n实际上，就是把函数的定义与声明分开来，使接口和实现分离开来\n\n\n\n\n\n\n\n\n(3) 预编译\n\n一般来说，预编译的实现如下：\n有两个文件\n一个是以结尾的头文件（用于声明函数）\n还有一个是以结尾的C语言文件（用于定义函数）\n.h\n// 头文件声明Delay函数#ifndef __DELAY_H__    // if not define #define __DELAY_H__   // define             #ifndef和#define的意义：防止重复包含，使函数只被定义一次，提高效率void Delay(unsigned int xms);#endif\n\n.c\n// C定义Delay函数void Delay(unsigned int xms)\t\t//@12.000MHz{\tunsigned char i, j;\twhile(xms--)\t{\t\ti = 2;\t\tj = 239;  \t\tdo\t\t{\t\t\twhile (--j);\t\t} while (--i);\t}}\n\n\n\n\n\n\n\n(4) 注意事项\n\n例如：\n调用的函数一定要声明，否则会报错\n#ifndef __NIXIE_H__#define __NIXIE_H__void Nixie(unsigned char Location,Number);#endif\n\n#include &lt;REGX52.H&gt;#include \"Delay.h\" // 在数码管Nixie函数的定义中使用了Delay函数，那么在定义时必须引用\"Delay.h\"unsigned char NixieTable[]={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x77,0x7C,0x39,0x5E,0x79,0x71,0x00};void Nixie(unsigned char Location,Number){\tswitch(Location)\t{\t\tcase 1:P2_4=1;P2_3=1;P2_2=1;break;\t\tcase 2:P2_4=1;P2_3=1;P2_2=0;break;\t\tcase 3:P2_4=1;P2_3=0;P2_2=1;break;\t\tcase 4:P2_4=1;P2_3=0;P2_2=0;break;\t\tcase 5:P2_4=0;P2_3=1;P2_2=1;break;\t\tcase 6:P2_4=0;P2_3=1;P2_2=0;break;\t\tcase 7:P2_4=0;P2_3=0;P2_2=1;break;\t\tcase 8:P2_4=0;P2_3=0;P2_2=0;break;\t\t\t}\tP0=NixieTable[Number];\tDelay(1);  \tP0=0x00;  //消影，即在段选和位选之间加入清零操作   排除窜位影响，即使窜位也没关系}\n\n\n\n\n\n\n\n\n\n\n\n2. LCD1602调试工具\n\n在插入LCD显示屏后由于引脚的冲突，数码管将不再亮\n\n\n#include &lt;REGX52.H&gt;#include \"LCD1602.h\"void main(){\tLCD_Init(); //初始化\tLCD_ShowChar(1,1,'A');     //在几行几列显示单个字符\tLCD_ShowString(1,3,\"Hello\");  //显示字符串\tLCD_ShowString(1,9,\"ZZH\");\t\tLCD_ShowNum(2,1,123,3);  //显示3位    若显示4位，则为0123，2位为23\tLCD_ShowSignedNum(2,5,-66,2);  //符号位不算在内\twhile(1)\t{\t\t}}\n\n每秒加1\n#include &lt;REGX52.H&gt;#include \"LCD1602.h\"#include \"Delay.h\"int a=0;void main(){\tLCD_Init(); //初始化\twhile(1)\t{\t\ta++;\t\tDelay(1000);\t\tLCD_ShowNum(1,1,a,3);  //每秒+1\t}\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n五、 矩阵键盘1. MatrixKey简介\n\n\n\n\n\n(1) 矩阵按键\n\n这种矩阵按键能很好的节省I/O口，提升工作效率。\n工作方式\n\n若有多行/列会无法判断\nI/O口原理C51的I/O口是“弱上拉，强下拉”模式\n\n\n\n\n手绘简图介绍：\n\n\n\n\n\n\n\n\n\n\n\n\n(2) 扫描\n\n数码管快速扫描，但是会占用CPU的时间\n\n\n\n显示器/手机屏幕：（利用矩阵的方式）对横竖交错的像素点进行扫描\n\n\n\n(3) MatrixKey代码实现#include &lt;REGX52.H&gt;#include \"Delay.h\"unsigned char MatrixKey(){\tunsigned char KeNumber=0;\t\t// 第一列置“0”\tP1=0xFF;\tP1_3=0;\t//s1的检测    if(P1_7==0)  //判断s1是否按下\t{\t\tDelay(20);\t\twhile(P1_7==0)  //消抖，判断s1是否抬起   为“1”时才跳出死循环\t\t{\t\t}\t\tDelay(20);\t\tKeyNumber=1;\t}\treturn KeyNumber;}\n\n\n\n\n\n#include &lt;REGX52.H&gt;#include \"Delay.h\"#include \"LCD1602.h\"#include \"MatrixKey.h\"/**  * @brief 矩阵键盘读取按键键码  * @param 无  * @retval KeyNumber 按下按键的键码值\t         如果按键按下不放，程序会停留在此函数，松手的一瞬间，返回按键键码，没有按键按下时，返回0  */unsigned char KeyNumber;void main(){\tLCD_Init();\tLCD_ShowString(1,1,\"Hello ZZH\");\twhile(1)\t{\t\tKeyNumber=MatrixKey();\t\tif(KeyNumber)\t\t{\t\t\tLCD_ShowNum(2,1,KeyNumber,2);\t\t}\t}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2. 矩阵键盘密码锁void main(){\tLCD_Init();\tLCD_ShowString(1,1,\"Password:\");\twhile(1)\t{\t\tKeyNumber=MatrixKey();\t\tif(KeyNumber)\t\t{\t\t\tif(KeyNumber&lt;=10)  //如果按键S1~S10按键按下，输入密码\t\t\t{\t\t\t\tPassword*=10;            //密码左移一位\t\t\t\tPassword+=KeyNumber%10;  //对10取余，目的是使10被定义为0  获取一位密码\t\t\t}\t\t\tLCD_ShowNum(2,1,Password,4);\t\t}\t}}// 第一位 0001 乘10      0010  实现左移\n\n\n\n\n\n简易的密码锁代码L:\n#include &lt;REGX52.H&gt;#include \"Delay.h\"#include \"LCD1602.h\"#include \"MatrixKey.h\"unsigned char KeyNumber;unsigned int Password,Count;void main(){\tLCD_Init();\tLCD_ShowString(1,1,\"Password:\");\twhile(1)\t{\t\tKeyNumber=MatrixKey();\t\tif(KeyNumber)\t\t{\t\t\tif(KeyNumber&lt;=10&amp;&amp;Count&lt;4)  //如果按键S1~S10按键按下，输入密码 控制密码为4位\t\t\t{\t\t\t\tPassword*=10;            //密码左移一位\t\t\t\tPassword+=KeyNumber%10;  //对10取余，目的是使10被定义为0  获取一位密码\t\t\t\tCount++;  //计次加一\t\t\t}\t\t\tLCD_ShowNum(2,1,Password,4);   //更新显示\t\t\t\t\t  if(KeyNumber==11)  //如果s11按下，确认密码\t\t  {\t\t\t\tif(Password==521)\t\t\t\t{\t\t\t\t\tLCD_ShowString(1,14,\"OK \");\t\t\t\t\t//密码和计次清0\t\t\t\t\t\t\t\t\t}\t\t\t\telse{LCD_ShowString(1,14,\"ERR\");}\t\t\t\tPassword=0;\t\t\t\tCount=0;\t\t\t\tLCD_ShowNum(2,1,Password,4);   //更新显示\t\t  }\t\t\t\t\t\t//按下取消\t\t\tif(KeyNumber==12)\t\t\t{\t\t\t\tPassword=0;\t\t\t\tCount=0;\t\t\t\tLCD_ShowNum(2,1,Password,4);   //更新显示\t\t\t}\t\t}\t\t\t}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n六、 定时器1. 定时器(1)简介\n\n\n\n\n\n\n\n\n\n(2)工作原理及模块\n\n\n\n\n\n工作模式\n\n\n\n\n\n\n\n\n\n工作模块时钟\n\n\n\n\n\n\n计数系统和中断系统\n\n\n\n\n整体\n\n\n\n\n\n\n\n\n\n\n定时器时钟\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n定时器0的代码：\n\n\n\n\n\n\nvoid Timer0Init(void)\t\t//1毫秒@12.000MHz{\tAUXR &amp;= 0xF0;\t\t//定时器时钟1T模式\tTMOD |= 0x01;\t\t//设置定时器模式\tTL0 = 0x18;\t\t//设置定时初值\tTH0 = 0xFC;\t\t//设置定时初值\tTF0 = 0;\t\t//清除TF0标志\tTR0 = 1;\t\t//定时器0开始计时\tET0=1;\tEA=1;\tPT0=0;}\n\n\n\n\n\n\n\n\n\n\n\n中断系统流程图如下：\n\n\n单片机中的中断资源\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n注意：\n1.中断函数一般都比较“短”，执行的都是一些简单的自增或是赋值操作，因为时间较长的话会影响main函数，即不分主次\n2.中断函数不能有形参和返回值\n//中断子程序，加上“interrupt+中断号” 普通子函数就变成了终端服务子函数void Timer0_Routine() interrupt 1{}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2. 按键控制LED流水灯模式&amp;定时器时钟按键控制LED流水灯模式#include &lt;REGX52.H&gt;#include \"Timer0.h\"#include \"Key.h\"#include &lt;INTRINS.H&gt;unsigned char KeyNum,LEDMode;void main(){\tP2=0xFE;  //给初值，最低位给0，点亮最低位LED\tTimer0Init();\twhile(1)\t{\t\tKeyNum=Key();\t\t//获取独立按键键码\t\tif(KeyNum)\t\t\t//如果按键按下\t\t{\t\t\tif(KeyNum==1)\t//如果K1按键按下\t\t\t{\t\t\t\tLEDMode++;\t//模式切换，进行0，1循环\t\t\t\tif(LEDMode&gt;=2)LEDMode=0;\t\t\t}\t\t}\t}}void Timer0_Routine() interrupt 1{\tstatic unsigned int T0Count;\tTL0 = 0x18;\t\t//设置定时初值，清空计时器\tTH0 = 0xFC;\t\t//设置定时初值\tT0Count++;\t\t//T0Count计次，对中断频率进行分频\tif(T0Count&gt;=500)//分频500次，500ms\t{\t\tT0Count=0;\t\tif(LEDMode==0)\t\t\t//模式判断\t\t\tP2=_crol_(P2,1);\t//LED输出   crol--循环左移   cror--循环右移         \t\tif(LEDMode==1)\t\t\tP2=_cror_(P2,1);\t}}\n\n注意\n_crol_( , )  这两个函数均为循环移位函数，可循环（左/右）移动二进制位 0x01 》0x02》0x04   若移到最高位则循环\n\n\n\n\n\n\n\n\n\n\n\n\n\n定时器时钟代码实现#include &lt;REGX52.H&gt;#include \"Delay.h\" #include \"LCD1602.h\"#include \"Timer0.h\"unsigned char Sec=58,Min=56,Hour=22;void main(){\tLCD_Init();\tTimer0Init();\tLCD_ShowString(1,1,\"Clock:\");\tLCD_ShowString(2,1,\"  :  :\");\t\twhile(1)\t{\t\tLCD_ShowNum(2,7,Sec,2);\t\tLCD_ShowNum(2,4,Min,2);\t\tLCD_ShowNum(2,1,Hour,2);\t}}\t//定时器中断函数模板void Timer0_Routine() interrupt 1{\tstatic unsigned int T0Count;\tTL0 = 0x18;\t\t//设置定时初值\tTH0 = 0xFC;\t\t//设置定时初值\tT0Count++;\tif(T0Count&gt;=1000)\t{\t\tT0Count=0;\t\tSec++;\t\tif(Sec&gt;=60)\t\t{\t\t\tSec=0;\t\t\tMin++;\t\t}\t\tif(Min&gt;=60)\t\t{\t\t\tMin=0;\t\t\tHour++;\t\t}\t\tif(Hour&gt;=24)\t\t{\t\t\tHour=0;\t\t}\t}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n七、串口1.串口通信2.串口向电脑发送数据&amp;电脑通过串口控制LED串口每隔一秒向电脑发送数据\n\n\n串口初始化函数模块\n\n\n\n#include &lt;REGX52.H&gt;/**  * @brief 串口初始化  * @param 无  * @retval 无  */void UART_Init()   //4800bps@11.0592MHz{\tSCON=0x40;     //使能波特率倍速位SMOD\tPCON|=0x80;    //8位数据，可变波特率\tTMOD &amp;= 0x0F;\t\t//设置定时器模式，清除定时器1模式位\tTMOD |= 0x20;\t\t//设置定时器模式，设置定时器1为8位自动重装方式\tTL1 = 0xF4;\t\t  //设置定时初值\tTH1 = 0xF4;\t\t  //设置定时初值\tET1= 0;\t\t    //禁止定时器1中断\tTR1=1;        //启动定时器1 }/**  * @brief 串口发送一个字节数据  * @param Byte 要发送的一个字节数据  * @retval 无  */void UART_SendByte(unsigned char Byte){\tSBUF=Byte;  //只需要将数据写入SBUF，她就会自动发送\t//检测是否完成\twhile(TI==0);\tTI=0;}\n\n\n\n\n\n主函数：\n#include &lt;REGX52.H&gt;#include \"Delay.h\"#include \"UART.h\"unsigned char Sec;void main(){\tUART_Init();  //循环之前进行初始化\t\twhile(1)\t{\t\tUART_SendByte(Sec);\t\tSec++;\t\tDelay(1000);\t}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n电脑通过串口控制LED#include &lt;REGX52.H&gt;#include \"Delay.h\"#include \"UART.h\"void main(){\tUART_Init();  //循环之前进行初始化\t\twhile(1)\t{\t}}void UART_Routine() interrupt 4{\t//判断是否是“读SBUF”，即接受中断   因为发送也会触发中断，为了区分开发送与接受\tif(RI==1)\t{\t\tP2=~SBUF;\t\tUART_SendByte(SBUF);\t\tRI=0; //软件检测1后清零\t}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n八、LED点阵屏点阵屏显示笑脸：\n#include &lt;REGX52.H&gt;#include \"Delay.h\"sbit RCK=P3^5;  //RCLKsbit SCK=P3^6;  //SRCLKsbit SER=P3^4;  //SER#define MATRIX_LED_PORT  P0     //定义P0口，因为它是一个寄存器（不能进行sbit声明）便于后续统一操作(只需修改串口，如P0)/**  * @brief  74HC595写入一个字节  * @param  要写入的一个字节  * @retval 无  *///将参数写入8个引脚，给其赋值void _74HC595_WriteByte(unsigned char Byte){\tunsigned char i;\tfor(i=0;i&lt;8;i++)\t{\t\tSER=Byte&amp;(0x80&gt;&gt;i);  //最高位为1时赋值为0x80......\t\tSCK=1;    //给高电平上推，上升沿移位\t\tSCK=0;  //清零\t}\tRCK=1;  //8位数据移位\tRCK=0;}/**  * @brief   LED点阵屏显示一列  * @param   Column 要选择的列，范围：0~7，0在最左边* @retval  Data 选择的列所显示的数据，高位在上，1为亮，0为灭  */void MatrixLED_ShowColumn(unsigned char Column,Date){\t_74HC595_WriteByte(Date);\tMATRIX_LED_PORT=~(0x80&gt;&gt;Column); //取反，保持0亮，1灭\tDelay(1);\tMATRIX_LED_PORT=0xFF; //位选清零，防止串位}int main(){\tSCK=0;\tRCK=0;\twhile(1)\t{\t\tMatrixLED_ShowColumn(0,0x3C);\t\tMatrixLED_ShowColumn(1,0x42);\t\tMatrixLED_ShowColumn(2,0xA9);\t\tMatrixLED_ShowColumn(3,0x85);\t\tMatrixLED_ShowColumn(4,0x85);\t\tMatrixLED_ShowColumn(5,0xA9);\t\tMatrixLED_ShowColumn(6,0x42);\t\tMatrixLED_ShowColumn(7,0x3C);\t\t}\t\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n使用文字取模软件来读取点阵数据\n横向取模，高位在上（不用选取字节倒序）\n\n\nC51自动生成\n\n\n\n\n\n\n\n\n\n\n动态动画显示：\n#include &lt;REGX52.H&gt;#include \"Delay.h\"#include \"MatrixLED.h\"// unsigned char code Animation   这里加上code后会把数组存储在Flash中，内存更大，但是，不可写入，只能读取（原来存储在RAM中，有溢出的风险）unsigned char Animation[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x18,0x18,0x18,0xFF,0x00,0x0E,0x15,0x15,0x15,0x09,0x00,0x7E,0x01,0x02,0x00,0x7E,0x01,0x02,0x00,0x0E,0x11,0x11,0x0E,0x00,0x7D,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,};  //存放动画的数据，逐帧偏移即可实现动态效果int main(){\tunsigned char i,Offset,Count=0;\tMatrixLED_Init();\twhile(1)\t{\t\t//显示静态图像\t\tfor(i=0;i&lt;8;i++)\t\t{\t\t\tMatrixLED_ShowColumn(i,Animation[i+Offset]);\t\t}\t\tCount++;        //延时\t\tif(Count&gt;10)\t\t{\t\t\tCount=0;\t\t\tOffset++; //逐帧移动\t\t\tif(Offset&gt;40)\t\t\t{\t\t\t\tOffset=0;\t\t\t}\t\t}\t\t}\t\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n九、DS1302实时时钟111\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["MCU"],"tags":["MCU"]},{"title":"Coppersmith-Study","url":"/2023/08/07/Coppersmith-Study/","content":"Coppersmith一、IntroductionCoppersmith定理在RSA中多有应用，最多的就是，\n高位攻击一类的\nCoppersmith 可以用于求多项式的小根，经常用于 RSA 攻击中“已知某些二进制位，求剩余位”这一类问题。\n二、DeductionCoppersmith干了这么一件事：现有一个阶的多项式，那么可以：\n\n在模意义下,快速求出以内的根\n给定，快速求出模某个意义下较小的根，其中，是的因数。\n\n一般采用Sage实现的small_root方法\n三、Problem1.  hash爆破proof: skr=os.urandom(8)hashlib.sha256(skr).hexdigest()=246bfcbe8c7b0be0a3ee28840a276272ba4416cb650affd846e9f7f2db2820a9skr[0:5].encode('hex')=c2183d3580skr.encode('hex')=\n\n　给出了 skr 的前 5 位，需要找到正确的 skr 使得其 sha256 为给定值。显然直接爆破后三位就行。\ndef phase1(pre, target):    pre = codecs.decode(pre.encode(), 'hex')    for x in itertools.product(range(256), repeat=3):        skr = pre + b''.join([t.to_bytes(1, 'big') for t in x])        if hashlib.sha256(skr).hexdigest() == target:            print(f'find {skr}')            return codecs.encode(skr, 'hex').decode()phase1('c2183d3580', '246bfcbe8c7b0be0a3ee28840a276272ba4416cb650affd846e9f7f2db2820a9')# find b'\\xc2\\x18=5\\x80\\x14Q9'# 'c2183d3580145139'\n\n\n\n\n\n2. 已知明文高位，求低位n=13112061820685643239663831166928327119579425830632458568801544406506769461279590962772340249183569437559394200635526183698604582385769381159563710823689417274479549627596095398621182995891454516953722025068926293512505383125227579169778946631369961753587856344582257683672313230378603324005337788913902434023431887061454368566100747618582590270385918204656156089053519709536001906964008635708510672550219546894006091483520355436091053866312718431318498783637712773878423777467316605865516248176248780637132615807886272029843770186833425792049108187487338237850806203728217374848799250419859646871057096297020670904211e=3m=random.getrandbits(512)c=pow(m,e,n)=15987554724003100295326076036413163634398600947695096857803937998969441763014731720375196104010794555868069024393647966040593258267888463732184495020709457560043050577198988363754703741636088089472488971050324654162166657678376557110492703712286306868843728466224887550827162442026262163340935333721705267432790268517((m&gt;&gt;72&lt;&lt;72)=2519188594271759205757864486097605540135407501571078627238849443561219057751843170540261842677239681908736long_to_bytes(m).encode('hex')=\n\n这里给出了的高位440位，我们只需要推断出剩余发低位–72位即可。记真实的为，则\n这个方程的根很小，可以直接求解。\ndef phase2(high_m, n, c):    R.&lt;x&gt; = PolynomialRing(Zmod(n), implementation='NTL')    m = high_m + x    M = m((m^3 - c).small_roots()[0])    print(hex(int(M))[2:])n = 13112061820685643239663831166928327119579425830632458568801544406506769461279590962772340249183569437559394200635526183698604582385769381159563710823689417274479549627596095398621182995891454516953722025068926293512505383125227579169778946631369961753587856344582257683672313230378603324005337788913902434023431887061454368566100747618582590270385918204656156089053519709536001906964008635708510672550219546894006091483520355436091053866312718431318498783637712773878423777467316605865516248176248780637132615807886272029843770186833425792049108187487338237850806203728217374848799250419859646871057096297020670904211c = 15987554724003100295326076036413163634398600947695096857803937998969441763014731720375196104010794555868069024393647966040593258267888463732184495020709457560043050577198988363754703741636088089472488971050324654162166657678376557110492703712286306868843728466224887550827162442026262163340935333721705267432790268517high_m = 2519188594271759205757864486097605540135407501571078627238849443561219057751843170540261842677239681908736phase2(high_m, n, c)# 464c41477b325e3872736137353839363933666336383963373763356635323632643635343237323432377d\n\n\n\n3. 广播攻击CRT的应用场景\n模数n、密文c不同，明文m、加密指数e相同。一般会是e=k，然后给k组数据使用不同的模数n，相同的公钥指数e加密相同的信息。就会得到多个(m^e) ==ci (mod ni)，将(m^e)视为一个整体M，这就是典型的中国剩余定理适用情况。按照中国剩余定理容易求得m^e的值，当e较小时直接开e方即可，可使用gmpy2.iroot(M,e)方法。\ne=3m=random.getrandbits(512)n1=78642188663937191491235684351005990853149481644703243255021321296087539054265733392095095639539412823093600710316645130404423641473150336492175402885270861906530337207734106926328737198871118125840680572148601743121884788919989184318198417654263598170932154428514561079675550090698019678767738203477097731989c1=pow(m,e,n1)=23419685303892339080979695469481275906709035609088426118328601771163101123641599051556995351678670765521269546319724616458499631461037359417701720430452076029312714313804716888119910334476982840024696320503747736428099717113471541651211596481005191146454458591558743268791485623924245960696651150688621664860n2=98174485544103863705821086588292917749386955237408645745685476234349659452606822650329076955303471252833860010724515777826660887118742978051231030080666542833950748806944312437614585352818344599399156268450521239843157288915059003487783576003027303399985723834248634230998110618288843582573006048070816520647c2=pow(m,e,n2)=72080679612442543693944655041130370753964497034378634203383617624269927191363529233872659451561571441107920350406295389613006330637565645758727103723546610079332161151567096389071050158035757745766399510575237344950873632114050632573903701015749830874081198250578516967517980592506626547273178363503100507676n3=91638855323231795590642755267985988356764327384001022396221901964430032527111968159623063760057482761918901490239790230176524505469897183382928646349163030620342744192731246392941227433195249399795012672172947919435254998997253131826888070173526892674308708289629739522194864912899817994807268945141349669311c3=pow(m,e,n3)=22149989692509889061584875630258740744292355239822482581889060656197919681655781672277545701325284646570773490123892626601106871432216449814891757715588851851459306683123591338089745675044763551335899599807235257516935037356212345033087798267959242561085752109746935300735969972249665700075907145744305255616long_to_bytes(m).encode('hex')=\n\n相同的消息用三个不同的公钥加密，且 =3，直接通过中国剩余定理得到  的确切值，开根号即可。\ndef phase5(n1, c1, n2, c2, n3, c3):    r = CRT([c1, c2, c3], [n1, n2, n3])    m = int(r)^(1/3)    print(hex(m)[2:])    n1 = 78642188663937191491235684351005990853149481644703243255021321296087539054265733392095095639539412823093600710316645130404423641473150336492175402885270861906530337207734106926328737198871118125840680572148601743121884788919989184318198417654263598170932154428514561079675550090698019678767738203477097731989c1 = 23419685303892339080979695469481275906709035609088426118328601771163101123641599051556995351678670765521269546319724616458499631461037359417701720430452076029312714313804716888119910334476982840024696320503747736428099717113471541651211596481005191146454458591558743268791485623924245960696651150688621664860n2 = 98174485544103863705821086588292917749386955237408645745685476234349659452606822650329076955303471252833860010724515777826660887118742978051231030080666542833950748806944312437614585352818344599399156268450521239843157288915059003487783576003027303399985723834248634230998110618288843582573006048070816520647c2 = 72080679612442543693944655041130370753964497034378634203383617624269927191363529233872659451561571441107920350406295389613006330637565645758727103723546610079332161151567096389071050158035757745766399510575237344950873632114050632573903701015749830874081198250578516967517980592506626547273178363503100507676n3 = 91638855323231795590642755267985988356764327384001022396221901964430032527111968159623063760057482761918901490239790230176524505469897183382928646349163030620342744192731246392941227433195249399795012672172947919435254998997253131826888070173526892674308708289629739522194864912899817994807268945141349669311c3 = 22149989692509889061584875630258740744292355239822482581889060656197919681655781672277545701325284646570773490123892626601106871432216449814891757715588851851459306683123591338089745675044763551335899599807235257516935037356212345033087798267959242561085752109746935300735969972249665700075907145744305255616phase5(n1,c1,n2,c2,n3,c3)# 464c41477b325e3872736138633566336366663462633039353334396665633635666332323633653837387d\n","categories":["Crypto"],"tags":["Crypto"]},{"title":"MCU-Study-Stm32","url":"/2023/10/06/MCU-Study-Stm32/","content":"Part1. 初识Stm32一、Preparation1.编写软件的准备\n\n  Keil5的arm版本，这个放在之前安装过的C51版本的根目录下即可。\n  拿取CID激活LIC的步骤就不过多赘述了。\n  之后还是需要安装STLink的USBdriver，识别成功即安装成功。\n\n\n\n\n\n\n\n\n\n\n\n\n二、About Stm321.Introduction\n\nSTM32相较于C51单片机，功能更加全面\n\n\n\n\n\n\n\n\n\n\n2. STM32f103c8tc(1)基本参数\n\n\n\n(2)外设\n\n\n\n\n\n(3)命名规则\n\n\n\n\n\n(4)系统结构\n\n\n\n\n\n\n\n(5)引脚定义\n\n\n\n\n\n\n\n(6)启动配置和最小系统电路\n\n  一般来说，在需要串口下载程序的时候才会设置为“系统存储器”启动模式。\n  BOOT引脚的值是在上电复位后的一瞬间有效的。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPart2. 编写STM32编写STM32主要有以下几种方式：\n\n基于寄存器的方式（由于STM32机构复杂，寄存器多而繁杂，不推荐）\n基于封装函数（库函数）的方式（调用方便，一般来说使用这种方法间接配置寄存器）\nHAL库基于图形化界面快速配置STM32（快速方便，但需理解底层逻辑）\n\n一、GPIOC口1.硬件与软件的调试准备首先需按图所示连接号STLINK与STM32\n\n\n\n\n\n\n在Keil5中，将调试器改为使用的ST-Link\n\n\n然后在Flash中勾选上，使程序在下载后立马复位执行\n\n\n\n\n\n\n\n\n2.直接配置寄存器看出这样操作麻烦，工作量大，远没有封装的库函数来的简洁与方便。\n#include \"stm32f10x.h\"                  // Device headerint main(void){\tRCC-&gt;APB2ENR = 0x00000010; //´ò¿ªGPIOC¼Ä´æÆ÷\tGPIOC-&gt;CRH = 0x00300000;\tGPIOC-&gt;ODR = 0x00002000;\twhile(1)\t{\t\t}}\n\n\n\n\n\n\n\n\n\n3.通过调用库函数来调试GPIOC口注意：\n  这里有一个条件编译，即若要使”stm32f10x_conf.h”生效，必须定义 USE_STDPERIPH_DRIVER\n\n\n在Define中输入，并添加好路径\n\n\n配置完之后编译检验是否配置成功。\n\n\n\n\n\n\n\n\n(1)新建工程\n\n\n\n\n\n\n\n(2)工程架构\n\n\n**startup: **\n  即启动文件，在Keil5中这是用汇编写的，内含中断向量表和中断服务函数等。中断服务函数里的复位函数是所有程序的入口，当STM32上电复位或者按下复位按键后就进入复位中断函数执行。它将调用SystemInit函数和main函数，然后结束。\n（实际上单片机不会停止工作，因为main函数一般以while(1)死循环结尾）\n\n\n\n\n\n代码块如下\n\n\n\n#include \"stm32f10x.h\"                  // Device headerint main(void){\tunsigned int i=0;\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE);\tGPIO_InitTypeDef GPIO_InitStructure; //结构体变量\tGPIO_InitStructure.GPIO_Mode =  GPIO_Mode_Out_PP;\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\t\tGPIO_Init(GPIOC,&amp;GPIO_InitStructure); //取地址返回\tGPIO_SetBits(GPIOC,GPIO_Pin_13); //将13号口置为高电平\tGPIO_ResetBits(GPIOC,GPIO_Pin_13); //设置为低电平\twhile(1)\t{\t\tGPIO_SetBits(GPIOC,GPIO_Pin_13);\t\tGPIO_ResetBits(GPIOC,GPIO_Pin_13);\t}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n二、GPIO输出1.GPIO相关知识(1)GPIO简介\n\n只有部分引脚可以忍受5V的电压，即FT(Five Tolerate)\n(2)GPIO基本结构\n\nAPB2：外接总线，在stm32中所有的GPIO都挂载在APB2上\nGPIO类别：GPIO(A–B–C)等等，每个GPIO口都有16个引脚\n32位寄存器： \n  仅低16位起作用，因为只有16个端口\n\n输出寄存器写1，则输出引脚输出高电平；0—-低电平\n输入寄存器读取1，则输入引脚为高电平；0—-低电平\n\n驱动器：\n增加信号驱动能力\n(3)GPIO位结构\n\n\n\n\n\n\n\n\n\n\n\n\n\n(4)GPIO模式\n\n  由于浮空输入的电平是不确定的，所以在使用浮空输入时，端口一定要接上一个连续的驱动源，不能出现悬空的状态。\na. 浮空/上拉/下拉输入\n\n  VDD：上拉    \n  VSS：下拉\n输入通过施密特触发器进行波形整形后，连接到输入数据寄存器\nb.  模拟输入（ADC专属）\n\n  注意到，此时仅有I/O引脚和进入片上外设的一条线在起作用\n  仅在模拟输入模式会关闭数字的输入功能\nc. 开漏/推挽输出\n\n\n\n\n\nd. 复用开漏/推挽输出\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n三、OLED调试工具和OLED显示屏1. OLED调试工具(1)OLED简介\n\n\n\n\n\n\n\n(2)调试方式\n\n\n串口调试： 把电脑的屏幕挂在单片机上。通过电脑端调试，功能强大，可以显示图像，曲线，图像，自己做的软件。不利于人机交互，不能不断刷新数据。\n显示屏调试：对于不断变化的数据可以不断刷新显示\n\n(3)硬件电路\n\n​\tSCL和SDA需要接在单片机的I2C通信引脚上\n(4)OLED驱动函数\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.OLED显示屏1.引脚配置/*引脚配置*/#define OLED_W_SCL(x)\t\tGPIO_WriteBit(GPIOB, GPIO_Pin_8, (BitAction)(x))#define OLED_W_SDA(x)\t\tGPIO_WriteBit(GPIOB, GPIO_Pin_9, (BitAction)(x))\n\nSCL和SDA配置为开漏输出模式\n/*引脚初始化*/void OLED_I2C_Init(void){    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);\t\tGPIO_InitTypeDef GPIO_InitStructure; \tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; \tGPIO_Init(GPIOB, &amp;GPIO_InitStructure);\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; \tGPIO_Init(GPIOB, &amp;GPIO_InitStructure);\t\tOLED_W_SCL(1);\tOLED_W_SDA(1);}\n\n\n\n\n\n\n\n\n\n2.调试模式\n\n点击红色放大镜进入调试模式\n四、TIM定时中断1.TIM简介\n\n  定时器是一个计数器，基本功能是定时触发中断\n(1)TIM类型\n\nAPB2总线性能更高    定时器向下兼容\na.基本定时器\n\n\n\n时基单元：\nTIMxCLK是72MHz\n\n\n\n\n预分频器：  0，即不分频   ； 1，即2分频，36MHz \nCNT计数器：16位计数器，值0–65535，溢出则归零。 自增运行至目标值，产生中断。\n自动重装寄存器：存储目标值的寄存器，即写入的计数目标。当计数达到目标值，产生中断信号并清零计数器，自动开始下一次的计数计时。\n\n\n\n更新中断： 计数值等于自动重装值产生的中断，产生更新中断后会通往NVIC，若配置好NVIC的定时器通道，那定时器的更新中断就能得到CPU的响应了。\n\n\n\nb.通用定时器\n\n  除了基本的向上计数模式（基本定时器的计数模式）外，通用定时器和高级定时器还支持向下计数模式和中央对齐模式。\n  向下计数模式： 从重装值开始向下自减，减到0，申请中断，循环。\n  中央对齐模式： 从0开始，向上自增到重装值，申请中断；向下自减到0，再申请中断。循环。\nc.高级定时器\n\n\n\n\n\n\n\n\n\n\n\n2.定时中断基本结构\n\n  上述为定时器搜友可选时钟源\n  若为高级定时器，则在自动重装器和中断输出控制之间还会多一个重复计数器\n中断输出控制：中断输出的“允许位”，允许后，对应中断才可输出\n1. 预分频器时序\n\n\n\n\n预分频缓冲寄存器（影子寄存器）才是真正起作用的寄存器，当计数到一半时，若改变了分频值，变化不会立刻生效，会等到本次计数周期结束，产生了更新事件（UEV），预分频寄存器的值才会被传递到缓冲寄存器里面去，才会生效。\n\n\n\nCNT_EN：计时器使能，高电平计数器正常工作，低电平计数器停止\nCK_CNT：计数器时钟，使预分频器的时钟输出也是CNT计时器的时钟输入\n\n\n\n\n\n\n\n\n\n\n\n\n2.计数器时序\n\nUIF只要置1了，就会去申请中断，中断响应后需要在中断程序中手动清零\nARR：自动重装定时器，它也有缓冲寄存器\na. 计数器无预装时序\n\n\n\nb.计数器有预装时序\n\n让值得变化和更新同步发生，防止在运行得途中更改发生错误\n3.RCC时钟树\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n五、TIM输出比较1.输出比较简介\n\nIC：Input Capture  输入捕获\nCC：Capture/Compare  输入捕获和输出比较的单元\nCNT计数器与CCR捕获比较寄存器\nCNT自增，CCR为给定值，通过比较二者的值不断置1 ，置0，来达到输出PWM波形的效果。\n\n\n2.PWM波形\n\n  PWM为数字输出信号，由高低电平组成。PWM的频率越快，它等效的模拟信号就约平稳。\n  快频率通电断电，就可以得到一个平均输出值。\n  分辨率：占空比变化的精细程度。\n3. 输出比较部分电路(1)输出比较通道\n\noc1ref：  reference（参考信号）\n\n\n极性选择：\n  0–&gt;信号不反转\n 1–&gt;非门取反，信号反转\n\n\nOC1右侧接推挽电路（2个，形成H桥），就可用于驱动电机（正反转）\n(2)八种模式输出比较\n\n\n冻结：输出暂停，高低电平维持冻结状态保持不变。\n\n有效电平/无效电平（1/0）\n\n匹配时输出翻转：更新两次，输出才为一个周期。\n\n\n4.PWM基本结构(1)总体结构\n\nPWM输出：\n\n\n蓝色：CNT              黄色：ARR              红色：CCR\n(2)参数计算\n\n\n\n\n\n\n\n5.STM32外设(1)舵机\n\n  PWM信号输入到控制板，给控制板一个指定的角度。然后，电位器检测输出轴的当前角度。若大于目标角度，直流电机反转；小于，正传。最终使输出轴固定在指定角度。\n\n\n\n\n\n\n\n\n(2)直流电机\n\nH桥： 由两路推挽电路组成\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["MCU"],"tags":["MCU"]},{"title":"Geek2023","url":"/2023/11/23/Fi1nd_th3_x---WP%EF%BC%9A/","content":"Fi1nd_th3_x—WP：  不难发现，dP、dQ、dR这三个模数两两之间并不互素。\n  而中国剩余定理(CRT)不能解决模数不互质情况的模线性同余方程组。很明显，这是一道exCRT的题目。关键在于求出满足条件的解系，即x’。\n#Task-expimport gmpy2from functools import reducefrom Crypto.Util.number import *p= 13014610351521460822156239705430709078128228907778181478242620569429327799535062679140131416771915929573454741755415612880788196172134695027201422226050343q= 12772373441651008681294250861077909144300908972709561019514945881228862913558543752401850710742410181542277593157992764354184262443612041344749961361188667r= 12128188838358065666687296689425460086282352520167544115899775800918383085863282204525519245937988837403739683061218279585168168892037039644924073220678419dP= 116715737414908163105708802733763596338775040866822719131764691930369001776551671725363881836568414327815420649861207859100479999650414099346914809923964116101517432576562641857767638396325944526867458624878906968552835814078216316470330511385701105459053294771612727181278955929391807414985165924450505855941dQ= 44209639124029393930247375993629669338749966042856653556428540234515804939791650065905841618344611216577807325504984178760405516121845853248373571704473449826683120387747977520655432396578361308033763778324817416507993263234206797363191089863381905902638111246229641698709383653501799974217118168526572365797dR= 60735172709413093730902464873458655487237612458970735840670987186877666190533417038325630420791294593669609785154204677845781980482700493870590706892523016041087206844082222225206703139282240453277802870868459288354322845410191061009582969848870045522383447751431300627611762289800656277924903605593069856921c= 93063188325241977486352111369210103514669725591157371105152980481620575818945846725056329712195176948376321676112726029400835578531311113991944495646259750817465291340479809938094295621728828133981781064352306623727112813796314947081857025012662546178066873083689559924412320123824601550896063037191589471066773464829226873338699012924080583389032903142107586722373131642720522453842444615499672193051587154108368643495983197891525747653618742702589711752256009#合并两个模不互素的同余方程def merge(x1, x2):    a1, m1 = x1    a2, m2 = x2    d = gmpy2.gcd(m1, m2) #寻找最大公约数d    assert (a2 - a1) % d == 0 #确保是有解的情况，即d|(a2-a1),即能够合并两方程    p1= m1 // d    p2= m2 // d    _,l1,l2 = gmpy2.gcdext(p1,p2)    k1 = -l1*((a1 - a2) // d)     lcm = gmpy2.lcm(m1,m2) #寻找最小公倍数lcm    x0 = pow(a1 + k1 * m1,1,lcm ) #满足情况的特解    return x0,lcm#构建同余方程def excrt(ai,mi):    tmp = zip(ai,mi)    return reduce(merge, tmp)mi = [(q - 1) * (r - 1),(p - 1) * (r - 1),(p - 1) * (q - 1)]ai = [dP,dQ,dR]d,lcm = excrt(ai,mi)n = p * q * rm = pow(c,d,n)print(long_to_bytes(m))\n\n","categories":["Crypto"],"tags":["Crypto"]},{"title":"MCU-Vehicle-Project","url":"/2023/11/23/Vehicle-Project/","content":"Vehicle ProjectAuthor: jrl777\n  基于STM32F103C8T6的两轮自平衡小车的学习过程记录，与诸君分享。内容参考平衡车开发指南。\n1.原理分析1.1 平衡原理  控制平衡小车的基本原理是控制中的负反馈机制。\n  由于小车只有两个轮子着地，车体只会在轮子滚动的方向上发生倾斜。控制轮子转动，抵消在一个维度上倾斜的趋势便可以保持车体平衡了。\n\n\n接下来需要解决的问题就转化成如何控制小车车轮的运动，以此控制小车的平衡了。需要建立两轮自平衡小车的运动学和动力学数学模型，设计反馈控制来保证车体的平衡。\n1.2 动力学分析  保持车体平衡的控制规律可以简化为理想化的单摆物理模型。\n\n\n  对单摆模型进行受力分析。\n  我们都知道，在单摆偏离平衡位置时会受到重力、和阻尼力的作用。而回复力是重力在切向上的分力（单摆在切向上作间简谐运动），属于作用力。\n  当物体离开平衡位置后，会受到重力和绳子的合力的作用，使物体回到平衡位置。这个合力就称为：回复力。其大小为\n​                                                                                \n  在偏移角度很小的情况下，回复力与偏移的角度之间大小成正比，方向相反。 在此回复力作用下，单摆便进行周期运动。在空气中运动的单摆，由于受到空气的阻尼力， 单摆最终会停止在垂直平衡位置。空气的阻尼力与单摆运动速度成正比，方向相反。阻尼力越大，单摆越会尽快在垂直位置稳定下来。\n  在不同阻尼系数下，单摆的运动曲线也不同。\n\n\n\n\n  我们都知道，对于单摆而言，稳定在垂直位置（平衡位置）的条件有两个：\n\n受到与位移（角度）相反的恢复力；\n受到与运动速度（角速度）相反的阻尼力。\n\n  如果没有阻尼力，单摆会在垂直位置左右摆动。阻尼力会使得单摆最终停止在垂直位置。阻尼力过小（欠阻尼）会使得单摆在平衡位置附件来回震荡。阻尼力过大（过阻尼）会使得单摆到达平衡位置时间加长，比如气球单摆。因而存在一个临界阻尼系数，使得单摆稳定在平衡位置的时间最短。\n\n\n  倒立摆之所以不能象单摆一样可以稳定在垂直位置，就是因为在它偏离平衡位置的时候，所受到的回复力与位移方向相同，而不是相反！因此，倒立摆便会加速偏离垂直位置，直到倒下。  所以我们需要给予倒立摆额外的力来使其稳定在批平衡位置。\n1.3 数学模型 下面对两轮自平衡小车进行简单数学建模，然后建立速度的比例微分负反馈控制，根据基本控制理论讨论小车通过闭环控制保持稳定的条件。\n\n\n\n\n  通过根轨迹示意图，可以很清晰的看出两轮自平衡小车的传递函数对应有两个零极点，有一个在 s 平面的右半平面。这说明两轮自平衡小车是不稳定的。\n  小车引入比例、微分（PD）反馈之后的系统如下图所示：\n\n\n\n\n\n\n\n\n\n\n1.4 Simulink仿真  通过对两轮自平衡小车系统进行动力学分析和数学建模，在理论上设计出了控制方法。下面，调用 Matlab 软件的 Simulink 仿真工具包对两轮自平衡小车的控制系统数学模型进行仿真验证，观察角度在干扰信号的作用下的自恢复情况。\n  在 Simulink 文件中，建立两轮自平衡小车的数学模型，调用 PID 控制器构成控制系统的主要部分。设定输入信号值为 0，代表角度初始值为 0，小车初始在平衡位置。对输出节点，调用两个 Step 模块，通过设定 Step Time，使之构成宽度为 1s 的脉冲信号作为小车的外力干扰作用信号。整体系统构成负反馈形式，如下图所示。\n\n\n\n\n\n\n\n\n\n\n1.5 小车的速度控制原理与串级PIDPID原理：PID控制算法原理（抛弃公式，从本质上真正理解PID控制） - 知乎 (zhihu.com) \n  通常在三轮小车、四轮小车中，我们使用 PID 进行速度控制，大部分都是负反馈。但是两轮自平衡小车的速度控制不大一样，不是负反馈，而是正反馈，因为小车的两个电机需要进行直立控制的同时去进行速度控制。\n  我们先使用常规的速度负反馈算法试一下，看在平衡小车上面是否有效果。首先我们给定一个目标速度值，由于在直立控制的作用下，此时小车要向前倾斜以获取加速度，车轮需要往后运动，这样小车的速度就会下降。因为是负反馈，速度下降之后，速度控制的偏差增大，小车往前倾斜的角度增大，如此反复，小车便会倒下。常规的速度负反馈在直立控制的影响下起到了正反馈效果。如下图所示。\n\n\n  根据以上的分析，在直立控制里面加入速度负反馈无法达到速度闭环的目的，而且还会破坏直立控制系统。下面我们换一种思路。\n  为保证直立控制的优先级，我们把速度控制放在直立控制的前面，也就是速度控制调节的结果仅仅是改变直立控制的目标值。因为根据经验可知，小车的运行速度和小车的倾角是相关的。比如要提高小车向前行驶的速度，就需要增加小车向前倾斜的角度，倾斜角度加大之后，车轮在直立控制的作用下需要向前运动保持小车平衡，速度增大；如果要降低小车向前行驶的速度，就需要减小小车向前的倾斜角度，倾斜角度减小之后，车轮在直立控制的作用下向后运动保持小车平衡，速度减小。如下图所示。\n\n\n  根据上面的原理图，我们把速度和直立两个控制器串联起来工作，其中速度控制的输出作为直立控制的输入，而直立控制的输出作为系统的输出，这其实就是一个串级控制系统。直立控制在前面有介绍，使用的 PD 控制。因为编码器可能存在的噪声，为防止噪声被放大并消除系统的静差，这里我们速度控制使用 PI 控制。\n  至此，我们得到了让小车保持直立且速度为给定值的控制算法，由一个负反馈的直立 PD 控制器和一个正反馈的速度 PI 控制器组成。控制原理图进行的演变，如下图所示。\n2. 电路开发2.1 系统框架一览\n\n  由上面系统框架图可以看到，整个系统围绕 STM32F103C8T6 主芯片运行，电池经过降压稳压后提供稳定的 5v 和 3.3v 给 STM32 主芯片和各电子模块，STM32 主芯片通过读取 MPU-6050 传感器芯片的数据，获取小车系统的运动状态，再通过 TB6612FNG 驱动芯片控制直流电机的运动，直流电机通过编码器反馈转速给 STM32 主芯片，这就构成了两轮自平衡小车的基本硬件框架。其他的辅助功能，比如蓝牙、OLED、超声波、红外等等都是可加可不加的功能，我们为了提高两轮自平衡小车的可玩性和操纵性，一并加进去。\n3.程序框架  打开自平衡小车的工程文件，展开的工程分组如下图所示：\n\n\n如图所示，该工程共有6个具体的分组。\n\nFWlib分组：主要是HAL库的文件代码\nCMSIS分组：主要是Cortex-M3 核心的文件代码\nStartup 分组：stm32f10x 的启动文件代码\nBSP 分组：外设硬件的驱动程序代码，例如MPU6050、oled 等等\nSYS 分组：主要是滴答定时器和调试相关的配置代码\nUSER 分组：用户代码，主程序\n\n讲解一下 USER 分组的 main.c。main.c 包含了所有硬件初始化和参数初始化代码。初始化代码如下：\nint main(void){            BspInit();       //初始化BSP    PIDInit();       //初始化PID        CarUpstandInit();//初始化系统参数    SysTick_Init();  //初始化定时器            if(IsInfrareOK())//检测是否悬挂红外模块        g_iGravity_Offset = 1; //如果检测到悬挂红外模块，则更改偏移值。    ShowHomePageInit();//初始化OLED显示屏主页    while (1)//进入主循环    {            SecTask();//秒级任务，主要是记录小车运行时间、读取电池电压等非实时任务        if(SoftTimer[1] == 0)//系统软件定时器1，分辨率为1ms，递减计数        {// 每隔20ms 执行一次            SoftTimer[1] = 20;            ResponseIMU();//上报姿态数据到APP                    DebugService();    //上位机调试数据发送                    Parse(Uart3Buffer);    //APP数据解析函数            }                    if(SoftTimer[2] == 0)//系统软件定时器2，分辨率为1ms，递减计数        {// 每隔20ms 执行一次            SoftTimer[2] = 20;            ShowHomePage();//刷新OLED页面            Read_Distane();//读取超声波测距距离            if(g_CarRunningMode == ULTRA_FOLLOW_MODE){                if(IsUltraOK())UltraControl(0);    //设置超声波跟随模式             }            if(g_CarRunningMode == ULTRA_AVOID_MODE){                if(IsUltraOK())UltraControl(1);    //设置超声波避障模式             }            else if(g_CarRunningMode == INFRARED_TRACE_MODE){                TailingControl();//设置红外循迹模式            }        }                }}\n\n  代码初始化主要是硬件底驱动和系统参数的初始化。\n3.1 BspInit()函数  BspInit 主要是硬件底层驱动的初始化，包括 STM32 外设的初始化、外围模块比如 MPU-6050 的初始化。具体见下面代码：\nvoid BspInit(void){    SWDConfig();            //SWD 调试接口配置，使能 SWD，失能 JTAG    ADCInit();                //ADC 初始化    USART1Init();            //串口 1 初始化-底板预留下载及调试用    USART3Init(0);            //串口 3 初始化-用于蓝牙    TIM1_Cap_Init();        //TIM1初始化-用于超声波跟随功能    TIM3_PWM_Init();         //PWM初始化    TIM2_Encoder_Init();    //TIM2 正交解码初始化-用于测速    TIM4_Encoder_Init();    //TIM4 正交解码初始化-用于测速        i2cInit();                 //I2C 初始化        InfraredIOInit();        //红外 IO 口初始化    OLED_Init();            //OLED 初始化    MPU6050_Init();            //MPU6050 初始化        LEDInit();                //指示灯初始化        UltraSelfCheck();        //超声模块开机自检    InfrareSelfCheck();        //红外模块开机自检        delay_ms(500);            //延时 0.5s，等待蓝牙模块启动    Uart3SendStr(\"\\r\\nAT+BAUD8\\r\\n\"); //配置蓝牙串口波特率为 115200 ( 原波特率9600 )     USART3Init(1);            //更改 UART3 波特率为 115200    delay_ms(20);           //延时 20ms,等待波特率稳定    SetBlueToothName();        //配置蓝牙模块名称}\n\n\n\n\n\n3.2 PIDInit 函数PIDInit 函数主要是对小车系统的PID算法的参数进行初始化。\n  PID 是 Proportional（比例）、Integral（积分）、Differential（微分）的首字母缩写；是一种结合比例、积分和微分三种环节于一体的闭环控制算法。PID 控制的实质是对目标值和实际值误差进行比例、积分、微分运算后的结果用来作用在输出上。\n  自平衡小车的PID算法思路上文已经讲过，整理就不再赘述了。\nvoid PIDInit(){\tchar flag[2];\t\tReadFlash(original_PID_Addr, flag, 2);\tif((flag[0] == 0xa5)&amp;&amp;(flag[1] == 0x5a))\t{// 非初次运行\t\tPIDRead();\t}\telse{// 初次运行\t\tflag[0] = 0xa5;\t\tflag[1] = 0x5a;\t\tProgramFlash(original_PID_Addr, flag, 2);\t\tProgramFlash(original_PID_Addr+2, (char*)&amp;g_tCarAnglePID, sizeof(PID_t));// ±£´æ½Ç¶È»·Ä¬ÈÏpid²ÎÊý\t\tProgramFlash(original_PID_Addr+2+16, (char*)&amp;g_tCarSpeedPID, sizeof(PID_t));// ±£´æËÙ¶È»·Ä¬ÈÏPID²ÎÊý\t}}\n\n\n\n\n\n3.3 CarUpstandInit函数  CarUpstandInit 函数的主要功能是对小车系统的各种参数进行初始化。\n  即全局变量初始化函数。\nvoid CarUpstandInit(void){\t//g_iAccelInputVoltage_X_Axis = g_iGyroInputVoltage_Y_Axis = 0;\tg_s16LeftMotorPulse = g_s16RightMotorPulse = 0;\tg_s32LeftMotorPulseOld = g_s32RightMotorPulseOld = 0;\tg_s32LeftMotorPulseSigma = g_s32RightMotorPulseSigma = 0;\tg_fCarSpeed = g_fCarSpeedOld = 0;\tg_fCarPosition = 0;\tg_fCarAngle    = 0;\tg_fGyroAngleSpeed = 0;\tg_fGravityAngle   = 0;\tg_fAngleControlOut = g_fSpeedControlOut = g_fBluetoothDirectionOut = 0;\tg_fLeftMotorOut    = g_fRightMotorOut   = 0;\tg_fBluetoothSpeed  = g_fBluetoothDirection = 0;\tg_fBluetoothDirectionNew = g_fBluetoothDirectionOld = 0;  g_u8MainEventCount=0;\tg_u8SpeedControlCount=0; \tg_u8SpeedControlPeriod=0;}\n\n\n\n\n\n3.4 SysTick_Init函数  SysTick_Init 是系统滴答定时器 SysTick 的初始化，在这里设置为 1ms 中断一次。\nvoid SysTick_Init(void){\t/* SystemFrequency / 100     10ms中断一次\t   SystemFrequency / 1000    1ms中断一次\t * SystemFrequency / 100000\t 10us中断一次\t * SystemFrequency / 1000000 1us中断一次\t */\tSystemCoreClockUpdate();\tif (SysTick_Config(SystemCoreClock / 1000))\t// ST3.5.0库版本\t{ \t\t/* Capture error */ \t\twhile (1);\t}\t// 开启滴答定时器 \tSysTick-&gt;CTRL |=  SysTick_CTRL_ENABLE_Msk;}\n\n\n\n\n\n3.5 其他函数  if(IsInfrareOK()) g_iGravity_Offset = 1; 检测是否悬挂红外循迹模块，如果有则需要修改重心偏移值。因为在一侧悬挂红外后，小车重心会偏移。\n  ShowHomePageInit 主要是在 OLED 显示 logo。\n  while(1) 主循环中主要是执行一些非实时任务（早些迟些执行都无所谓的任务），人为定义一个秒级任务，轮询执行这些任务。这些非实时任务有上报数据、调试数据、解析协议、刷新 OLED 数据、读取距离等。\n  执行完初始化，代码会由于滴答定时器 SysTick 进入中断而转跳到 SysTick 定时中断服务函数中执行。在 stm32f10x_it.c 中可以找到 SysTick_Handler 定时中断服务函数。代码具体内容如下：\nvoid SysTick_Handler(void){      SoftTimerCountDown();             //软定时器    g_u8MainEventCount++;            //主事件计数变量    g_u8SpeedControlPeriod++;        //速度环控制周期计数变量    SpeedControlOutput();            //速度环控制输出函数，每1ms执行一次    if(g_u8MainEventCount&gt;=5)        //5ms进入一次    {        g_u8MainEventCount=0;        GetMotorPulse();             //捕获电机脉冲（速度）函数，每5ms执行一次    }    else if(g_u8MainEventCount==1)    {        MPU6050_Pose();                 //读取MPU6050数据函数，每5ms执行一次        AngleCalculate();             //角度环计算函数，每5ms执行一次    }    else if(g_u8MainEventCount==2)    {        AngleControl();                 //角度环控制函数，每5ms执行一次    }    else if(g_u8MainEventCount==3)    {        g_u8SpeedControlCount++;        if(g_u8SpeedControlCount &gt;= 5)//25ms        {                      SpeedControl();          //车模速度控制函数，每25ms调用一次              g_u8SpeedControlCount=0;                g_u8SpeedControlPeriod=0;        }    }    else if(g_u8MainEventCount==4)    {        MotorManage();            //电机使能/失能控制函数，每5ms执行一次        MotorOutput();             //电机输出函数，每5ms执行一次    }}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4. 软件开发  我负责的是两轮自平衡小车的软件部分（下位机）的编写与验证。\n  主要编程软件：\nMDK-ARM；STM32CubeMx；stlink烧入\n\n\n\n\n\n\n4.1 STM32CubeMx生成工程  首先，先选择对应的主控芯片的型号：stm32f103c8tc\n\n\n  接着，配置好工程的基本设置\n \n\n\n\n\n\n\n\n\n\n4.2Usart与Printf函数重定向\n\n\n\n\n\nMiaowLabs-STM32F1-Tiny 核心板板载 CH340 USB to TTL 芯片，该芯片连接 STM32F103C8T6 芯片的 Usart1 引脚 PA9/PA10。\n","categories":["MCU"],"tags":["MCU"]},{"title":"CVP_to_SVP","url":"/2024/03/16/CVP-to-SVP/","content":"From CVP to SVP1.SVP问题  svp问题(Shortest Vector Problem），顾名思义，就是在格中寻找”长度“最短的向量。\n  将抽象的问题定量分析，我们可以把格中的一个点设置为坐标轴0点。这样可以把问题转化为：找到距离 0 点最近的格点   \n  一般而言，我们使用向量的欧几里得范数作为“距离”的定义。\n定义：对于维向量的欧几里得范数为\n对于维的格，因为一个格基由条向量组成，相应的就会有条最短的向量。\n下图展示了一个2维的最短两条向量\n\n\n\n\n\n\n二维的SVP问题可以画同心圆来求解，但是如果维度上去了作图就行不通了。\n但是，如果我们可以拿到相互正交的基格，那么我们只需要遍历基格中的各个向量就可以找到最短的向量了。\n\n\n\n\n为了找到最短的向量，就要尽量使基格正交。\n2.CVP问题Lattice中另一大问题就是最近向量问题（CVP，Closest Vector Problem）了。问题的定义是这样的：给定连续空间中任意的一个点 ，找到距离这个点最近的格点 。\n\n\n\n\n其余包括还有 SIVP问题（Shortest Independent Vectors Problem）,BDD（Bounded Distance Decoding）问题 ,ADD（Absolute Distance Decoding）问题  等都是 SVP, CVP 的衍生，可以搞出如下的关联性\n\n\n\n\n\n\n\n\n\n\n\n\nCVP--&gt;SVP\n\n\n\n假设我们有一个一维的格，然后我们需要找到距离点最近的格点\n\n\n\n\n我们可以将格点”升维“，使得也成为新格的一个格点。\n\n\n\n\n\n\n\n\n  接下来，在这个新格中我们解决一下 SVP，找到最短向量，然后再将这个最短向量投影回原来的低维中，我们就能找到原来格中距离最近的格点了。\n\n\n\n\n这样，CVP问题能够转化为SVP问题，而解决SVP问题的关键还是找到正交基\n3.Gram-Schmidt基格正交化  事实上，由于“离散”的特性，我们仅可以通过对格基进行一系列（系数为整数）的线性变换找到接近正交的基，而这一过程，我们称为格基规约（Lattice Basis Reduction）\n这里我们先介绍一种在线性代数中会学到的规约方法，即 Gram-Schmidt正交化，方便起见，我们在二维格上进行演示。\n假设我们拥有一组基  \n\n\n\n\n\n\n\n\n  在这个Lattice中，这两个基向量是不垂直的。接下来，我们尝试找到一组互相垂直的基满足  $b_1^\\perp b_2^。垂直是相互，所以我们先设b_1^*= b_1，然后尝试去找b_2^*$ \n\n\n\n\n\n\n\n\n  显然 ，不过由于在格上我们仅可以通过对格基进行一系列系数为整数的线性变换我们最终所能得到的尽可能“垂直“的格基\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  高斯算法中蕴含的思想与欧几里得算法类似，两者都是不断地实施先约化后交换的策略。在伪代码中，**(2)(b)是约化步，(2)(c\\ii)是交换步**。\n不停地让两个向量互相约化，直到它们无法变得更短为止\n低维\n#sagedef Gauss(x,y):    # step 1    v1 = x; v2 = y    finished = False    # step 2    while not finished:        # (a)        m = round(( v2.dot_product(v1) / v1.dot_product(v1) ))        # (b)        v2 = v2 - m*v1        # (c)        if v1.norm() &lt;= v2.norm():            finished = True        else:            v1, v2 = v2, v1       return v1, v2\n\n\n\n高维（LLL算法）\ndef max(a, b):    return a if a &gt; b else bdef LLL_v0(M, delta=0.75):    B = deepcopy(M)    Q, mu = B.gram_schmidt()    n, k = B.nrows(), 1        while k &lt; n:                # size reduction step        for j in reversed(range(k)):            if abs( mu[k][j] ) &gt; 0.5:                B[k] = B[k] - round( mu[k][j] ) * B[j]                Q, mu = B.gram_schmidt()                # swap step         if Q[k].dot_product(Q[k]) &gt;= (delta - mu[k][k-1]^2) * Q[k-1].dot_product(Q[k-1]):            k = k + 1        else:            B[k], B[k-1] = B[k-1], B[k]            Q, mu = B.gram_schmidt()            k = max(k-1,1)        return B \n\n\n\n\n\nReference：\n\n格基规约算法：算法详解-CSDN博客 \n(https://mp.weixin.qq.com/s/nzFRgOUkffeUaF9PqtEnQA )\nLattice学习笔记02：格中难题 - 知乎 (zhihu.com) \n\n","tags":["Crypto"]}]