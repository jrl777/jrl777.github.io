[{"title":"DES-Study","url":"/2023/04/13/DES-Study/","content":"DES-Study强加密算法（基于以下两种本源操作）：\n（1）混淆（Confusion）：是一种使密钥与密文之间的关系尽可能模糊的加密操作。如今实 现混淆常用的一个元素就是替换；这个元素在DES和AES中都有使用。 \n（2）扩散（Diffusion）：是一种为了隐藏明文的统计属性而将一个明文符号的影响扩散到 多个密文符号的加密操作。最简单的扩散元素就是位置换，它常用于DES中；而AES则使用更高级的 Mixcolumn 操作。 \n1.DefineDES是一种使用56位密钥对64位长分组进行加密的密码（如图3-3）。\n\n\nDES是一种对称密码，即其加密过程和解密过程使用相同的密钥。与几乎所有现代分组加密一样，DES也是一种迭代算法。DES对明文中每个分组的加密过程都包含16轮，且每轮的操作完全相同。图3-4显示了DES的轮结构。每轮都会使用不同的子密钥，并且所有子密钥k；都从主密钥k中推导而来的。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.Feistel网络每轮中仅加密输入为的一半，未加密右半部分，用的是伪随机数产生器的输出对左半部分进行XOR操作。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Crypto"]},{"title":"SYC三面","url":"/2022/12/16/SYC/","content":"1.对于Task代码注释的补齐1.1 Task：from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytesimport gmpy2 as gpimport randomfrom flag import flagflag = bytes_to_long(flag)p = getPrime(100)    #说明含义q = getPrime(100)    #说明含义n = p * qclist = []for i in bin(flag)[2:]:    #说明含义    while True:        x = random.randint(1, n)   #说明含义        if gp.gcd(x, n) == 1:   #说明含义            c = (pow(3, int(i) + x * 2, n) * x**2) % n                 clist.append(c)            breakprint(n)print(clist)&#x27;&#x27;&#x27;1254676922968308054473282588201432441748387886551758353389559[112490766735794793494258589897687977797993914062877995369853, 423825989606899409733986824741778284626898537704684650054048, 1239912440099782777043012567198356769914426423982980091061342, 1078272043845620437375344423460688188703277391763226546180151, 159286594418951337823608883690981934876156746053051292254402, 189434397083734065502133592439774066008070864031834709620441, 264105932521685455831442874483122006851812174082486446496525, 252479590298382195780257510632414277760400686563367629394825, 34602153293813328946647556336715300088648653636913843351330, 808692976248223555967993480457680585654329233137701900525232, 836623390705731389723338030121423143060093415003999783847569, 1218829648463542488706300570862499177531816513847669694517865, 571795296699927140597629733281737316938588378300113684751321, 324408602401500017634991400429058861929441907523133040616718, 652309276856121062936275131393396513436481452168222192943617, 135368324264829776566203256490111602190045577103623626459391, 677807894471260530035795635544578014296111908610448488780236, 1135708831589387209825610411788217272141435421502826225558333, 196882176169680492388044653063809988445336200851553236565493, 1130705847039352086713022625138307016610235729598245321418537, 974627899979016730650505688458957247745733629797568884460037, 948987355716018600108888773982169186615279073844787201014331, 364200727831752453880724784142441918092136276002472196567297, 811786724825671349602848333002825903390189436235744947667153, 248544601758659627780643527412918707686666534454807514221527, 1078860601713092925823762998344218082511712606733279204236487, 634851505432770176888905188832078431577879067601938324607512, 232972021265122845242665536151391828176473610240017058444456, 1080796896535347345799923528377657622102130648424673730618155, 622059452832122796944248249707923610120342427983134655552340, 837257289852652447556360719449396492271622453092839975184158, 626327369687614106133688347844033161113612134573404258486630, 1233019194503373412608053469954621323121044455057773900406773, 912564467902216938034173803480737819092198560216579817988291, 408076399689155479697691914877522087726703540593136498587215, 1118745562641959211267518507476218888452509349041078337285098, 1103228775032586830415033772993541541820163005491285279882940, 680899077364553221002722115625274809744677788062477442312086, 355349436487753936000721704075588637048102593449252106813298, 5254361838244723184679801326407268664182654715017847086461, 480145671282471097574354032682584083826945502763658946101104, 249136810947175342894562520096603076879372702701088690594445, 175216547555975039599856545426098941943382367602172941744494, 436310864447848960706296122266108102033486860525693191197797, 342620466614509535208918527767209905005823047382938223113086, 369848992268737575958936185907214270590887322936419642815242, 278575045025661827978388874494219837629182438978526195181637, 1189171180780533071473125545247289861677955100195126109964590, 256190182678715266654387215899616014762531664768736561586327, 719160215933023695898776016718481385742508618676368640641809, 147033122794177086112261858085593706727904275426698884436011, 247466503394960387825735598976068779045757078494832316444804, 787155643450160361724955357286670519256662665704845721250609, 112101120505278148126370035869523081506090979629681063614381, 890009544685851814191758439205974159586245412054287515881584, 1168625756997945588141764967298286550498540363325170551587334, 946031342434770434479581499217378781992921204179509449159996, 759124753621557368233069144948668001126536400499520990700641, 930584421635842804698880452391670787414151645249729141739148, 140981825203074314092967178062754008486703246602401550271041, 880126454149733441805446179826584472107299085899567279467558, 510129631452465708304688340114214360026947205003705062663759, 857274757020001316639221394675820731579775247610619594760511, 444486969413575687285961819261097401974268741167841964919716, 645830958128126799221416466698967430939726760487764050203821, 128864469762235652994228226148325614187747349331618451490354, 732913002124581119538173953534485652651112140400076340646452, 1245672039639609341331477592944058028011275464117654972595670, 1160765030758624190775369713232721901616189349905945190302338, 745734132091942990384796294800038299023052878196943617322617, 34973161572808799782240527358912894045293050940490682156733, 507586651070816931641904112686082840821460472219390068396982, 359195216122538975934588740641220005777478961423841727365432, 60506687352654743312206686911057762445232526009857863834444, 402036521271253699065227780662896890228371046068283711170220, 465427226677337673103293964961886503610313835775181975449721, 925246962888172144515172444374190859841851825972285013006527, 542176614893876361668218387162168517498644799220587472896002, 852215132196560596695876248813488364201491362280912035912061, 945548964927065532651141821562204387565145712002346337639711, 736943822066388892909878515650831955490636214039062998720510, 766357526983761241394182000478355475617711906398422036954152, 77156525593382594092608158744099524034892127423492520631820, 562562817542804973601572838378263130638457829485887327130286, 768093992370198202822524520006977816845162154854939167515517, 1099957424762490943973557935337350760135180754563993547358098, 698816668614997174913438496891169625976027534942525487303513, 417641699919584202170293946436276552973997395211792288687960, 1006229610175567855209117721408416419896921240126676949824724, 4206431689326446028142220658552064336105749936096602165359, 893846509909828693967573302731018066461118006150050253703744, 878425189026235350891203121924637130803808920422558040493294, 730047416245095988472212050949689633327186823542036387345181, 648095719945750715387983948406690533087473721929975873848169, 213513454359755001454814601053555627585345770061082141021326, 350001050012957205656929492039628823072469208940960439158263, 1016858635000037892730835311903706149371704230428070443107320, 1040987439471207869975679257301693610464700899302787643642354, 1194690615352550474729309715449838057220521596135246725909553, 508165053077110820797186371383859674371399129952105597675096, 266494438294281492504556232035584920066331725618646155019547, 28469482072427012244441092412738741355431846649166066368980, 790175775999108776289865518368056397969387298334297622465909, 590581138260907253939363764832940322585129285968275409510634, 221909012579985462013325803334419731308959816500415305934495, 1063780559219791515938747204569742799329237935871594345400252, 977747525495509380693721486866821791065499754056415279744653, 346306061371595730004513789139807509540063462412619321003626, 456103179467597859705969406860196938169100856240100927540401, 969300078509189631808517876996065933181606409375207150288464, 1029806631220370012120597683927351131622576733031694535189521, 344896431603140401163996810922500893279239069499717183710501, 430000423804197030568046280589772094106128395099434235915031, 700179843567016021775399107572964843751703290591400960796112, 961227906080189143689698720420426659986080298413605666115640, 607209606799750473714271393200060455739097869884727178692312, 106958847163040842225140399905505511449479709017540851084532, 953369942103273809257762268859167463617831445026988544378658, 428269440686506672744282327102546440435442014650795927162711, 56621803434665963032193024056111306570802155743250152849716, 800707635631355839166448276143596444307614901816577459076131, 1032256515703247765067950588859299047987257001987777631061065, 813725055801254665600156259482200403981770576173968929131487, 940024839745068011043019236327963504645352520797347949823455, 1065005324140908547287467504568283884363143527586278243210801, 1087828777506290663525994551834233065465427418753806182842291, 668387132001968449612224853010931354244797738682007519611989, 563185246196177998134932666270526715161378776103340983046580, 148292872313931508344196679476720973752571125303712466045656, 413889563851226543249984374872220761253120628252088546262699, 853542105910386365929770611480736086723126396438880650918917, 59730458840715910492468261806200793684923819793480597554146, 792260492800286127199649276659137441324248689470594987965190, 753608630500639136668081531883097047491651258191552267413126, 33514911499472634865669915075769163328171019557849259474018, 634963859228206842307837566519244534650818456901841184879977, 219354096455968590219445072777282329948785844491217770978344, 1123377226439583158729762969668999276741275445803396272436031, 357765295513680388973981712560200525235334734759663454993805, 385868499980630535766019957877752149506518574529845752144666, 138578212294299392480319417966870656714476525885983752756188, 1110526796192425688386237355263892073046060477008920073455044, 244699783645221387947312903861559688207612147588246639081699, 583209905862562678600202085212425597809036630416117298854978, 1207854793808762194414317661151529169444903662139065050090746, 1127506983223466275821900811940356395242309493951089427884032, 526185119576631048584313761548704536031634598332129570964689, 266882032196696984660521486449809902101615921156569537960109, 1188118705564450461919200724390473040524626320052324478509883, 682831747455078454647149830819696088960233603851250102828667, 669419928942561433130809268138650695825596612075801278942980, 1077750630919867687880983437504767304166615787212813240073843, 486023540111308483450127320955599047045479654684477043315645, 409429366346146233850088863324915025465847596238000661872172, 779883595226131237594759409249289551033410304517183865388408, 1155872225708857920911178110668279174877878422508206228579940, 411063490066038942009369947241345843238439795078686488373864, 1243453053541946030699872676712518536022061850799945414120045, 871711034820169700581685353768658469631429266493677466057997, 601920686459160120670719526703980120744719013393032353678765, 329932100141177850249406090412821976994089707958551194468769, 558327299751202100333335353826111016492585371503632197870640, 113444032302978611299580451314055133491399096282744687816086, 152525914892717139057165748051966776217223953242540511499945, 965404850400527912039904270871065001313018148780552532312669, 313557099445185696402013375071955475516203519824979749629786, 952254159335810337756614972813240144837526566801182319987154]&#x27;&#x27;&#x27;\n\n\n\n\n\n\n\n\n\n\n\n1.2 注释与补齐：from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytesimport gmpy2 as gpimport randomfrom flag import flag  #flag未知flag = bytes_to_long(flag)#getPrime来自Crypto库中的Util.number模块，其作用是随机获得一个N比特位的素数，同时进行检验，确保正确性  p = getPrime(100)   #随机获得一个100比特位的素数，并将它的值赋值给pq = getPrime(100)   #随机获得一个100比特位的素数，并将它的值赋值给qn = p * qclist = []for i in bin(flag)[2:]:    #将flag转为二进制数，获取从偏移为2到末尾的数，再历遍所有可能    while True:        x = random.randint(1, n)   #生成在1与n之间的整数x(1&lt;=x&lt;=n)        if gp.gcd(x, n) == 1:   #引用gp.gcd函数，判断x与n是否互质            c = (pow(3, int(i) + x * 2, n) * x**2) % n                 clist.append(c)  #将c添加到clist列表末尾            breakprint(n)print(clist)#给出n与若干组c的值&#x27;&#x27;&#x27;1254676922968308054473282588201432441748387886551758353389559[112490766735794793494258589897687977797993914062877995369853, 423825989606899409733986824741778284626898537704684650054048, 1239912440099782777043012567198356769914426423982980091061342, 1078272043845620437375344423460688188703277391763226546180151, 159286594418951337823608883690981934876156746053051292254402, 189434397083734065502133592439774066008070864031834709620441, 264105932521685455831442874483122006851812174082486446496525, 252479590298382195780257510632414277760400686563367629394825, 34602153293813328946647556336715300088648653636913843351330, 808692976248223555967993480457680585654329233137701900525232, 836623390705731389723338030121423143060093415003999783847569, 1218829648463542488706300570862499177531816513847669694517865, 571795296699927140597629733281737316938588378300113684751321, 324408602401500017634991400429058861929441907523133040616718, 652309276856121062936275131393396513436481452168222192943617, 135368324264829776566203256490111602190045577103623626459391, 677807894471260530035795635544578014296111908610448488780236, 1135708831589387209825610411788217272141435421502826225558333, 196882176169680492388044653063809988445336200851553236565493, 1130705847039352086713022625138307016610235729598245321418537, 974627899979016730650505688458957247745733629797568884460037, 948987355716018600108888773982169186615279073844787201014331, 364200727831752453880724784142441918092136276002472196567297, 811786724825671349602848333002825903390189436235744947667153, 248544601758659627780643527412918707686666534454807514221527, 1078860601713092925823762998344218082511712606733279204236487, 634851505432770176888905188832078431577879067601938324607512, 232972021265122845242665536151391828176473610240017058444456, 1080796896535347345799923528377657622102130648424673730618155, 622059452832122796944248249707923610120342427983134655552340, 837257289852652447556360719449396492271622453092839975184158, 626327369687614106133688347844033161113612134573404258486630, 1233019194503373412608053469954621323121044455057773900406773, 912564467902216938034173803480737819092198560216579817988291, 408076399689155479697691914877522087726703540593136498587215, 1118745562641959211267518507476218888452509349041078337285098, 1103228775032586830415033772993541541820163005491285279882940, 680899077364553221002722115625274809744677788062477442312086, 355349436487753936000721704075588637048102593449252106813298, 5254361838244723184679801326407268664182654715017847086461, 480145671282471097574354032682584083826945502763658946101104, 249136810947175342894562520096603076879372702701088690594445, 175216547555975039599856545426098941943382367602172941744494, 436310864447848960706296122266108102033486860525693191197797, 342620466614509535208918527767209905005823047382938223113086, 369848992268737575958936185907214270590887322936419642815242, 278575045025661827978388874494219837629182438978526195181637, 1189171180780533071473125545247289861677955100195126109964590, 256190182678715266654387215899616014762531664768736561586327, 719160215933023695898776016718481385742508618676368640641809, 147033122794177086112261858085593706727904275426698884436011, 247466503394960387825735598976068779045757078494832316444804, 787155643450160361724955357286670519256662665704845721250609, 112101120505278148126370035869523081506090979629681063614381, 890009544685851814191758439205974159586245412054287515881584, 1168625756997945588141764967298286550498540363325170551587334, 946031342434770434479581499217378781992921204179509449159996, 759124753621557368233069144948668001126536400499520990700641, 930584421635842804698880452391670787414151645249729141739148, 140981825203074314092967178062754008486703246602401550271041, 880126454149733441805446179826584472107299085899567279467558, 510129631452465708304688340114214360026947205003705062663759, 857274757020001316639221394675820731579775247610619594760511, 444486969413575687285961819261097401974268741167841964919716, 645830958128126799221416466698967430939726760487764050203821, 128864469762235652994228226148325614187747349331618451490354, 732913002124581119538173953534485652651112140400076340646452, 1245672039639609341331477592944058028011275464117654972595670, 1160765030758624190775369713232721901616189349905945190302338, 745734132091942990384796294800038299023052878196943617322617, 34973161572808799782240527358912894045293050940490682156733, 507586651070816931641904112686082840821460472219390068396982, 359195216122538975934588740641220005777478961423841727365432, 60506687352654743312206686911057762445232526009857863834444, 402036521271253699065227780662896890228371046068283711170220, 465427226677337673103293964961886503610313835775181975449721, 925246962888172144515172444374190859841851825972285013006527, 542176614893876361668218387162168517498644799220587472896002, 852215132196560596695876248813488364201491362280912035912061, 945548964927065532651141821562204387565145712002346337639711, 736943822066388892909878515650831955490636214039062998720510, 766357526983761241394182000478355475617711906398422036954152, 77156525593382594092608158744099524034892127423492520631820, 562562817542804973601572838378263130638457829485887327130286, 768093992370198202822524520006977816845162154854939167515517, 1099957424762490943973557935337350760135180754563993547358098, 698816668614997174913438496891169625976027534942525487303513, 417641699919584202170293946436276552973997395211792288687960, 1006229610175567855209117721408416419896921240126676949824724, 4206431689326446028142220658552064336105749936096602165359, 893846509909828693967573302731018066461118006150050253703744, 878425189026235350891203121924637130803808920422558040493294, 730047416245095988472212050949689633327186823542036387345181, 648095719945750715387983948406690533087473721929975873848169, 213513454359755001454814601053555627585345770061082141021326, 350001050012957205656929492039628823072469208940960439158263, 1016858635000037892730835311903706149371704230428070443107320, 1040987439471207869975679257301693610464700899302787643642354, 1194690615352550474729309715449838057220521596135246725909553, 508165053077110820797186371383859674371399129952105597675096, 266494438294281492504556232035584920066331725618646155019547, 28469482072427012244441092412738741355431846649166066368980, 790175775999108776289865518368056397969387298334297622465909, 590581138260907253939363764832940322585129285968275409510634, 221909012579985462013325803334419731308959816500415305934495, 1063780559219791515938747204569742799329237935871594345400252, 977747525495509380693721486866821791065499754056415279744653, 346306061371595730004513789139807509540063462412619321003626, 456103179467597859705969406860196938169100856240100927540401, 969300078509189631808517876996065933181606409375207150288464, 1029806631220370012120597683927351131622576733031694535189521, 344896431603140401163996810922500893279239069499717183710501, 430000423804197030568046280589772094106128395099434235915031, 700179843567016021775399107572964843751703290591400960796112, 961227906080189143689698720420426659986080298413605666115640, 607209606799750473714271393200060455739097869884727178692312, 106958847163040842225140399905505511449479709017540851084532, 953369942103273809257762268859167463617831445026988544378658, 428269440686506672744282327102546440435442014650795927162711, 56621803434665963032193024056111306570802155743250152849716, 800707635631355839166448276143596444307614901816577459076131, 1032256515703247765067950588859299047987257001987777631061065, 813725055801254665600156259482200403981770576173968929131487, 940024839745068011043019236327963504645352520797347949823455, 1065005324140908547287467504568283884363143527586278243210801, 1087828777506290663525994551834233065465427418753806182842291, 668387132001968449612224853010931354244797738682007519611989, 563185246196177998134932666270526715161378776103340983046580, 148292872313931508344196679476720973752571125303712466045656, 413889563851226543249984374872220761253120628252088546262699, 853542105910386365929770611480736086723126396438880650918917, 59730458840715910492468261806200793684923819793480597554146, 792260492800286127199649276659137441324248689470594987965190, 753608630500639136668081531883097047491651258191552267413126, 33514911499472634865669915075769163328171019557849259474018, 634963859228206842307837566519244534650818456901841184879977, 219354096455968590219445072777282329948785844491217770978344, 1123377226439583158729762969668999276741275445803396272436031, 357765295513680388973981712560200525235334734759663454993805, 385868499980630535766019957877752149506518574529845752144666, 138578212294299392480319417966870656714476525885983752756188, 1110526796192425688386237355263892073046060477008920073455044, 244699783645221387947312903861559688207612147588246639081699, 583209905862562678600202085212425597809036630416117298854978, 1207854793808762194414317661151529169444903662139065050090746, 1127506983223466275821900811940356395242309493951089427884032, 526185119576631048584313761548704536031634598332129570964689, 266882032196696984660521486449809902101615921156569537960109, 1188118705564450461919200724390473040524626320052324478509883, 682831747455078454647149830819696088960233603851250102828667, 669419928942561433130809268138650695825596612075801278942980, 1077750630919867687880983437504767304166615787212813240073843, 486023540111308483450127320955599047045479654684477043315645, 409429366346146233850088863324915025465847596238000661872172, 779883595226131237594759409249289551033410304517183865388408, 1155872225708857920911178110668279174877878422508206228579940, 411063490066038942009369947241345843238439795078686488373864, 1243453053541946030699872676712518536022061850799945414120045, 871711034820169700581685353768658469631429266493677466057997, 601920686459160120670719526703980120744719013393032353678765, 329932100141177850249406090412821976994089707958551194468769, 558327299751202100333335353826111016492585371503632197870640, 113444032302978611299580451314055133491399096282744687816086, 152525914892717139057165748051966776217223953242540511499945, 965404850400527912039904270871065001313018148780552532312669, 313557099445185696402013375071955475516203519824979749629786, 952254159335810337756614972813240144837526566801182319987154]&#x27;&#x27;&#x27;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.Paper‘s notes2.1 关于数论：\n论文中会自主定义一些乘法群、域\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.2 中国剩余定理与二次剩余：2.2.1 中国剩余定理：\n\n\n\n\n\n\n\n\n\n\n\n中国剩余定理公式：\n\n设正整数两两互素，则同余方程组\n​               \n有整数解。并且在模下的解是唯一的，解为\n​                \n其中，而为模的逆元。\n\n中国剩余定理学习笔记 - MashiroSky - 博客园 (cnblogs.com)\n2.2.2 二次剩余：1. 二次剩余定理：对于n和素数p来说，存在x使\n 方程  x^2≡n(mod p)    \n成立\n2. 引入符号：勒让德符号，这个符号里有两个值，一个是n,一个是p。假设p为奇素数，且n无法整除p时，有以下定义\n\n\n\n\n\n\n\n\n\n\n\n类似于paper中的雅可比符号\n\n3. 证明：\n(5条消息) 二次剩余定理详解_gerayking的博客-CSDN博客_二次剩余定理\n2.3 笔记整理：2.3.1 算法：1. 判断x是否为二次剩余\n\n\n\n\n\n\n\n\n\n\n\n\n\n2. 用N已知的因子p、q判断模N下数x是否为二次剩余\n\n\n\n\n\n\n\n\n\n\n\n\n\n3. 已知条件\n\n\n\n\n\n\n\n\n\n\n\n\n\n4. 加密算法\n\n\n\n\n\n\n\n\n\n\n\n\n\n5. 解密算法由于接收者已知私钥：p、q，他就不需要另外单独的解密算法，通过判断c是否为二次剩余，他就可以知道密文为0还是1。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.3.2 命题：1. 二次剩余\n2. 雅可比符号\n3. 雅可比乘法性质\n4. 二次剩余的复合运算\n5. 二次剩余与雅可比的分布\n\n6. 雅可比的复合运算\n3. Task解题3.1 题目模型：本task的模型是 Goldwasser-Micali Cryprosystem，即GM公钥加密系统\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.2解题思路：3.2.1 题目分析：from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytesimport gmpy2 as gpimport randomfrom flag import flagflag = bytes_to_long(flag)p = getPrime(100)   q = getPrime(100)    n = p * qclist = []for i in bin(flag)[2:]:        while True:        x = random.randint(1, n)          if gp.gcd(x, n) == 1:              c = (pow(3, int(i) + x * 2, n) * x**2) % n                 clist.append(c)            breakprint(n)print(clist)&#x27;&#x27;&#x27;1254676922968308054473282588201432441748387886551758353389559[112490766735794793494258589897687977797993914062877995369853, 423825989606899409733986824741778284626898537704684650054048, 1239912440099782777043012567198356769914426423982980091061342, 1078272043845620437375344423460688188703277391763226546180151, 159286594418951337823608883690981934876156746053051292254402, 189434397083734065502133592439774066008070864031834709620441, 264105932521685455831442874483122006851812174082486446496525, 252479590298382195780257510632414277760400686563367629394825, 34602153293813328946647556336715300088648653636913843351330, 808692976248223555967993480457680585654329233137701900525232, 836623390705731389723338030121423143060093415003999783847569, 1218829648463542488706300570862499177531816513847669694517865, 571795296699927140597629733281737316938588378300113684751321, 324408602401500017634991400429058861929441907523133040616718, 652309276856121062936275131393396513436481452168222192943617, 135368324264829776566203256490111602190045577103623626459391, 677807894471260530035795635544578014296111908610448488780236, 1135708831589387209825610411788217272141435421502826225558333, 196882176169680492388044653063809988445336200851553236565493, 1130705847039352086713022625138307016610235729598245321418537, 974627899979016730650505688458957247745733629797568884460037, 948987355716018600108888773982169186615279073844787201014331, 364200727831752453880724784142441918092136276002472196567297, 811786724825671349602848333002825903390189436235744947667153, 248544601758659627780643527412918707686666534454807514221527, 1078860601713092925823762998344218082511712606733279204236487, 634851505432770176888905188832078431577879067601938324607512, 232972021265122845242665536151391828176473610240017058444456, 1080796896535347345799923528377657622102130648424673730618155, 622059452832122796944248249707923610120342427983134655552340, 837257289852652447556360719449396492271622453092839975184158, 626327369687614106133688347844033161113612134573404258486630, 1233019194503373412608053469954621323121044455057773900406773, 912564467902216938034173803480737819092198560216579817988291, 408076399689155479697691914877522087726703540593136498587215, 1118745562641959211267518507476218888452509349041078337285098, 1103228775032586830415033772993541541820163005491285279882940, 680899077364553221002722115625274809744677788062477442312086, 355349436487753936000721704075588637048102593449252106813298, 5254361838244723184679801326407268664182654715017847086461, 480145671282471097574354032682584083826945502763658946101104, 249136810947175342894562520096603076879372702701088690594445, 175216547555975039599856545426098941943382367602172941744494, 436310864447848960706296122266108102033486860525693191197797, 342620466614509535208918527767209905005823047382938223113086, 369848992268737575958936185907214270590887322936419642815242, 278575045025661827978388874494219837629182438978526195181637, 1189171180780533071473125545247289861677955100195126109964590, 256190182678715266654387215899616014762531664768736561586327, 719160215933023695898776016718481385742508618676368640641809, 147033122794177086112261858085593706727904275426698884436011, 247466503394960387825735598976068779045757078494832316444804, 787155643450160361724955357286670519256662665704845721250609, 112101120505278148126370035869523081506090979629681063614381, 890009544685851814191758439205974159586245412054287515881584, 1168625756997945588141764967298286550498540363325170551587334, 946031342434770434479581499217378781992921204179509449159996, 759124753621557368233069144948668001126536400499520990700641, 930584421635842804698880452391670787414151645249729141739148, 140981825203074314092967178062754008486703246602401550271041, 880126454149733441805446179826584472107299085899567279467558, 510129631452465708304688340114214360026947205003705062663759, 857274757020001316639221394675820731579775247610619594760511, 444486969413575687285961819261097401974268741167841964919716, 645830958128126799221416466698967430939726760487764050203821, 128864469762235652994228226148325614187747349331618451490354, 732913002124581119538173953534485652651112140400076340646452, 1245672039639609341331477592944058028011275464117654972595670, 1160765030758624190775369713232721901616189349905945190302338, 745734132091942990384796294800038299023052878196943617322617, 34973161572808799782240527358912894045293050940490682156733, 507586651070816931641904112686082840821460472219390068396982, 359195216122538975934588740641220005777478961423841727365432, 60506687352654743312206686911057762445232526009857863834444, 402036521271253699065227780662896890228371046068283711170220, 465427226677337673103293964961886503610313835775181975449721, 925246962888172144515172444374190859841851825972285013006527, 542176614893876361668218387162168517498644799220587472896002, 852215132196560596695876248813488364201491362280912035912061, 945548964927065532651141821562204387565145712002346337639711, 736943822066388892909878515650831955490636214039062998720510, 766357526983761241394182000478355475617711906398422036954152, 77156525593382594092608158744099524034892127423492520631820, 562562817542804973601572838378263130638457829485887327130286, 768093992370198202822524520006977816845162154854939167515517, 1099957424762490943973557935337350760135180754563993547358098, 698816668614997174913438496891169625976027534942525487303513, 417641699919584202170293946436276552973997395211792288687960, 1006229610175567855209117721408416419896921240126676949824724, 4206431689326446028142220658552064336105749936096602165359, 893846509909828693967573302731018066461118006150050253703744, 878425189026235350891203121924637130803808920422558040493294, 730047416245095988472212050949689633327186823542036387345181, 648095719945750715387983948406690533087473721929975873848169, 213513454359755001454814601053555627585345770061082141021326, 350001050012957205656929492039628823072469208940960439158263, 1016858635000037892730835311903706149371704230428070443107320, 1040987439471207869975679257301693610464700899302787643642354, 1194690615352550474729309715449838057220521596135246725909553, 508165053077110820797186371383859674371399129952105597675096, 266494438294281492504556232035584920066331725618646155019547, 28469482072427012244441092412738741355431846649166066368980, 790175775999108776289865518368056397969387298334297622465909, 590581138260907253939363764832940322585129285968275409510634, 221909012579985462013325803334419731308959816500415305934495, 1063780559219791515938747204569742799329237935871594345400252, 977747525495509380693721486866821791065499754056415279744653, 346306061371595730004513789139807509540063462412619321003626, 456103179467597859705969406860196938169100856240100927540401, 969300078509189631808517876996065933181606409375207150288464, 1029806631220370012120597683927351131622576733031694535189521, 344896431603140401163996810922500893279239069499717183710501, 430000423804197030568046280589772094106128395099434235915031, 700179843567016021775399107572964843751703290591400960796112, 961227906080189143689698720420426659986080298413605666115640, 607209606799750473714271393200060455739097869884727178692312, 106958847163040842225140399905505511449479709017540851084532, 953369942103273809257762268859167463617831445026988544378658, 428269440686506672744282327102546440435442014650795927162711, 56621803434665963032193024056111306570802155743250152849716, 800707635631355839166448276143596444307614901816577459076131, 1032256515703247765067950588859299047987257001987777631061065, 813725055801254665600156259482200403981770576173968929131487, 940024839745068011043019236327963504645352520797347949823455, 1065005324140908547287467504568283884363143527586278243210801, 1087828777506290663525994551834233065465427418753806182842291, 668387132001968449612224853010931354244797738682007519611989, 563185246196177998134932666270526715161378776103340983046580, 148292872313931508344196679476720973752571125303712466045656, 413889563851226543249984374872220761253120628252088546262699, 853542105910386365929770611480736086723126396438880650918917, 59730458840715910492468261806200793684923819793480597554146, 792260492800286127199649276659137441324248689470594987965190, 753608630500639136668081531883097047491651258191552267413126, 33514911499472634865669915075769163328171019557849259474018, 634963859228206842307837566519244534650818456901841184879977, 219354096455968590219445072777282329948785844491217770978344, 1123377226439583158729762969668999276741275445803396272436031, 357765295513680388973981712560200525235334734759663454993805, 385868499980630535766019957877752149506518574529845752144666, 138578212294299392480319417966870656714476525885983752756188, 1110526796192425688386237355263892073046060477008920073455044, 244699783645221387947312903861559688207612147588246639081699, 583209905862562678600202085212425597809036630416117298854978, 1207854793808762194414317661151529169444903662139065050090746, 1127506983223466275821900811940356395242309493951089427884032, 526185119576631048584313761548704536031634598332129570964689, 266882032196696984660521486449809902101615921156569537960109, 1188118705564450461919200724390473040524626320052324478509883, 682831747455078454647149830819696088960233603851250102828667, 669419928942561433130809268138650695825596612075801278942980, 1077750630919867687880983437504767304166615787212813240073843, 486023540111308483450127320955599047045479654684477043315645, 409429366346146233850088863324915025465847596238000661872172, 779883595226131237594759409249289551033410304517183865388408, 1155872225708857920911178110668279174877878422508206228579940, 411063490066038942009369947241345843238439795078686488373864, 1243453053541946030699872676712518536022061850799945414120045, 871711034820169700581685353768658469631429266493677466057997, 601920686459160120670719526703980120744719013393032353678765, 329932100141177850249406090412821976994089707958551194468769, 558327299751202100333335353826111016492585371503632197870640, 113444032302978611299580451314055133491399096282744687816086, 152525914892717139057165748051966776217223953242540511499945, 965404850400527912039904270871065001313018148780552532312669, 313557099445185696402013375071955475516203519824979749629786, 952254159335810337756614972813240144837526566801182319987154]&#x27;&#x27;&#x27;\n\n\n\nfor i in bin(flag)[2:]:        #历遍转化为二进制数的flag，即逐位获得flag的二进制位    while True:        x = random.randint(1, n)          #在（1，n）的范围内随机选择用于加密信息的x        if gp.gcd(x, n) == 1:              c = (pow(3, int(i) + x * 2, n) * x**2) % n                 clist.append(c)            break\n\n\n\n\n\n我们观察到本task的模型是 Goldwasser-Micali Cryprosystem，c的加密方式也已经给出，并且在clist数组内列出了每个c的值。\nc是这样加密的：c&#x3D;(3^(int(i)+2x)*x^2)%n \n仔细观察上式，发现当i&#x3D;0时情况特殊。若i&#x3D;0,则c&#x3D;(3^x*x)^2%n\n而此时c是模n的二次剩余。\n$$总结一下，当c是模n的二次剩余，即J_n(c)&#x3D;1时，i&#x3D;0$$\n$$那么相反，当c是模n的非二次剩余，即J_n(c)&#x3D;-1时，i&#x3D;1$$\n3.2.2 破解流程：我们先列出已知条件，即n与clist中若干组加密的c的值\nn=1254676922968308054473282588201432441748387886551758353389559clist=[&#x27;&#x27;&#x27;&#x27;&#x27;&#x27; ]\n\n\n\n\n\n\n\n通过分析，我们发现能够在仅知道公钥n的条件下，通过jacobi判断c是否为二次剩余对flag进行还原。\n攻击设计如下\nflag=&#x27;&#x27;#历遍给出的若干组cfor c in clist:   #判断“二次剩余”，逐个还原flag的二进制数\tif gp.jacobi(c,n)==1:\t\tflag+=&#x27;0&#x27;\tif  gp.jacobi(c,n)==-1:\t\t\tflag+=&#x27;1&#x27;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.2.3 攻击脚本：#GM脚本import gmpy2 as gpfrom libnum import*n=1254676922968308054473282588201432441748387886551758353389559clist=[112490766735794793494258589897687977797993914062877995369853, 423825989606899409733986824741778284626898537704684650054048, 1239912440099782777043012567198356769914426423982980091061342, 1078272043845620437375344423460688188703277391763226546180151, 159286594418951337823608883690981934876156746053051292254402, 189434397083734065502133592439774066008070864031834709620441, 264105932521685455831442874483122006851812174082486446496525, 252479590298382195780257510632414277760400686563367629394825, 34602153293813328946647556336715300088648653636913843351330, 808692976248223555967993480457680585654329233137701900525232, 836623390705731389723338030121423143060093415003999783847569, 1218829648463542488706300570862499177531816513847669694517865, 571795296699927140597629733281737316938588378300113684751321, 324408602401500017634991400429058861929441907523133040616718, 652309276856121062936275131393396513436481452168222192943617, 135368324264829776566203256490111602190045577103623626459391, 677807894471260530035795635544578014296111908610448488780236, 1135708831589387209825610411788217272141435421502826225558333, 196882176169680492388044653063809988445336200851553236565493, 1130705847039352086713022625138307016610235729598245321418537, 974627899979016730650505688458957247745733629797568884460037, 948987355716018600108888773982169186615279073844787201014331, 364200727831752453880724784142441918092136276002472196567297, 811786724825671349602848333002825903390189436235744947667153, 248544601758659627780643527412918707686666534454807514221527, 1078860601713092925823762998344218082511712606733279204236487, 634851505432770176888905188832078431577879067601938324607512, 232972021265122845242665536151391828176473610240017058444456, 1080796896535347345799923528377657622102130648424673730618155, 622059452832122796944248249707923610120342427983134655552340, 837257289852652447556360719449396492271622453092839975184158, 626327369687614106133688347844033161113612134573404258486630, 1233019194503373412608053469954621323121044455057773900406773, 912564467902216938034173803480737819092198560216579817988291, 408076399689155479697691914877522087726703540593136498587215, 1118745562641959211267518507476218888452509349041078337285098, 1103228775032586830415033772993541541820163005491285279882940, 680899077364553221002722115625274809744677788062477442312086, 355349436487753936000721704075588637048102593449252106813298, 5254361838244723184679801326407268664182654715017847086461, 480145671282471097574354032682584083826945502763658946101104, 249136810947175342894562520096603076879372702701088690594445, 175216547555975039599856545426098941943382367602172941744494, 436310864447848960706296122266108102033486860525693191197797, 342620466614509535208918527767209905005823047382938223113086, 369848992268737575958936185907214270590887322936419642815242, 278575045025661827978388874494219837629182438978526195181637, 1189171180780533071473125545247289861677955100195126109964590, 256190182678715266654387215899616014762531664768736561586327, 719160215933023695898776016718481385742508618676368640641809, 147033122794177086112261858085593706727904275426698884436011, 247466503394960387825735598976068779045757078494832316444804, 787155643450160361724955357286670519256662665704845721250609, 112101120505278148126370035869523081506090979629681063614381, 890009544685851814191758439205974159586245412054287515881584, 1168625756997945588141764967298286550498540363325170551587334, 946031342434770434479581499217378781992921204179509449159996, 759124753621557368233069144948668001126536400499520990700641, 930584421635842804698880452391670787414151645249729141739148, 140981825203074314092967178062754008486703246602401550271041, 880126454149733441805446179826584472107299085899567279467558, 510129631452465708304688340114214360026947205003705062663759, 857274757020001316639221394675820731579775247610619594760511, 444486969413575687285961819261097401974268741167841964919716, 645830958128126799221416466698967430939726760487764050203821, 128864469762235652994228226148325614187747349331618451490354, 732913002124581119538173953534485652651112140400076340646452, 1245672039639609341331477592944058028011275464117654972595670, 1160765030758624190775369713232721901616189349905945190302338, 745734132091942990384796294800038299023052878196943617322617, 34973161572808799782240527358912894045293050940490682156733, 507586651070816931641904112686082840821460472219390068396982, 359195216122538975934588740641220005777478961423841727365432, 60506687352654743312206686911057762445232526009857863834444, 402036521271253699065227780662896890228371046068283711170220, 465427226677337673103293964961886503610313835775181975449721, 925246962888172144515172444374190859841851825972285013006527, 542176614893876361668218387162168517498644799220587472896002, 852215132196560596695876248813488364201491362280912035912061, 945548964927065532651141821562204387565145712002346337639711, 736943822066388892909878515650831955490636214039062998720510, 766357526983761241394182000478355475617711906398422036954152, 77156525593382594092608158744099524034892127423492520631820, 562562817542804973601572838378263130638457829485887327130286, 768093992370198202822524520006977816845162154854939167515517, 1099957424762490943973557935337350760135180754563993547358098, 698816668614997174913438496891169625976027534942525487303513, 417641699919584202170293946436276552973997395211792288687960, 1006229610175567855209117721408416419896921240126676949824724, 4206431689326446028142220658552064336105749936096602165359, 893846509909828693967573302731018066461118006150050253703744, 878425189026235350891203121924637130803808920422558040493294, 730047416245095988472212050949689633327186823542036387345181, 648095719945750715387983948406690533087473721929975873848169, 213513454359755001454814601053555627585345770061082141021326, 350001050012957205656929492039628823072469208940960439158263, 1016858635000037892730835311903706149371704230428070443107320, 1040987439471207869975679257301693610464700899302787643642354, 1194690615352550474729309715449838057220521596135246725909553, 508165053077110820797186371383859674371399129952105597675096, 266494438294281492504556232035584920066331725618646155019547, 28469482072427012244441092412738741355431846649166066368980, 790175775999108776289865518368056397969387298334297622465909, 590581138260907253939363764832940322585129285968275409510634, 221909012579985462013325803334419731308959816500415305934495, 1063780559219791515938747204569742799329237935871594345400252, 977747525495509380693721486866821791065499754056415279744653, 346306061371595730004513789139807509540063462412619321003626, 456103179467597859705969406860196938169100856240100927540401, 969300078509189631808517876996065933181606409375207150288464, 1029806631220370012120597683927351131622576733031694535189521, 344896431603140401163996810922500893279239069499717183710501, 430000423804197030568046280589772094106128395099434235915031, 700179843567016021775399107572964843751703290591400960796112, 961227906080189143689698720420426659986080298413605666115640, 607209606799750473714271393200060455739097869884727178692312, 106958847163040842225140399905505511449479709017540851084532, 953369942103273809257762268859167463617831445026988544378658, 428269440686506672744282327102546440435442014650795927162711, 56621803434665963032193024056111306570802155743250152849716, 800707635631355839166448276143596444307614901816577459076131, 1032256515703247765067950588859299047987257001987777631061065, 813725055801254665600156259482200403981770576173968929131487, 940024839745068011043019236327963504645352520797347949823455, 1065005324140908547287467504568283884363143527586278243210801, 1087828777506290663525994551834233065465427418753806182842291, 668387132001968449612224853010931354244797738682007519611989, 563185246196177998134932666270526715161378776103340983046580, 148292872313931508344196679476720973752571125303712466045656, 413889563851226543249984374872220761253120628252088546262699, 853542105910386365929770611480736086723126396438880650918917, 59730458840715910492468261806200793684923819793480597554146, 792260492800286127199649276659137441324248689470594987965190, 753608630500639136668081531883097047491651258191552267413126, 33514911499472634865669915075769163328171019557849259474018, 634963859228206842307837566519244534650818456901841184879977, 219354096455968590219445072777282329948785844491217770978344, 1123377226439583158729762969668999276741275445803396272436031, 357765295513680388973981712560200525235334734759663454993805, 385868499980630535766019957877752149506518574529845752144666, 138578212294299392480319417966870656714476525885983752756188, 1110526796192425688386237355263892073046060477008920073455044, 244699783645221387947312903861559688207612147588246639081699, 583209905862562678600202085212425597809036630416117298854978, 1207854793808762194414317661151529169444903662139065050090746, 1127506983223466275821900811940356395242309493951089427884032, 526185119576631048584313761548704536031634598332129570964689, 266882032196696984660521486449809902101615921156569537960109, 1188118705564450461919200724390473040524626320052324478509883, 682831747455078454647149830819696088960233603851250102828667, 669419928942561433130809268138650695825596612075801278942980, 1077750630919867687880983437504767304166615787212813240073843, 486023540111308483450127320955599047045479654684477043315645, 409429366346146233850088863324915025465847596238000661872172, 779883595226131237594759409249289551033410304517183865388408, 1155872225708857920911178110668279174877878422508206228579940, 411063490066038942009369947241345843238439795078686488373864, 1243453053541946030699872676712518536022061850799945414120045, 871711034820169700581685353768658469631429266493677466057997, 601920686459160120670719526703980120744719013393032353678765, 329932100141177850249406090412821976994089707958551194468769, 558327299751202100333335353826111016492585371503632197870640, 113444032302978611299580451314055133491399096282744687816086, 152525914892717139057165748051966776217223953242540511499945, 965404850400527912039904270871065001313018148780552532312669, 313557099445185696402013375071955475516203519824979749629786, 952254159335810337756614972813240144837526566801182319987154]flag=&#x27;&#x27;for c in clist:\tif gp.jacobi(c,n)==1:\t\tflag+=&#x27;0&#x27;\tif  gp.jacobi(c,n)==-1:\t\t\tflag+=&#x27;1&#x27;\t\tprint(&#x27;flag二进制:&#x27;,flag)#二进制转化成十进制f=int(flag,2)print(&#x27;flag十进制:&#x27;,f)print(n2s(f))\n\n\n\n\n\n运行结果：\n\n顺利得到flag：\nSYC{run_to_the_light}\n","tags":["面试小结"]},{"title":"Hgame-2023-note","url":"/2023/01/17/Hgame-2023-note/","content":"WEEK1RSATASK：\nfrom Crypto.Util.number import *flag = open(&#x27;flag.txt&#x27;, &#x27;rb&#x27;).read()p = getPrime(512)q = getPrime(512)n=p*qe = 65537m = bytes_to_long(flag)c = pow(m, e, n)print(f&quot;c=&#123;c&#125;&quot;)print(f&quot;n=&#123;n&#125;&quot;)&quot;&quot;&quot;c=110674792674017748243232351185896019660434718342001686906527789876264976328686134101972125493938434992787002915562500475480693297360867681000092725583284616353543422388489208114545007138606543678040798651836027433383282177081034151589935024292017207209056829250152219183518400364871109559825679273502274955582n=135127138348299757374196447062640858416920350098320099993115949719051354213545596643216739555453946196078110834726375475981791223069451364024181952818056802089567064926510294124594174478123216516600368334763849206942942824711531334239106807454086389211139153023662266125937481669520771879355089997671125020789&quot;&quot;&quot;\n\n\n\nWP：\n直接分解N，求解\n#HGAME-RSAfrom Crypto.Util.number import *import gmpy2  n=135127138348299757374196447062640858416920350098320099993115949719051354213545596643216739555453946196078110834726375475981791223069451364024181952818056802089567064926510294124594174478123216516600368334763849206942942824711531334239106807454086389211139153023662266125937481669520771879355089997671125020789e=65537c=110674792674017748243232351185896019660434718342001686906527789876264976328686134101972125493938434992787002915562500475480693297360867681000092725583284616353543422388489208114545007138606543678040798651836027433383282177081034151589935024292017207209056829250152219183518400364871109559825679273502274955582p=11239134987804993586763559028187245057652550219515201768644770733869088185320740938450178816138394844329723311433549899499795775655921261664087997097294813q=12022912661420941592569751731802639375088427463430162252113082619617837010913002515450223656942836378041122163833359097910935638423464006252814266959128953phi=(p-1)*(q-1)d=gmpy2.invert(e,phi)m=pow(c,d,n)print(m)print(long_to_bytes(m))\n\nflag:  hgame{factordb.com_is_strong!}\nMORSE+Task:\n学校突然放假了，tr0uble正在开开心心的收拾东西准备回家，但是手机铃声突然响起，tr0uble接起电话，但是只听到滴答滴答的声音。努力学习密码学的tr0uble一听就知道这是什么，于是马上记录下来并花了亿点时间成功破译了，但是怎么看这都不像是人能看懂的，还没等tr0uble反应过来，又一通电话打来，依然是滴答滴答的声音。tr0uble想到兔兔也在学习密码学，于是不负责任地把密文都交给了兔兔，兔兔收到密文后随便看了一眼就不屑地说”这么简单都不会？自己解去，别耽误我抢车票”。 \nEncrypted_message:\n5Yeg5Liq5pif5pyf5YmN77yM5oiR5Lus5pS25Yiw5LiA5Liq56We56eY55qE5raI5oGv44CC5L2G5piv6L+Z5Liq5raI5oGv6KKr6YeN6YeN5Yqg5a+G77yM5oiR5Lus5LiN55+l6YGT5a6D55qE55yf5q2j5ZCr5LmJ5piv5LuA5LmI44CC5ZSv5LiA55+l6YGT55qE5L+h5oGv5piv5YWz5LqO5a+G6ZKl55qE77ya4oCc5Y+q5pyJ5YCS552A57+76L+H5Y2B5YWr5bGC55qE56+x56yG5omN6IO95oq16L6+5YyX5qyn56We6K+d55qE57uI54K54oCd44CC\nbase64解密后得到：\n几个星期前，我们收到一个神秘的消息。但是这个消息被重重加密，我们不知道它的真正含义是什么。唯一知道的信息是关于密钥的：“只有倒着翻过十八层的篱笆才能抵达北欧神话的终点”。\n使用Audacity解析Morse得到加密信息：\n0223e_priibly__honwa_jmgh_fgkcqaoqtmfr\n逆序：\nrfmtqoaqckgf_hgmj_awnoh__ylbiirp_e3220\nW型栅栏密码：\ndef generate_w(string, n):     &#x27;&#x27;&#x27;将字符排列成w型&#x27;&#x27;&#x27;    array = [[&#x27;.&#x27;]*len(string) for i in range(n)] #生成初始矩阵    row =0    upflag = False    for col in range(len(string)): #在矩阵上按w型画出string        array[row][col] = string[col]        if row == n-1:            upflag = True        if row == 0:            upflag = False        if upflag:            row -= 1        else:            row += 1    return arraydef decode(string, n):    &#x27;&#x27;&#x27;解密&#x27;&#x27;&#x27;    array = generate_w(string, n)    sub = 0    for row in range(n): #将w型字符按行的顺序依次替换为string        for col in range(len(string)):            if array[row][col] != &#x27;.&#x27;:                array[row][col] = string[sub]                sub += 1    msg = []    for col in range(len(string)): #以列的顺序依次连接各字符        for row in range(n):            if array[row][col] != &#x27;.&#x27;:                msg.append(array[row][col])    return array, msgdef crack_cipher(string):    for n in range(2,len(string)):        print(str(n)+&#x27;栏:&#x27;+&#x27;&#x27;.join(decode(string,n)[1]))if __name__ == &quot;__main__&quot;:    string = &quot;rfmtqoaqckgf_hgmj_awnoh__ylbiirp_e3220&quot;    crack_cipher(string)#18栏: rmocfhm_wo_ybipe2023_ril_hnajg_katfqqg\n\n最后维吉尼亚密码解密：\nKey: vidar\nflag:hgame{welcome_to_hgame2023_and_enjoy_hacking}\nStream CipherTask:\n很喜欢李小龙先生的一句话”Be water my friend”，但是这条小溪的水好像太多了。\nfrom flag import flagassert type(flag) == byteskey = [int.from_bytes(b&quot;Be water&quot;, &#x27;big&#x27;), int.from_bytes(b&quot;my friend&quot;, &#x27;big&#x27;)]def stream(i):    if i==0:        return key[0]    elif i==1:        return key[1]    else:        return (stream(i-2)*7 + stream(i-1)*4)enc = b&quot;&quot;for i in range(len(flag)):    water = stream((i//2)**6) % 256    enc += bytes([water ^ flag[i]])print(enc)# b&#x27;\\x1a\\x15\\x05\\t\\x17\\tu&quot;-\\x06lm\\x01-\\xc7\\xcc2\\x1eXA\\x1c\\x15\\xb7\\xdb\\x06\\x13\\xaf\\xa1-\\x0b\\xd4\\x91-\\x06\\x8b\\xd4-\\x1e\\xab\\xaa\\x15-\\xf0\\xed\\x1f\\x17\\x1bY&#x27;\n\n\n\n\n\n\n\nwp:\n参考官方wp: 这道题给了⼤家⼀个跑不出来的程序，需要优化程序得到flag。优化⽅法还挺多的，预期是⽤矩阵快速幂的⽅法。\n回到本题，根据递归函数可以得到stream的递推式 S[ i ] &#x3D; 4 ∗ S [ i − 1] + 7 ∗ S [ i − 2]\n类似于斐波那契数列，只不过增加了系数。 考虑⽤斐波那契矩阵和矩阵快速幂优化\nenc = b&#x27;\\x1a\\x15\\x05\\t\\x17\\t\\xf5\\xa2-\\x06\\xec\\xed\\x01-\\xc7\\xcc2\\x1eXA\\x1c\\x157[\\x06\\x13/!-\\x0b\\xd4\\x91-\\x06\\x8b\\xd4-\\x1e+*\\x15-pm\\x1f\\x17\\x1bY&#x27;def mul(a, b):   c = [[0, 0], [0, 0]]   for i in range(2):      for j in range(2):         for k in range(2):            c[i][j] += (a[i][k] * b[k][j]) % 256            c[i][j] %= 256   return c def power(n):   if n==1: return key[1] % 256   if n==0: return key[0] % 256   res = [[1, 0], [0, 1]]   A = [[4, 7], [1, 0]]   while n:      if n &amp; 1: res = mul(A, res)      A = mul(A, A)      n &gt;&gt;= 1   return (res[1][0] * key[1] + res[1][1] * key[0]) % 256flag = b&#x27;&#x27;for i in range(0, len(enc)):   water = power((i//2)**6)   flag += bytes([water ^ enc[i]])print(flag)\n\n\n\nfrom flag import flag        #flag未知assert type(flag) == bytes   #assert要求表达式的布尔值必须为真，说明flag的数据形式为byteskey = [int.from_bytes(b&quot;Be water&quot;, &#x27;big&#x27;), int.from_bytes(b&quot;my friend&quot;, &#x27;big&#x27;)]#key=[4784265876259235186,2019423192753765707364]def stream(i):    if i==0:        return key[0]   #key[0]=4784265876259235186    elif i==1:        return key[1]   #key[1]=2019423192753765707364    else:        return (stream(i-2)*7 + stream(i-1)*4)enc = b&quot;&quot;for i in range(len(flag)):       water = stream((i//2)**6) % 256     #地板除向下取整 114 110    enc += bytes([water ^ flag[i]])print(enc)# b&#x27;\\x1a\\x15\\x05\\t\\x17\\tu&quot;-\\x06lm\\x01-\\xc7\\xcc2\\x1eXA\\x1c\\x15\\xb7\\xdb\\x06\\x13\\xaf\\xa1-\\x0b\\xd4\\x91-\\x06\\x8b\\xd4-\\x1e\\xab\\xaa\\x15-\\xf0\\xed\\x1f\\x17\\x1bY&#x27; \n\n\n\n\n\n\n\n\n\n","tags":["CTF小试"]},{"title":"Hello World","url":"/2022/12/16/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"Python-study","url":"/2023/02/24/Python-study/","content":"Python学习笔记(Python教程 - 廖雪峰的官方网站 (liaoxuefeng.com) )By：jrl\n一、Python基础1.多行注释：\n2.变量：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.除法：\n4.Unicode与Utf-8：\nUnicode虽然范围广，可以编码汉字，但是占存储空间大，所以转为Utf-8储存。\n\n5.字符编码：由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。\n\n\n文件开头一般写入的注释：\n#!/usr/bin/env python3# -*- coding: utf-8 -*-\n\n\n\n\n6.格式化字符串的方法：1）使用占位符\n&#x27;Age: %s. Gender: %s&#x27; % (25, True)&#x27;growth rate: %d %%&#x27; % 7   # %%转义字符 表示一个%\n\n\n\n\n\n\n\n2）foramt()\n3）f-strng\n\n7.list与tuple(1)listPython内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。\n#egclassmates = [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]len(classmates)  #获得list元素的个数classmates[0]   #用索引来访问list中每一个位置的元素classmates[-1]  #访问最后一个元素的位置classmates.append(&#x27;Adam&#x27;)  # append() 可以往list中追加元素到末尾classmates.insert(1, &#x27;Jack&#x27;)  #也可以把元素插入到指定的位置classmates.pop()  # pop(i) 删除list末尾的元素\n\n\n\n(2)tuple另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改\nclassmates = (&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;)t = () #或者()  定义空tuplet=(1,) #定义只有一个元素的tuple\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n8.条件判断elif(else if)\nage = 20if age &gt;= 6:    print(&#x27;teenager&#x27;)elif age &gt;= 18:    print(&#x27;adult&#x27;)else:    print(&#x27;kid&#x27;)\n\n\n\ninput()的返回类型是str,str不能直接与整数比较，须转化\ns = input(&#x27;birth: &#x27;)birth = int(s)if birth &lt; 2000:    print(&#x27;00前&#x27;)else:    print(&#x27;00后&#x27;)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.循环(1)for  in  循环#历遍list或者tulpe中的元素names = [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]for name in names:    print(name)        #求和    sum = 0for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:    sum = sum + xprint(sum)\n\n\n\n当须历遍的范围过大时，可使用range()函数\nlist(range(5))    #[0, 1, 2, 3, 4]  0-4sum = 0for x in range(101):    sum = sum + xprint(sum)\n\n\n\n\n\n(2)while循环只要条件满足，就不断循环，条件不满足时退出循环\nsum = 0n = 99while n &gt; 0:    sum = sum + n    n = n - 2print(sum)\n\n\n\n\n\nbreak\n在循环中，break语句可以提前退出循环\nn = 1while n &lt;= 100:    if n &gt; 10: # 当n = 11时，条件满足，执行break语句        break # break语句会结束当前循环    print(n)    n = n + 1print(&#x27;END&#x27;)\n\n\n\n\n\ncontinue\n在循环过程中，也可以通过continue语句，跳过当前的这次循环，直接开始下一次循环。\nn = 0while n &lt; 10:    n = n + 1    if n % 2 == 0: # 如果n是偶数，执行continue语句        continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行    print(n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n10.dict和set(1)dictPython内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。\n先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢，给定一个名字，比如&#39;Michael&#39;，dict在内部就可以直接计算出Michael对应的存放成绩的“页码”，也就是95这个数字存放的内存地址，直接取出来，所以速度非常快。\n#初始化d = &#123;&#x27;Michael&#x27;: 95, &#x27;Bob&#x27;: 75, &#x27;Tracy&#x27;: 85&#125;d[&#x27;Adam&#x27;] = 67#查找d[&#x27;Michael&#x27;]#删除#要删除一个key，用pop(key)方法，对应的value也会从dict中删除： d.pop(&#x27;Bob&#x27;)\n\n\n\n由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉，如果key不存在，dict就会报错要避免key不存在的错误，有两种办法\n一是通过in判断key是否存在：\n&#x27;Thomas&#x27; in d\n\n二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value：\nd.get(&#x27;Thomas&#x27;)d.get(&#x27;Thomas&#x27;, -1)\n\n要删除一个key，用pop(key)方法，对应的value也会从dict中删除： d.pop(&#x27;Bob&#x27;)\n\n\n\n\n\ndict与list比较请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。\n和list比较，dict有以下几个特点：\n\n查找和插入的速度极快，不会随着key的增加而变慢；\n需要占用大量的内存，内存浪费多。\n\n而list相反：\n\n查找和插入的时间随着元素的增加而增加；\n占用空间小，浪费内存很少。\n\n所以，dict是用空间来换取时间的一种方法。\ndict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。\n这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。\n要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：\n(2)set set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。\n#要创建一个set，需要提供一个list作为输入集合：s = set([1, 2, 3])#注意，传入的参数[1, 2, 3]是一个list，而显示的&#123;1, 2, 3&#125;只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的     重复元素在set中自动被过滤：s = set([1, 1, 2, 2, 3, 3])                #  &gt;&gt; s    &#123;1, 2, 3&#125;#通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果：s.add(4)#通过remove(key)方法可以删除元素：s.remove(4)#set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：&gt;&gt;&gt; s1 = set([1, 2, 3])&gt;&gt;&gt; s2 = set([2, 3, 4])&gt;&gt;&gt; s1 &amp; s2&#123;2, 3&#125;&gt;&gt;&gt; s1 | s2&#123;1, 2, 3, 4&#125;\n\n\n\n\n\nset与dict比较set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。\n不可变对象str是不变对象，而list是可变对象\n#对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：a = [&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]#对于不可变对象，比如str，对str进行操作呢：&gt;&gt;&gt; a = &#x27;abc&#x27;&gt;&gt;&gt; a.replace(&#x27;a&#x27;, &#x27;A&#x27;)&#x27;Abc&#x27;&gt;&gt;&gt; a&#x27;abc&#x27;#replace并不是真的改变了变量a所指向的字符串&quot;abc&quot;，而是创建了一个新的变量b，指向&quot;Abc&quot;\n\n\n二、函数1.调用函数可以通过官网来调查函数： http://docs.python.org/3/library/functions.html#abs \n也可以在交互式命令行通过help(),查看函数的帮助信息。\n#eg: 数据类型转换&gt;&gt;&gt; int(&#x27;123&#x27;)123&gt;&gt;&gt; int(12.34)12&gt;&gt;&gt; float(&#x27;12.34&#x27;)12.34&gt;&gt;&gt; str(1.23)&#x27;1.23&#x27;&gt;&gt;&gt; str(100)&#x27;100&#x27;&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool(&#x27;&#x27;)False\n\n函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：\n&gt;&gt;&gt; a = abs # 变量a指向abs函数&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.定义函数在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。\n我们以自定义一个求绝对值的my_abs函数为例：\ndef my_abs(x):    if x &gt;= 0:        return x    else:        return -x         &#x27;&#x27;&#x27; 请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。return None可以简写为return。 &#x27;&#x27;&#x27;# 如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目录下启动Python解释器，用from abstest import my_abs来导入my_abs()函数，注意abstest是文件名（不含.py扩展名）：\n\n\n\n交互式环境\n\n(1)空函数如果想定义一个什么事也不做的空函数，可以用pass语句：\ndef nop():    pass# pass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。# pass还可以用在其他语句里，比如：if age &gt;= 18:    pass\n\n\n\n\n\n(2)参数检查调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError：\n&gt;&gt;&gt; my_abs(1, 2)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: my_abs() takes 1 positional argument but 2 were given\n\n\n\n但是如果参数类型不对，Python解释器就无法帮我们检查。试试my_abs和内置函数abs的差别：\n&gt;&gt;&gt; my_abs(&#x27;A&#x27;)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;  File &quot;&lt;stdin&gt;&quot;, line 2, in my_absTypeError: unorderable types: str() &gt;= int()&gt;&gt;&gt; abs(&#x27;A&#x27;)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: bad operand type for abs(): &#x27;str&#x27;\n\n\n\n当传入了不恰当的参数时，内置函数abs会检查出参数错误，而我们定义的my_abs没有参数检查，会导致if语句出错，出错信息和abs不一样。所以，这个函数定义不够完善。\n让我们修改一下my_abs的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数isinstance()实现：\ndef my_abs(x):    if not isinstance(x, (int, float)):        raise TypeError(&#x27;bad operand type&#x27;)    if x &gt;= 0:        return x    else:        return -x\n\n\n\n添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误：\n&gt;&gt;&gt; my_abs(&#x27;A&#x27;)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;  File &quot;&lt;stdin&gt;&quot;, line 3, in my_absTypeError: bad operand type\n\n\n\n\n\n\n\n\n\n\n\n(3)关于返回值Python中的返回值是唯一的\nEg： 在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标：\nimport mathdef move(x, y, step, angle=0):    nx = x + step * math.cos(angle)    ny = y - step * math.sin(angle)    return nx, ny\n\n然后，我们就可以同时获得返回值：\n&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print(x, y)151.96152422706632 70.0\n\n但其实这只是一种假象，Python函数返回的仍然是单一值：\n&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print(r)(151.96152422706632, 70.0)\n\n原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。\n3.函数的参数Python的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。\n(1)位置参数我们先写一个计算x2的函数\n对于power(x)函数，参数x就是一个位置参数\n修改后的power(x, n)函数有两个参数：x和n，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数x和n。\ndef power(x, n):    s = 1    while n &gt; 0:        n = n - 1        s = s * x    return s\n\n\n\n\n\n(2)默认参数新的power(x, n)函数定义没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用：\n&gt;&gt;&gt; power(5)Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: power() missing 1 required positional argument: &#x27;n&#x27;\n\n这个时候，默认参数就排上用场了。由于我们经常计算x2，所以，完全可以把第二个参数n的默认值设定为2：\ndef power(x, n=2):    s = 1    while n &gt; 0:        n = n - 1        s = s * x    return s\n\n而对于n &gt; 2的其他情况，就必须明确地传入n，比如power(5, 3)。\n从上面的例子可以看出，默认参数可以简化函数的调用。设置默认参数时，有几点要注意：\n一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；\n二是如何设置默认参数。\n当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。\n使用默认参数有什么好处？最大的好处是能降低调用函数的难度。\n举个例子，我们写个一年级小学生注册的函数，需要传入name和gender两个参数：\ndef enroll(name, gender):    print(&#x27;name:&#x27;, name)    print(&#x27;gender:&#x27;, gender)   #如果要继续传入年龄、城市等信息怎么办？这样会使得调用函数的复杂度大大增加。我们可以把年龄和城市设为默认参数，这样，大多数学生注册时不需要提供年龄和城市，只提供必须的两个参数：def enroll(name, gender, age=6, city=&#x27;Beijing&#x27;):    print(&#x27;name:&#x27;, name)    print(&#x27;gender:&#x27;, gender)    print(&#x27;age:&#x27;, age)    print(&#x27;city:&#x27;, city)       #只有与默认参数不符的学生才需要提供额外的信息：enroll(&#x27;Bob&#x27;, &#x27;M&#x27;, 7)enroll(&#x27;Adam&#x27;, &#x27;M&#x27;, city=&#x27;Tianjin&#x27;)#也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用enroll(&#x27;Adam&#x27;, &#x27;M&#x27;, city=&#x27;Tianjin&#x27;)，意思是，city参数用传进去的值，其他默认参数继续使用默认值。\n\n\n\n默认函数最大的坑：\n#先定义一个函数，传入一个list，添加一个END再返回：def add_end(L=[]):    L.append(&#x27;END&#x27;)    return L#当你正常调用时，结果似乎不错：&gt;&gt;&gt; add_end([1, 2, 3])[1, 2, 3, &#x27;END&#x27;]&gt;&gt;&gt; add_end([&#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;])[&#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;END&#x27;]#当你使用默认参数调用时，一开始结果也是对的：&gt;&gt;&gt; add_end()[&#x27;END&#x27;]#但是，再次调用add_end()时，结果就不对了：&gt;&gt;&gt; add_end()[&#x27;END&#x27;, &#x27;END&#x27;]&gt;&gt;&gt; add_end()[&#x27;END&#x27;, &#x27;END&#x27;, &#x27;END&#x27;]\n\n这是因为：\nPython函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。\n 定义默认参数要牢记一点：默认参数必须指向不变对象！\n#要修改上面的例子，我们可以用None这个不变对象来实现：def add_end(L=None):    if L is None:        L = []    L.append(&#x27;END&#x27;)    return L#为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。\n\n\n\n\n\n\n\n\n\n(3)可变参数在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。\n我们以数学题为例子，给定一组数字a，b，c……，请计算a2 + b2 + c2 + ……。\n要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下：\ndef calc(numbers):    sum = 0    for n in numbers:        sum = sum + n * n    return sum#但是调用的时候，需要先组装出一个list或tuple：&gt;&gt;&gt; calc([1, 2, 3])14&gt;&gt;&gt; calc((1, 3, 5, 7))84\n\n\n\n我们把函数的参数改为可变参数：\nPython允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去：\n*nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。\n#调用该函数时，可以传入任意个参数，包括0个参数：&gt;&gt;&gt; calc(1, 2)5&gt;&gt;&gt; calc()0def calc(*numbers):    sum = 0    for n in numbers:        sum = sum + n * n    return sum\n\n\n\n\n\n\n\n\n\n(4)关键字参数","tags":["Python"]},{"title":"C-Study-1","url":"/2023/02/20/C-Study-1/","content":"C-STUDY-1一、指针（(14条消息) C语言指针详解(经典,非常详细)_liu100m的博客-CSDN博客_c语言指针用法详解）1.指针类型的意义指针类型决定了：指针解引用的权限有多大，以及“+1”时走的步长(int,4字节  char，1字节，因为只跳过一个字符)\n#include&lt;stdio.h&gt;int main()&#123;    int arr[10]=&#123;0&#125;;    int*p=arr;    for(int i=0;i&lt;10;i++)               //整形数据占4字节，若换成 char*p则无法将arr中的元素全赋值为0    &#123;        *(p+i)=0;    &#125;    for(int i=0;i&lt;10;i++)    &#123;        printf(&quot;%d\\n&quot;,arr[i]);    &#125;    return 0;&#125;\n\n记得将指针初始化，若不知道则赋值为空指针\nint*p&#x3D;NULL;   &#x2F;&#x2F;此时仍然无法赋值，因为NULL不属于个人\n2.指针的运算指针-指针  得到的是两个指针间元素的个数  (前提是指针类型相同且指向同一空间)\n指针+指针   无意义\n#include&lt;stdio.h&gt;int main()&#123;    int arr[10]=&#123;1,2,3,4,5,6,7,8,9,10&#125;;    printf(&quot;%d\\n&quot;,&amp;arr[9]-&amp;arr[0]);    return 0;&#125;\n\n\n\n\n\n\n\n3.指针与数组数组名是数组首元素的首地址\n#include&lt;stdio.h&gt;int main()&#123;  int arr[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;;  printf(&quot;%p&quot;,arr);   //等价于  printf(&quot;%p&quot;,&amp;arr[0]);  return 0;&#125;\n\n\n\n\n\n\n\n4.二级指针#include&lt;stdio.h&gt;int main()&#123;    int a=7;    int*p=&amp;a;      //p是指针变量，一级指针    int**pa=&amp;p;   //pa也是指针变量，二级指针   &amp;pa取出pa在内存中的起始地址    return 0；&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n二、文件((14条消息) C语言文件操作（含详细步骤）_zjruiiiiii的博客-CSDN博客_c语言文件操作)\n三、链表((14条消息) C语言链表超详解_rivencode的博客-CSDN博客)\n？\n","tags":["C-study"]},{"title":"Summary","url":"/2023/06/18/Summary/","content":"一 、RSA1.1 What is RSA1.1.1 Define RSA： 1977年，麻省理工学院的 Ron Rivest、Adi Shamir 和 Leonard Adleman 共同提出了一种非对称加密\n算法，用他们三人的姓氏缩写命名为 RSA。RSA 既不是惟一，也不是最早的非对称加密算法。但它是使\n用最广泛，因而也是最重要的非对称加密算法。\n1.1.2 Basic principle：eg：假设Alice和Bob要在网上进行加密通信，他们要怎么应用RSA来加密和解密信息呢？步骤如下：\n1.随机选择两个不相同的素数 p , q。\n2.将p , q 相乘，记为n &#x3D; p × q 。\n3.计算n的欧拉函数φ( n )，欧拉函数证明，当 p , q 为不相同的素数时，φ(n)&#x3D;(p−1)(q−1) 。\n4.随机选择一个整数 e ，满足两个条件：φ(n)与e互质,且1&lt;e&lt;φ(n) 。\n5.计算e对于φ(n) 的模反元素d，也就是说找到一个d满足 ed &#x3D; 1 mod φ(n)。这个式子等价于\ned−1&#x3D;kφ(n)，实际上就是对于方程ed−kφ(n)&#x3D;1求(d,k)的整数解。这个方程可以用扩展欧几里得算法求\n解。\n6.最终把(e,n)封装成公钥,(d,n)封装成私钥。\n公钥与私钥的产生 ：\n1.随机选择两个不同大质数 p 和 q，计算 N&#x3D;p×q\n2.根据欧拉函数，求得 φ(N)&#x3D;φ(p)φ(q)&#x3D;(p−1)(q−1)\n3.选择一个小于 φ(N)φ(N) 的整数 e，使 e 和 φ(N)互质。并求得 e 关于 φ(N) 的模反元素，命名为 d，有\ned≡1(mod φ(N))\n4.将 p 和 q 的记录销毁，此时，(N,e))是公钥，(N,d) 是私钥。\n消息加密：\n首先需要将消息 以一个双方约定好的格式转化为一个小于 N，且与 N 互质的整数 m。如果消息太长，\n可以将消息分为几段，这也就是我们所说的块加密，后对于每一部分利用如下公式加密：\nm^e≡c (mod N)\n消息解密：\n利用密钥d进行解密。\nc^d≡m (modN)\n正确性证明:\n即我们要证m^ed≡m mod N，已知ed≡1 mod ϕ(N)，那么 ed&#x3D;kϕ(N)+1，即需要证明\nm^kϕ(N)+1≡m mod N\n这里我们分两种情况证明\n第一种情况 gcd(m,N)&#x3D;1，那么 m^ϕ(N)≡1 mod N，因此原式成立。\n第二种情况 gcd(m,N)≠1，那么 m 必然是 p 或者 q的倍数，并且 n&#x3D;mn&#x3D;m 小于 N。我们假设\nm&#x3D;xp\n那么x必然小于 q，又由于q是素数。那么\nm^{kϕ(N)+1}&#x3D;m+uqm&#x3D;m+uqxp&#x3D;m+uxN\n所以原式成立。\n1.1.3 Summariz：欧拉函数与小费马定理\n(https://blog.csdn.net/weixin_30302609/article/details/96312617?ops_request_misc=%7B%22request%5Fid%22%3A%22166827222816782391833081%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=166827222816782391833081&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-96312617-null-null.142\nhttp://blog.csdn.net/boksic/article/details/6912381\n1.2 Tools and third-party libaries1.2.1 RSA-tool :使用rsatool工具计算d的值，直接填入p,q,把e &#x3D; 65537转换为16进制在再填入，再点击Calc.D,即可获得\nD的值。在已知d的情况下，我们可以使用此工具将d分解为两个质数p,q，便于解出密文。但前提是已知\n的d不是一个非常大的整数，因为大整数很难被分解。\n1.2.2 Python :Python中的第三方库中有许多有用的函数，通过调用不同的函数，可以进行高效的数学运算，这对于\nRSA问题有极大的帮助，能大大提高破解的效率。\n如 gmpy2\ngmpy2.invert(x,m)求大整数x模m的逆元\nprint(gmpy2.invert(4, 23)) # eg:46 ≡ 1 mod 23 –&gt; 6**gmpy2.powmod(x,y,m)求大整数x的y次幂模m取余\n1.3 Eg analyze1.3.1 Easy RSA:from Geek Challenge 2022:\nn&#x3D;\n6998481475728885783197750918520850086672477175656162927968781930122248321872866\n3\ne&#x3D; 65537\nc&#x3D;\n6767284506351741544248617509644866461758157956488531184232610787180559569745470\n1\n思路分析：\n题目中给出了n,e,c\n通过观察发现n较小，可以尝试将其分解为p,q，再调用gmpy.2函数解出d,进而解出flag\n代码如下：\nprint(gmpy2.powmod(3, 3, 5)) # eg: 333 mod 5 –&gt; 2 \nprint(gmpy2.powmod(3, 2, 5)) # eg: 3*3 mod 5 –&gt; 4 \nimport gmpy2 \nimport binascii \ne &#x3D; 65537从而解出flag:\nb’SYC{5t4rt_R5A_ls_1t_3a5y?}’\n1.3.2 Crypto–RSA:from Crypto.Util.number import *import gmpy2 as gpflag = b&#x27;xxxxxxxxx&#x27;m=bytes_to_long(flag)p = getPrime(1024)q = getPrime(1024)n = p*q*qphi = q*(p-1)*(q-1)e = 0x10001d = gp.invert(e,phi)c1 = gp.powmod(m,e,n)c2 = gp.powmod(d,e,n)print(c1)print(c2)print(n)&#x27;&#x27;&#x27;14509379790282216731965263256391304920435944160691429937132813276173793784148298520477299169344655838268721129596612507243272811458526087788248191753718534890942856041592962539985956564079887975146491666585807765209871888037151776115227608751460887262303306387556335682644976813531560028668655343582938424513443366495975004969678298240376753135034068427887193962225383594250883659757016400948044532691983148400120793146984804396122299969130456660593233184448173499438760467678006235132399370083206401606340646709053994403659316278177783139867306487788815996588005473022366137802701321068676233903137034749449975584204315740369097122521500465517531264362750200962081675477858875972327525301089556747574239109066966798877771707160055371923883082199967563095816246054788154410985010523623215930953782040387272785539118194123321123587625079895916754686084365932640580302428247003702061562681653408452239029912633217914665483249427610379108377189670613441955119794879945650448935619329207591863347850074406758945501668606322978730084004775948741225498242596510429069890188734971463262832207338509259636158197186473231084030611277970142135506452566914392952406514161769385333654288558315100417373198672146898364766659160370806483032661626096448246797827676729581606342709969920561820508157704645093523526223435723687574259355146223059724195082108488756975882551413208621693276649009903367179575066266673604798237758134158822234458880819086205540111304355202712376749562740802613008613260404056634272076658688987063643965272417337144452612006574056543705738274650069505346656886598742666804826134021330227393996894520875426566412750432339683501873858961170671028054994435471915730331430660759838018535742232100958947763805959195826897767808212953005533895883805276594215123977864023845045386538171770379069368278128946732848722324244150864229348629158013373287002712425388307525352609100624748000272472736874666500547841318591852594619595724087209914853196867692948250150501764076446154470673884523284309784517787183054246280337398098853243684127104584733672924352341481572093454807255602936733377039997650201840331363344239719297203152251916861311582291699460040753803661345073084832894779090488743449087119526126541942853573076715474894397009565884537900866295889520532273851131982999253534600891259155672158005086674638844910604020655531132043490450001206903667855774008230185435154887685054704162605627162865608268235359819470906793478144795375880249991003056592569994537140155966341660560671914544355445680021310815797523132967939090744815795215539133448449248304650191105105400480778072455609675366453408226825706923640521370456175259373003734277093133962318272307543941384223016249143554311711183964923672359210163040661231350422086972190979806820525109574548334715135305259&#x27;&#x27;&#x27;\n\n\n\n\n\n\n\n分析：1.p与q都是随机的1024位的二进制数，这使得n会变得非常大，加之大正整数是很难分解的，所以这道\n题并不是通过分解n来求解的。\n2.e &#x3D; 0x10001 十六进制转换为十进制及e&#x3D;65537\n3.n &#x3D; pqq\nphi &#x3D; q*(p-1)*(q-1)\n观察发现n与phi有公因子q\n4.c1 &#x3D; gp.powmod(m,e,n) 即 m^e&#x3D;k1pq*q+c1 *\nc2 &#x3D; gp.powmod(d,e,n) 即**d^e&#x3D;k2pqq+c2\n解题思路：\n 1.题目给出了一组c1,c2,n的值，泄露了d的信息，即d^e mod n。同时我们发现phi与n有公因子\nq,n&#x3D;pqq,phi&#x3D;(p-1)(q-1)q。\n2.(d^e mod n )*(e^e mod n) mod n&#x3D; (de)^e mod n&#x3D;(kphi+1)^e mod n。\n3.那么我们现在的想法就是设法求出q,再将n分解为p,q，接着就可以通过逆元求解出d的值。\n4.这样我们就知道c即c1,n,d的值，进而解出m，破译密文。\n二、Hash2.1 What is Hash2.1.1 Hash and background: Hash,一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过\n散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空\n间通常远小于输入的空间。它其实就是一个算法，最简单的算法就是加减乘除，比方，我设计个数字算\n法，输入+7&#x3D;输出，比如我输入1，输出为8；输入2，输出为9。\n哈希算法不过是一个更为复杂的运算，它的输入可以是字符串，可以是数据，可以是任何文件，经过哈\n希运算后，变成一个固定长度的输出，该输出就是哈希值。但是哈希算法有一个很大的特点，就是你不\n能从结果推算出输入,所以又称为不可逆的算法。\n安全，这是Hash的最大优点！\n2.1.2 Hash’s advantages:1.不可逆：在具备编码功能的同时，哈希算法也作为一种加密算法存在。即，你无法通过分析哈希值计\n算出源文件的样子，换句话说：你不可能通过观察香肠的纹理推测出猪原来的样子。\n2.计算极快：20G高清电影和一个5K文本文件复杂度相同，计算量都极小，可以在0.1秒内得出结果。也\n就是说，不管猪有多肥，骨头多硬，做成香肠都只要眨眨眼的时间。\n2.1.3 Applied fields:哈希算法的不可逆特性使其在以下领域使用广泛\n1.密码，我们日常使用的各种电子密码本质上都是基于hash的，你不用担心支付宝的工作人员会把你的\n密码泄漏给第三方，因为你的登录密码是先经过 hash+各种复杂算法得出密文后 再存进支付宝的数据库\n里的2.文件完整性校验，通过对文件进行hash，得出一段hash值 ，这样文件内容以后被修改了，hash值就\n会变。 MD5 Hash算法的”数字指纹”特性，使它成为应用最广泛的一种文件完整性校验和(Checksum)算\n法，不少Unix系统有提供计算md5 checksum的命令。\n3.数字签名，数字签名技术是将摘要信息用发送者的私钥加密，与原文一起传送给接收者。接收者只有\n用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与解\n密的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息\n被修改过，因此数字签名能够验证信息的完整性。\n此外，hash算法在区块链领域也使用广泛。\n2.2 Eg analyze(MD5 in Hash)2.2.1 MD5MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过一些列的处理后，\n算法输出由四个32位分组组成的128位散列值。具体的步骤如下所示：\n1、填充\n如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得对512求余结果等于448。填充\n的方法是填充一个1和n个0。填充完成后，信息的长度为N*512+448\n2、记录信息长度\n用64位内存来存储填充前信息长度。这64位加在第一步结果的后面，这样信息长度就变为N512 + 448 +\n*64 &#x3D; (N+1)*512\n3、装入标准的幻数（四个整数）\n标准的幻数（物理顺序）是（A&#x3D;(01234567)16，B&#x3D;(89ABCDEF)16，C&#x3D;(FEDCBA98)16，D&#x3D;\n(76543210)16）。如果在程序中定义应该是（A&#x3D;0X67452301L，B&#x3D;0XEFCDAB89L，\nC&#x3D;0X98BADCFEL，D&#x3D;0X10325476L)。\n2.2.2 Crypto–md5:一个名为Hacker的人想给小彭加德育分，但是需要小彭的学号和寝室号才能完成加分。\nHacker自己只找到了学号和寝室号对应的md5值，聪明的你能帮助Hacker拿到学号和寝室号吗？\n学号：71c5a9bd7cc3a8e563efe4171f07b427\n寝室号：cb1592d95b7e3846451eab3728eeaa51\n分析：\nmd5是一种信息摘要算法，不可反向解密，不同长度的内容加密后都是32位。它是单向密码体制，从明\n文到密文的不可逆映射，只有加密过程没有解密过程，所以我们没法通过运算来解开密文得到明文。由\n于md5是一种散列函数，运用Hash算法，在计算过程中原文会随机丢失，仅仅根据MD5的计算过程和\n得到的最终结果，是无法逆向计算出明文的。\n1.题目中的MD5密文并未加入盐作为干扰，都是标准的32位密文，解密时并没有非常困难，可以通过考\n虑穷举法进行暴力求解。\n2.通过迭代组合形成若干明文组，再将明文组进行utf-8编码成密文，然后与题目中的密文进行比较，当\n两者一致时即“破译”成功，输出得到flag。\n脚本如下：\n1.引用hash\n给定范围\n运用for循环进行枚举\n2.学号的格式为：19XXXXXXXX\n我们发现已经给出部分明文，我们只需要解出剩下的8位明文即可，即设置8个变量\n#coding: utf-8 import hashlib dic = &#x27;0123456789&#x27; for i in range(1000):a,b,c,d,e,f,g\n\n\n\n\n\n3.接着组成密文组t \nt =&#x27;19&#x27;+str(a)+str(b)+str(c)+str(d)+str(e)+str(f)+str(g)+str(h)\n\n4.进行MD5算法，utf-8编码，所得密文与原密文比对，正确即输出，得到flag\nmd5 = hashlib.md5(t.encode(&#x27;utf-8&#x27;)).hexdigest() if md5[:32] == &#x27;71c5a9bd7cc3a8e563efe4171f07b427&#x27;: print (t)\n\n\n\n\n\n\n\n\n\n运行\n#coding: utf-8 import hashlib dic = &#x27;0123456789&#x27; for i in range(1000):     for a in dic:         for b in dic:             for c in dic:                 for d in dic:                     for e in dic:                        for f in dic:                            for g in dic:                                 for h in dic:                                     t =&#x27;19&#x27;+str(a)+str(b)+str(c)+str(d)+str(e)+str(f)+str(g)+str(h)                                     md5 = hashlib.md5(t.encode(&#x27;utf-8&#x27;)).hexdigest()                                     if md5[:32] == &#x27;71c5a9bd7cc3a8e563efe4171f07b427&#x27;:                                         print (t)                                        break\n\n求解完学号，寝室号的解密也是类似的：\n注意到寝室号格式为：XX-XXXX\n那么在组合时注意加入字符‘-’即可\n#coding: utf-8import hashlib from tqdm import tqdm for i in tqdm(range(1000)): pass dic = &#x27;0123456789&#x27; for i in range(1000):         for a in dic:           for b in dic:             for c in dic:               for d in dic:                 for e in dic:                   for f in dic:                                   t =str(a)+str(b)+&#x27;-&#x27;+str(c)+str(d)+str(e)+str(f)                                   md5 = hashlib.md5(t.encode(&#x27;utf-8&#x27;)).hexdigest() #print t if md5[:32] == &#x27;cb1592d95b7e3846451eab3728eeaa51&#x27;: print (t)\n\n\n\n\n\n综上，flag为\nSYC{1919114514,81-2048}\n三、ECC3.1 What is ECC  ECC与RSA一样都属于非对称加密算法，但是，与传统的基于大质数分解难题的加密算法不同，该加密方式基于 “离散对数” 这种数学难题。\n椭圆曲线加密（Elliptic Curve Cryptography），ECC加密算法是一种公钥加密技术，以椭圆曲线理论为基础。利用有限域上椭圆曲线的点构成的Abel群离散对数难解性，实现加密、解密和数字签名。将椭圆曲线中的加法运算与离散对数中的模乘运算相对应，就可以建立基于椭圆曲线的对应密码体制。\n这里我不了解什么是群，什么是圆锥曲线理论，所以去CSDN了一下。\n3.1.1 关于群：\n3.1.2 EIgamal：\n\n实例密钥生成选取素数p&#x3D;150001，本原元a&#x3D;7，密钥113\n\n\n\np&#x3D;150001a&#x3D;7d&#x3D;113ad%p66436Ly&#x3D;ad%pprint y66436\n\n\n\n由公式可得公钥为y&#x3D;66436\n 加密，明文为m&#x3D;809,随机整数为k&#x3D;1000\n\n\n\nm&#x3D;809k&#x3D;1000c1&#x3D;ak%pc190429Lc2&#x3D;m*yk%pc215061L\n\n\n\n得到密文为(c1,c2)&#x3D;(90429,15061)\n解密\n根据公式m1&#x3D;c2&#x2F;c1y%p，但其中有模逆运算，不能直接计算，可以用扩展欧几里得算法,先求c1y的模逆\n\n\n\nextended_gcd(c1**d%p,p)(-69199L, 2147L)\n\n\n\n我们所需要的是正数，所以加上p，-69199+p&#x3D;80802\n然后就可以\n\n\n\n80802*c2%p809L\n\n\n\n正是刚开始的明文809\n(https://blog.csdn.net/boksic/article/details/7014386)\n3.1.3 椭圆曲线(Elliptic curve):\n\n\n(3条消息) 椭圆曲线入门详解_boksic的博客-CSDN博客_怎么求解椭圆曲线的全部解点\n3.1.4 ECC and background:我们知道，RSA算法的优势就是算法原理简单，可以很容易的构造。但是缺点也很明显，需要足够长的密钥长度来保证数据的安全性。\n\n而现在移动终端的数目在逐渐增多，越来越多的运算是在移动终端上进行的，而移动终端的计算能力有限，超级计算机的计算能力在不断增强。按照摩尔定律，计算机处理器的性能，每两年就会翻一番。\n\n这就必然导致了一个矛盾：\n\n由此，ECC加密算法应运而生。引文链接：https://blog.csdn.net/xuanli4845/article/details/115907886\n3.2 ECC’s advantagesECC主要优势是可以使用更小的密钥并提供相当高等级的安全。ECC164位的密钥产生一个安全级，相当于RSA 1024位密钥提供的保密强度，而且计算量较小，处理速度更快，存储空间和传输带宽占用较少。目前我国居民二代身份证正在使用 256 位的椭圆曲线密码，虚拟货币比特币也选择ECC作为加密算法。对于ECC加密算法的优点，那就是性能上的提升，同样的密钥长度，基于ECC加密要比基于RSA安全很多。\n总结来说就是ECC算法能在短时间内达到RSA的加密效果，同时ECC的密钥更短，存储效率高，通信效率高。\n3.3 ECC’s principle3.3.1 Define ECC:在有限域Fp中定义一个椭圆曲线，常用y2&#x3D;x3+ax+b\nFp中只有p个元素，p为素数Fp中，a+b≡c (mod p)，a×b≡c (mod p)，a&#x2F;b≡c (mod p)4a^3+27b^2≠0　(mod p)  a，b是小于p的非负整数x，y属于0到p-1间的证书，曲线标记为Ep（a，b）阶：椭圆曲线上一点P，存在正整数n，使得nP&#x3D;O∞，则n为P的阶，若n不存在，则P是无限阶的，有限域上定义的椭圆曲线上所有点的阶都存在。\n椭圆曲线难题\nK&#x3D;kG，其中K,G为Ep（a,b）上的点，k为小于n的整数，n是点G的阶，给定k和G，计算K容易，但是给定K和G，求k就很难了！\n因此，设K为公钥，k为私钥，G为基点。\n加密过程A选定一条椭圆曲线Ep（a,b），并取曲线上一点作为基点GA选择一个私钥k，并生成公钥K&#x3D;kGA将Ep（a,b）和k，G发送给BB收到后将明文编码到Ep（a,b）上一点M，并产生一个随机数rB计算点C1&#x3D;M+rK，C2&#x3D;rGB将C1，C2传给AA计算C1-kC2&#x3D;M+rkG-krG&#x3D;MA对M解码得到明文攻击者只能得到Ep（a,b），G，K，C1，C2，没有k就无法得到M。\n签名验签流程A选定一条椭圆曲线Ep（a，b），并取曲线上一点作为基点GA选择一个私钥k，并生成公钥K&#x3D;kGA产生一个随机数r，计算R(x,y)&#x3D;rGA计算Hash&#x3D;SHA(M)，M‘&#x3D;M(modp)A计算S&#x3D;（Hash+M’k）&#x2F;r(modp)B获得S和M’，Ep(a,b)，K，R(x,y)B计算Hash&#x3D;SHA(M)，M’&#x3D;M(modp)B计算R’&#x3D;（Hash*G+M’K）&#x2F;S&#x3D;(HashG+M’*kG)*r&#x2F;(Hash+M’k)&#x3D;rG&#x3D;R（x,y），若R’&#x3D;R，则验签成功。https://blog.csdn.net/leo_wonty/article/details/7366418\n3.3.2 Eg:Eg1\n\n(3条消息) 椭圆曲线密码算术（ECC）原理_Soul fragments的博客-CSDN博客_ecc原理\n(3条消息) ECC椭圆曲线加解密原理详解(配图)_NFTDigger的博客-CSDN博客_椭圆曲线加密算法原理\nEg2\n\nECC椭圆曲线详解(有具体实例) - Kalafinaian - 博客园 (cnblogs.com)\n3.4 Crypto–ECC阿鲁为了保护自己的qq，使用椭圆曲线加密了自己的qq密码。嘉然觉得这样并不安全，于是决定拿到阿鲁的qq密码证明此事。发现阿鲁的QQ密码就是椭圆曲线的公钥坐标之和。现已知椭圆曲线各参数：\na &#x3D; 2546417962\nb &#x3D; 33279036350\np &#x3D; 190540091407103\n私钥: k &#x3D; 3068869\nG &#x3D; (25040232765915, 122045618759262)\n求公钥K(x, y)\nflag是SYC{}包上x+y的sha256值\nAnalyze:1.通过观察题目我们发现，已知椭圆曲线加密Ep(a,b)参数为\na &#x3D; 2546417962\nb &#x3D; 33279036350\np &#x3D; 190540091407103\n私钥: k &#x3D; 3068869\nG &#x3D; (25040232765915, 122045618759262)\n需要求解的是公钥K(x,y)的横坐标与纵坐标之和的sha256的值\n2.我们已知k与G，求解公钥K相对较简单。但是，如果知道G与K，反过来求解k就会变得很困难。阿鲁为了保护自己的qq，使用椭圆曲线加密了自己的qq密码，其QQ密码为公钥K(x,y)的横坐标与纵坐标之和，这么做显然是不够安全的，我们只需要解出公钥K就“破译”成功。\n\n\n\n根据椭圆曲线上的点的加法运算\n\n我们就计算能得到公钥K，拿到flag\nSolve process：1.写入已知数据\nGx = 25040232765915Gy = 122045618759262a = 2546417962b = 33279036350p = 190540091407103k = 3068869x = Gxy = Gy\n\n\n\n\n\n2.分根据P、Q两点是否重合，进行分类\nfor i in range(k-1):    #若P、Q两点重合    if (x==Gx and y==Gy):        inv = pow(2*Gy, p-2,p)           temp = (3*Gx*Gx+a)*inv%p         #若P、Q两点不重合    else:        inv = pow((x-Gx), p-2,p)        temp = (y-Gy)*inv%p\n\n\n\n\n\n3.再通过椭圆曲线上的加法运算算出公钥K\n xr = (temp*temp-Gx-x)%p    yr = (temp*(x-xr)-y)%p #print(i,xr,yr)    x = xr    y = yrprint(x+y)\n\n\n\n\n\n\n\n\n\n脚本如下：\n#输入已知数据Gx = 25040232765915Gy = 122045618759262a = 2546417962b = 33279036350p = 190540091407103k = 3068869x = Gxy = Gyfor i in range(k-1):    #分类计算K的值    #若P、Q两点重合    if (x==Gx and y==Gy):        inv = pow(2*Gy, p-2,p)   #费马小定理(1/2/Gy)%p=(2Gy)^p-2 %p        temp = (3*Gx*Gx+a)*inv%p         #若P、Q两点不重合    else:        inv = pow((x-Gx), p-2,p)        temp = (y-Gy)*inv%p    xr = (temp*temp-Gx-x)%p    yr = (temp*(x-xr)-y)%p #print(i,xr,yr)    x = xr    y = yrprint(x+y)\n\n\n\n\nQQ:196301645356440\n4.sha256\n#Hash.sha256import hashlibhash=hashlib.sha256();hash.update(bytes(&#x27;196301645356440&#x27;,encoding=&#x27;utf-8&#x27;))print(hash.hexdigest())\n\n得到sha256后的值：a6c50a41e9ff4678ff94a17e893f434952a32b2e70c78dfb726c4d78b4303471\n\n所以，flag为\nSYC{a6c50a41e9ff4678ff94a17e893f434952a32b2e70c78dfb726c4d78b4303471}\n四、Coppersmith&amp;Lattice-based Cryptography4.1 Define4.1.1 Coppersmith：Coppersmith定理攻击，也是针对n\nCoppersmith定理指出在一个e阶的mod n多项式f(x)中，如果有一个根小于n^1&#x2F;e，就可以运用一个O(log n)的算法求出这些根。\n这个定理可以应用于rsa算法。如果e &#x3D; 3并且在明文当中只有三分之二的比特是已知的，这种算法可以求出明文中所有的比特。\n\n4.1.2 Lattice-based Cryptography：Background：\n随着当下量子计算机的研制的迅速进展，量子算法亦是相应得以巨大突破。在量子计算模型下，经典数论假设的密码体系（如大整数分解，计算有限域&#x2F;椭圆曲线上的离散对数问题等），存在多项式时间（PPT）的量子算法，换而言之，经典数论密码体系受到了极大的冲击，将有可能成为旧时代的眼泪。因此，能够抵抗量子计算机攻击的密码——“后量子”或“抗量子”密码便应运而生。\n目前, 用于构建后量子密码系统的常见数学技巧包括：1.杂凑函数,多变量方程(在构造签名方案时较有优势)2.纠错码(更合适构造加密方案)3.格(最通用的一类, 几乎所有经典密码概念都可以在格密码中实现)4.超奇异椭圆曲线同源问题(当下较新的一类, 目前其中较受关注的有密钥交换和签名方案的构造,计算效率很低,还达不到实用性的要求)\n\n(3条消息) 格密码学习笔记（一）_中科院大学网安学院五班的博客-CSDN博客_格密码\n4.2 Crypto–Latticefrom Crypto.Util.number import * import gmpy2 as gp from secret import flag m = bytes_to_long(flag) p = getPrime(1024) q = gp.next_prime(p^getPrime(300)) n = p*q*q  e = 65537 c = gp.powmod(m,e,n) print(&#x27;n =&#x27;,n) print(&#x27;c =&#x27;,c) &#x27;&#x27;&#x27;n = 1657441819757560493500517852783955669448453505565270030410061904903034812851838667903292681076179721746140392331192685190606078940084193957290326586494942522658447994684113206242147782786486488436062862050720479488907160079456425398688762594497865325047151851509869420955094484022711893914207287322595902861633185849920399826569309062936190162679696321445993297117512458125412547050580265204485812236589358129086671672828599162645076611983958397948578920439799452386250795654988454192963915928293305164506837479627943346663261467474305586884553923408358862832788883664773346582688933735310806488603282226770159631772761229230574671474094221451870770630961493950451576998259008044822492004077759659701132437773984472438535462757118722089434990869144816129748753152891554265248737014747786223673274064575777197461593456413962892395208072539632132385626016349698916261814365453919077654267526533803349663404621106450916027162399c = 1593553679265125861785993192995912696703111560484695970440496248832386885660325028592530874649060028886120763183422597047360806209458935841437245811877714862968196063554261763749466409879047920508168205393706964912523940426199563334512062879052144213846731434858189341622618689853479805825788008893681015249513342688073719536077558806766432484683211750233531164855481666588757851308926988995968945742356896847523781439112333434449743267160262042077831263329769226240475721901216575639399568420398732862655239671453285258560223566086632412820111497447791858015410203252987331230298565756895805839776628672153301485185711776486346696438675451218026201460790552063913385567753045113924570385856031061350493346154777923602808727275442959100197205924675240921131973487280067779126475375849306092292239336121622197137677170815075931160633100612695431123755384954524364124384771024043229892682507314656508989478323824687786447911936&#x27;&#x27;&#x27;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n五、Discrete Log5.1 What is Discrete Log离散对数被誉为当代密码学领域的三大基础之一。1976年，Diffifie和Hellman提出了一种密钥协商协议， 产生了首个离散对数系统模型；8年后，ElGamal提出了基于离散对数系统的公钥加密和签名方法，并奠定了离散对数密码学基础。从那时起，围绕离散对数系统产生了不少研究成果，本文阐述离散对数的基本概念，然后介绍基于离散对数的ElGamal的公钥加密方法和数字签名方法（DSA）。\n5.1.1 Define Discrete Log:\n\n定义\n当模 m有原根时，设 a为模 m的一个原根，则当$$ak≡x(mod m)时： Indx≡k(mod ϕ(m))$$，此处的 Indx为 x以整数 a为底，模 ϕ(m)时的离散对数值.\n性质\n离散对数和一般的对数有着相类似的性质：\n\n示例\n对模5，ϕ(5)&#x3D;5−1&#x3D;4.有个原根是2. 因为\n\n离散对数概念 - 瀚海星空 - 周海汉博客 (abloz.com)\n5.2 Crypto–Discrete Logimport gmpy2 as gp from Crypto.Util.number import * from Crypto.Cipher import AES  import random from secret import flag,key def ts(g,p):    return gp.powmod(g,(p-1)//2,p) == 1     class ELG():    def __init__(self,m):        self.m = m      def creation(self):        global p,g                         while True:            p = 2              pr = []             for i in range(10):                 a = getPrime(20)                pr.append(a)                 p *= a**random.randint(1,4)             if isPrime(p+1):                break           p += 1          print(&#x27;p =&#x27;,p)         print(&#x27;pr =&#x27;,pr)         g = 2        while True :            g+=1             if ts(g,p):                break         print(&#x27;g =&#x27;,g)         priv_a = random.randint(1,p-1)         pub_A = gp.powmod(g,priv_a,p)                         print(&#x27;pub =&#x27;,pub_A)         return priv_a,pub_A                 def enc(self,m,pub):        k = random.randint(2&lt;&lt;100,2&lt;&lt;200)          c1 = gp.powmod(g,k,p)         c2 = (m * gp.powmod(pub,k,p)) % p         return c1,c2      def conn(self):         priv,pub = self.creation()         c1,c2 = self.enc(self.m,pub)         return c1,c2        DEBUG = True if DEBUG:     aes = AES.new(key,AES.MODE_ECB)      elg = ELG(bytes_to_long(flag))     c1,c2 = elg.conn()     print(&#x27;c1 =&#x27;,c1)     print(&#x27;c2 =&#x27;,c2)     c = aes.encrypt(flag)      print(&#x27;cipher =&#x27;,bytes_to_long(c))    &#x27;&#x27;&#x27;p = 240311898144666004845993472603553263322756300779157768701176199291766409589743098329948576886913307536581636947347700640539029536089210573230307671485961868117315471159814486642321020898269103855126517533262247331484819745914498053780059371263306840883425781625061104966618125509054939865409539648498696187295927g = 5pub = 134285622222383211593143419284735141120812420703242474727692334574646766372588113350683719458438557808968651014501757534179743215386357063432496866596113430845534517856556614675236061221959886358825348089193378086912994104626194570995572907279789332330634572963965215940753665380396874414753113588963071439984133c1 = 59866977306496443433230989875501170590733738724206572571973692325202707443627775293269002455283846854135556345025196628657530983549383681055008873942332984996831735632074040992205674787686019847478343708531796808561868062324972209667292857694231350874772127330748101130540816455846043028497370515427917876173767c2 = 189736523869687408218680256920128645519881608991064724826055201457101208294761171595467115162913230133265415706153044192480307701067740580637047863932982867754412493322841249939735690673297501484346546496379585941155099078148120702397606052034259931372433234626469922863663420459070532806854867523903923301588710cipher = 106965036567008443490243813427422441161051668015352122219256553139516361341928&#x27;&#x27;&#x27; \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n六、Inverse6.1 What is inverse6.6.1 Define inverse:Inverse，即逆元。\n我们都知道倒数的概念，逆元可以说是扩大了概念的倒数。在模运算中，若ab≡1（mod m)，则称b为模m下a的逆元。\n求解公式(a&#x2F;b)%m 时，因b可能会过大，会出现爆精度的情况，所以需变除法为乘法：\n6.1.2 Inverse’s application：那么逆元有什么用呢？(a + b) % p &#x3D; (a%p + b%p) %p （对）(a - b) % p &#x3D; (a%p - b%p) %p （对）(a * b) % p &#x3D; (a%p * b%p) %p （对）(a &#x2F; b) % p &#x3D; (a%p &#x2F; b%p) %p （错）在求余的过程中我们发现只有除法是不能分开运算的，而当a过大时，在计算除法过程中可能会造成比较大的精度损失，所以对于这种情况我们一般会把式子转换成那么(a &#x2F; b) % p &#x3D; (a * inv(b) ) % p &#x3D; (a % p * inv(b) % p) % p来进行计算。这样就解决了除法不能分开计算的问题。需要注意只有a和p互质，a才有关于p的逆元\nhttps://blog.csdn.net/weixin_45757507/article/details/107506285\n6.1.3  Achieve ways：1.费马小定理\n费马小定理：(3条消息) 费马小定理及其应用_不见月光见星光的博客-CSDN博客_费马小定理应用\n费马小定理(Fermat’s little theorem)是数论中的一个重要定理，在1636年提出。\n如果p是一个质数，而整数a不是p的倍数，则有a^（p-1）≡1（mod p）费马小定理规定了p一定为一个质数，所以a和p一定互质那么双方在modp的意义下同时除a可得a^(p-2) ≡1&#x2F;a (mod p)也就是a^(p-2) ≡ inv(a) (mod p)所以inv(a) &#x3D; a^(p-2) (mod p)\n2.扩展欧几里得算法求逆元\n欧几里得算法：(3条消息) 欧几里得算法原理_ltrbless的博客-CSDN博客_欧几里得算法\n如果gcd（a，p）&#x3D;1；那么就有ax+py&#x3D;1双方同时modp就有ax≡1（modp）因为py是p的倍数全部约掉了此时x就是a的逆元所以只需解出该情况下的扩展欧几里得方程的解问题就解决了\n6.2 Inverse–Coding参考书目以及参考的资料：\n《An Introduction to Mathematical Cryptography》\n(3条消息) Python在GF(2⁸)有限域上求解多项式的乘法逆元——基于扩展欧几里得算法_海绵菌的博客-CSDN博客_有限域多项式乘法\n","tags":["面试小结"]},{"title":"Buu-Crypto","url":"/2023/06/18/Buu-Crypto/","content":"BuuCTF刷题记录-Crypto1.异性相吸TASK：\n最近出现了一个奇葩观点，说性别都不一样，怎么能谈恋爱？为了证明这个观点错误，请大家证明异性是相吸的。 \nkey:asadsasdasdasdasdasdasdasdasdasdqwesqf密文：ἇ̀Ј唒ဃ塔屋䩘卖剄䐃堂ن䝔嘅均ቄ䩝ᬔ\n\n\n\nWP：\n\n用010打开两个文件，获得他们的二进制数，再进行异或\n\nfrom Crypto.Util.number import long_to_bytesa = &#x27;0110000101110011011000010110010001110011011000010111001101100100011000010111001101100100011000010111001101100100011000010111001101100100011000010111001101100100011000010111001101100100011000010111001101100100011000010111001101100100011000010111001101100100011100010111011101100101011100110111000101100110&#x27;b = &#x27;0000011100011111000000000000001100001000000001000001001001010101000000110001000001010100010110000100101101011100010110000100101001010110010100110100010001010010000000110100010000000010010110000100011000000110010101000100011100000101010101100100011101010111010001000001001001011101010010100001010000011011&#x27;c = &#x27;&#x27;for i in range(len(a)):    if(a[i] == b[i]):        c+=&#x27;0&#x27;    else:        c+=&#x27;1&#x27;print(c)#0110011001101100011000010110011101111011011001010110000100110001011000100110001100110000001110010011100000111000001110010011100100110010001100100011011100110110011000100011011101100110001110010011010101100010001101010011010001100001001101110011010000110011001101010110010100111000001110010110010101111101print(long_to_bytes(13040004482825639027998127915416848738127988052104145969389882111109559127041106665604212093))#flag&#123;ea1bc0988992276b7f95b54a7435e89e&#125;\n\n\n\n\n\n\n\n\n\n2.RSA（证书公钥解析）TASK：\n\n\n题目给了两个附件，没遇到过，了解后知道是证书公钥解析类型的题目。（证书公钥解析 - CNW - 博客园 (cnblogs.com)）\nWP：\n\npub-key:\n\n-----BEGIN PUBLIC KEY-----MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMAzLFxkrkcYL2wch21CM2kQVFpY9+7+/AvKr1rzQczdAgMBAAE=-----END PUBLIC KEY-----\n\n\n\n\n\n\n公钥解析后就是基本的RSA，脚本如下：\n\nimport gmpy2import libnumfrom Crypto.Util.number import *import rsae= 65537n= 86934482296048119190666062003494800588905656017203025617216654058378322103517p= 285960468890451637935629440372639283459q= 304008741604601924494328155975272418463d= 81176168860169991027846870170527607562179635470395365333547868786951080991441key = rsa.PrivateKey(n,e,d,q,p)         #在pkcs标准中,pkcs#1规定,私钥包含(n,e,d,p,q)with open(&quot;D:\\CTF\\\\buu\\\\0eaf8d6c-3fe5-4549-9e81-94ac42535e7b\\\\flag.enc&quot;,&quot;rb&quot;) as f:  #以二进制读模式，读取密文    f = f.read()    print(rsa.decrypt(f,key))           # f:公钥加密结果  key:私钥\n\n得到flag：  flag{decrypt_256}\n3.RSA1（dp,dq泄露）TASK：\np = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852\n\n题目给出了p,q,dp,dq,c \n考虑使用crt，欧拉定理求解\nWP：\n\n推导过程如下：\n\n\n\nfrom gmpy2 import invertfrom libnum import*p = 8637633767257008567099653486541091171320491509433615447539162437911244175885667806398411790524083553445158113502227745206205327690939504032994699902053229 q = 12640674973996472769176047937170883420927050821480010581593137135372473880595613737337630629752577346147039284030082593490776630572584959954205336880228469 dp = 6500795702216834621109042351193261530650043841056252930930949663358625016881832840728066026150264693076109354874099841380454881716097778307268116910582929 dq = 783472263673553449019532580386470672380574033551303889137911760438881683674556098098256795673512201963002175438762767516968043599582527539160811120550041 c = 24722305403887382073567316467649080662631552905960229399079107995602154418176056335800638887527614164073530437657085079676157350205351945222989351316076486573599576041978339872265925062764318536089007310270278526159678937431903862892400747915525118983959970607934142974736675784325993445942031372107342103852#n=p*qI = invert(q,p)            #求p的逆元mp = pow(c,dp,p)           #求幂取模运算mq = pow(c,dq,q)           #求幂取模运算m = int((((mp-mq)*I)%p)*q+mq) m=m%nprint(n2s(m))             \n\n解出flag： noxCTF{W31c0m3_70_Ch1n470wn}\n","tags":["CTF小试"]},{"title":"Theorem","url":"/2023/07/08/Theorem/","content":"Theorem in Crypto一、Fermat’s Little Theorem（费马小定理）1.定理内容如果p是质数，并且a不是p的倍数。那么就有$$a^{p-1} &#x3D; 1 (mod p)$$\n对于正整数a和p，如果有$$a x ≡ 1 ( m o d   p )$$，那么称x的最小整数解为a模p的逆元\n由上面的结论我们可以得到a的逆元其实就是$$a^{p − 2}$$  对于这个数我们可以使用快速幂来计算结果\n2.费马小定理的运用 费马小定理可以用来解决求组合数的问题，在求解组合数的时候，我们虽然可以通过使用杨辉三角来进行求解，但是在一些情况下我们经常需要去求解一个组合数的模，但是那些阶乘超过了我们的运算范围，也需要对它们进行取模，可是这个时候上下同时进行取模的结果是错误的结果。下面我们来进行 a b m o d   p \\frac{a}{b}mod\\space pba\n mod p 的正确求解操作\n 首先有一个前提条件是a mod b &#x3D; 0 a&#x2F;b &#x3D; m\n 假设存在一个数使得ax%p &#x3D; m\n 由于模运算对于乘法是有效的，所以两边同时乘上b，得到a%p &#x3D; (m%p)*(b%p)%p\n 两边再同时乘以x，得到m%p &#x3D; (mb)*x%p，得到 1 &#x3D; bx%p, 所以我们可以知道这个x其实就是b的逆元，基于这个结论我们可以得到求解$$\\frac{a}{b}\\mod p &#x3D; a\\cdot b的逆元$$ 所以对于组合数$$C_a^b &#x3D; \\frac{a!}{b!(a-b)!} &#x3D; a!\\cdot b!(a-b)!$$对于p的逆元\n在RSA的ctf题目中总有其用武之地\n二、Chinese remainder theorem（中国剩余定理）1.定理内容在《孙子算经》中有这样一个问题：“今有物不知其数，三三数之剩二（除以3余2），五五数之剩三（除以5余3），七七数之剩二（除以7余2），问物几何？”这个问题称为“孙子问题”，该问题的一般解法国际上称为“中国剩余定理”。具体解法分三步：\n\n\n找出三个数：从3和5的公倍数中找出被7除余1的最小数15，从3和7的公倍数中找出被5除余1 的最小数21，最后从5和7的公倍数中找出除3余1的最小数70。\n用15乘以2（2为最终结果除以7的余数），用21乘以3（3为最终结果除以5的余数），同理，用70乘以2（2为最终结果除以3的余数），然后把三个乘积相加15∗2+21∗3+70∗215∗2+21∗3+70∗2得到和233。\n用233除以3，5，7三个数的最小公倍数105，得到余数23，即233%105&#x3D;23233%105&#x3D;23。这个余数23就是符合条件的最小数。\n\n\n\n　　就这么简单。我们在感叹神奇的同时不禁想知道古人是如何想到这个方法的，有什么基本的数学依据吗？\n　　我们将“孙子问题”拆分成几个简单的小问题，从零开始，试图揣测古人是如何推导出这个解法的。\n　　首先，我们假设n1是满足除以3余2的一个数，比如2，5，8等等，也就是满足3∗k+2（k&gt;&#x3D;0）的一个任意数。同样，我们假设n2是满足除以5余3的一个数，n3是满足除以7余2的一个数。\n　　有了前面的假设，我们先从n1这个角度出发，已知n1满足除以3余2，能不能使得n1+n2的和仍然满足除以3余2？进而使得n1+n2+n3的和仍然满足除以3余2？\n　　这就牵涉到一个最基本数学定理，如果有a%b&#x3D;c，则有(a+k∗b)%b&#x3D;c(k为非零整数)，换句话说，如果一个除法运算的余数为c�，那么被除数与k倍的除数相加（或相减）的和（差）再与除数相除，余数不变。这个是很好证明的。\n　　以此定理为依据，如果n2是3的倍数，n1+n2就依然满足除以3余2。同理，如果n3也是3的倍数，那么n1+n2+n3的和就满足除以3余2。这是从n1的角度考虑的，再从n2，n3的角度出发，我们可推导出以下三点：\n\n\n为使n1+n2+n3的和满足除以3余2，n2和n3必须是3的倍数。\n为使n1+n2+n3的和满足除以5余3，n1和n3必须是5的倍数。\n为使n1+n2+n3的和满足除以7余2，n1和n2必须是7的倍数。\n\n\n\n　　因此，为使n1+n2+n3的和作为“孙子问题”的一个最终解，需满足：\n\n\nn1除以3余2，且是5和7的公倍数。\nn2除以5余3，且是3和7的公倍数。\nn3除以7余2，且是3和5的公倍数。\n\n\n\n　　所以，孙子问题解法的本质是从5和7的公倍数中找一个除以3余2的数n1，从3和7的公倍数中找一个除以5余3的数n2，从3和5的公倍数中找一个除以7余2的数n3，再将三个数相加得到解。在求n1，n2，n3时又用了一个小技巧，以n1为例，并非从5和7的公倍数中直接找一个除以3余2的数，而是先找一个除以3余1的数，再乘以2。也就是先求出5和7的公倍数模3下的逆元，再用逆元去乘余数。\n　　这里又有一个数学公式，如果a%b&#x3D;c，那么(a∗k)%b&#x3D;a%b+a%b+…+a%b&#x3D;c+c+…+c&#x3D;k∗c(k&gt;0),也就是说，如果一个除法的余数为c�，那么被除数的k倍与除数相除的余数为k∗c。展开式中已证明。\n　　最后，我们还要清楚一点，n1+n2+n3只是问题的一个解，并不是最小的解。如何得到最小解？我们只需要从中最大限度的减掉掉3，5，7的公倍数105即可。道理就是前面讲过的定理“如果a%b&#x3D;c，则有$$(a−k∗b)(mod b)&#x3D;c^n$$所以（n1+n2+n3）%105（就是最终的最小解。\n　　这样一来就得到了中国剩余定理的公式：\n\n设正整数两两互素，则同余方程组\n​               \n有整数解。并且在模下的解是唯一的，解为\n​                \n其中，而为模的逆元。\n\n\n2.中国剩余定理扩展——求解模数不互质情况下的线性方程组：　　普通的中国剩余定理要求所有的互素，那么如果不互素呢，怎么求解同余方程组？\n　　这种情况就采用两两合并的思想，假设要合并如下两个方程：\n\n\n　　那么得到：\n\n\n　　我们需要求出一个最小的x使它满足：\n\n\n　　那么x1和x2就要尽可能的小，于是我们用扩展欧几里得算法求出x1的最小正整数解，将它代回a1+m1x1，得到x的一个特解x’，当然也是最小正整数解。\n　　所以x的通解一定是x′加上lcm(m1,m2)∗k，这样才能保证x模m1和m2的余数是a1和a2。由此，我们把这个x′当做新的方程的余数，把lcm(m1,m2)当做新的方程的模数。（这一段是关键）\n　　合并完成：\n\n\n\n\n\n\n\n\n","tags":["Crypto"]},{"title":"MCU-Study","url":"/2023/07/15/MCU-Study/","content":"Contents\n[TOC]\nPart1–初识MCU一、Preparation1. Two applicationsKeil5（编写程序）\n\n\n\n(1)从官网下载Keil5\n\n\n(2)从License Magement中复制你的CID并将其输入keygen中激活\n\n\n\n\n\n注意，以管理员身份运行程序，否则权限不够。  AND    在打开Keygen或者下载前，关闭防火墙，否则有一定概率误杀\n\n\n\n(3)点击Generate，完成激活\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStc-isp（下载程序）这个自行搜索下载\n\n\n在成功下载之后，一般来说无法直接读取或识别外接的C51，这个时候需要安装相应的driver：\n\n\n\n\n\n\n这时候如果在任务管理器中能够能看到USB-SERIAL，说明驱动安装成功，C51已被读取。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n二、About  MCU1. Brief introduction单片机，英文Micro ControIIer Unit ， 简称MCU\n\n内部集成了CPU 、RAM 、ROM 、定时器、中断系统、通讯接口等一系列电脑的常用硬件功能\n单片机的任务是信息采集（ 依靠传感器） 、处理（ 依靠CPU) 和硬件设备（ 例如电机， LED 等） 的控制\n单片机跟计算机相比， 单片机算是一个袖珍版计算机， 一个芯片就能构成完整的计算机系统。但在性能上， 与计算机相差甚远， 但单片机成本低、体积小、结构简单， 在生活和工业控制领域大有所用。同时， 学习使用单片机是了解计算机原理与结构的最佳选择\n\n51单片机：指80年代Intel开发的8051内核的单片机的统称。\n\n\n\n\n\n\n*类比电脑内存条*：RAM（Random Access Memory，随机存取存储器）是计算机中的一种主要存储设备，用于临时存储和快速访问数据。它是计算机的一个重要组成部分，用于存储正在执行的程序和数据。\nRAM与计算机的硬盘驱动器（或固态驱动器）不同，后者用于长期存储数据，而RAM是一种易失性存储器，意味着其存储的数据在断电或重新启动后会被清除。这是因为RAM是基于电子器件和电路构建的，需要持续的电源供应来保持存储的数据。\nRAM被分为主存储器（Main Memory）和高速缓存（Cache Memory）。主存储器是计算机直接访问的存储区域，用于存储正在运行的程序和数据。它的存取速度比硬盘驱动器等次要存储设备要快得多。高速缓存是位于CPU内部的一种更快速的存储器，用于临时存储处理器频繁访问的数据，以提高计算机的性能。\nRAM的容量通常以兆字节（MB）或千兆字节（GB）进行衡量。较大容量的RAM可以容纳更多的程序和数据，从而提供更好的性能和多任务处理能力。计算机的RAM容量可以根据需要进行扩展或升级。\n总之，RAM是一种临时存储设备，用于存储正在执行的程序和数据，提供计算机的实时访问能力。它在计算机的性能和多任务处理方面起着重要的作用。\n*类比电脑硬盘*：ROM（Read-Only Memory）是一种计算机芯片或存储设备中的一种存储器类型。与随机访问存储器（RAM）相比，ROM在断电后能够保持其存储的数据不变，因此也被称为非易失性存储器。ROM的数据一般是由制造厂商在生产过程中预先写入的，并且用户无法对其进行修改。这意味着ROM中存储的内容是只读的，无法被擦除或重写。\nROM有多种不同类型，包括：\n\nPROM（Programmable Read-Only Memory，可编程只读存储器）：这种ROM允许用户在一次性编程之前将数据写入其中。一旦编程完成，数据将永久固化在芯片中，不可更改。\nEPROM（Erasable Programmable Read-Only Memory，可擦除可编程只读存储器）：这种ROM允许用户通过使用特定设备将其数据擦除，然后再次编程。擦除通常通过使用紫外线光线或电子擦除器来进行。\nEEPROM（Electrically Erasable Programmable Read-Only Memory，电可擦除可编程只读存储器）：EEPROM与EPROM类似，但是擦除操作可以通过电源供电而不需要其他特殊设备。EEPROM的擦除和编程可以在特定的操作条件下进行。\n\nROM的应用非常广泛，它被用于存储启动引导程序、固件、芯片内的固定数据以及其他一些需要在断电后保持不变的数据。有些游戏机、手机和电脑主板中也使用ROM存储固件或操作系统。总之，ROM在计算机和电子设备中起到了重要的作用，并且因其稳定性和数据不易丢失的特点而受到广泛使用。\n2. Application field单片机的使用领域已十分广泛， 如智能仪表、实时工控、通讯设备、导航系统、家用电器等。各种产品一旦用上了单片机， 就能起到使产品升级换代的功效， 常在产品名称前冠以形容词——“智能型”，如智能型洗衣机等。\n3. Naming rules\n\n\n\n\n\n\n\n\n\n4. Structure单片机内部结构图：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n单片机管脚图：\n\n\n例如 Vcc代表 + 极，Gnd代表 - 极\n单片机的最小系统：\n\n\n电容——过滤因为电源不稳定产生的电磁波\n复位电路（中间的）——复位电路通常用来清除存储器中的数据、关闭所有开关和重置相关的逻辑电路。它可以在系统启动时，或在错误发生时，通过将相关电路重新初始化，确保系统处于可控状态。\n晶振（左下角）——用于时钟电路和振荡电路中，以稳定电子设备的工作频率。晶振的主要原理是利用压电效应，在晶体振荡器中产生稳定的振荡信号。推动程序往下进行的关键。\nPart2–编写MCU一、Light up LED \n\nLED，全称为Light Emitting Diode（发光二极管），是一种固体电子器件，可以将电能直接转化为光能。相对于传统的光源，如白炽灯和荧光灯，LED具有更高的能效、更长的使用寿命和更大的可靠性。\nLED的工作原理是基于半导体材料的特性。当电流通过LED时，电子和空穴在半导体材料中重新组合，产生能量释放，从而产生可见光。不同半导体材料的能带结构决定了LED发出的光的颜色。\nLED具有许多优点。首先，LED保存能量且效率高，相比传统光源，LED产生的光功率更大，但消耗的电能更少。其次，LED寿命长，通常可以达到数万个小时，远远超过传统光源。此外，LED具有快速开启和关闭的特性，并且可以根据需要调节亮度，因此被广泛应用于照明和显示领域。\nLED在各个领域有广泛的应用。在照明领域，LED被用于家庭照明、商业照明和街道照明等。由于其高效节能的特性，LED也被用于太阳能照明和绿色建筑项目中。在电子显示领域，LED用于制造各种显示屏，如电视、计算机显示器和手机屏幕。此外，LED还常用于车辆照明、室内装饰、电子设备指示灯等。\n1. 点亮一个LED首先观察MCU里的LED模块\n\n\n\n\n\n\n右边图片中的RP9、RP10是两个电阻                                                                          102&#x3D;1k(10*10^2)元器件上的标号以此类推\n\n\nP2口下的寄存器控制LED：       1–5V  不亮              0–0V  亮\n\n\n创建一个Project，在列表里的Atmel下选择AT89C52\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n在该文件夹下创建一个C的文件，以便进一步编写程序\n\n\n\n\n\n\n\n 3.编写控制LED的代码\n#include &lt;REGX52.H&gt;void main()&#123;\tP2=0xFE;  &#125;\n\n\n\n\n\n\n\n4.将文件保存为hex格式，以便烧入\n\n\n\n\n\n\n\n\n5.用stc-isp将程序烧入进MCU中，尝试运行\n选择相应的单片机型号与串口号，并打开已写好的程序文件\n\n\n\n\n然后点击下载，重启单片机，发现成功点亮LED\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2. LED闪烁重复(1)中的操作步骤，新建一个Project\n其实要完成闪烁只需要写一个while循环就可以了\n#include &lt;REGX52.H&gt;void main()&#123;\t\twhile(1)\t&#123;\t\tP2=0xFE;\t\tP2=0xFF;\t&#125;&#125;\n\n但这个时候发现LED闪烁周期过快，肉眼无法观察到明显现象，这个时候需要加大周期，即加入延时函数。\n#include &lt;REGX52.H&gt;#include &lt;INTRINS.H&gt;void Delay500ms()\t\t//@12.000MHz&#123;\tunsigned char i, j, k;\t_nop_();\ti = 4;\tj = 205;\tk = 187;\tdo\t&#123;\t\tdo\t\t&#123;\t\t\twhile (--k);\t\t&#125; while (--j);\t&#125; while (--i);&#125;void main()&#123;\t\twhile(1)\t&#123;\t\tP2=0xFE;          //0xAA    左右闪烁\t\tDelay500ms();\t\tP2=0xFF;          //0x55\t\tDelay500ms();\t&#125;&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3. LED流水灯有了“前车之鉴”，再写流水灯其实就很简单了，逻辑是一样的。\n#include &lt;REGX52.H&gt;#include &lt;INTRINS.H&gt;void Delay250ms()\t\t//@12.000MHz&#123;\tunsigned char i, j, k;\t_nop_();\ti = 2;\tj = 231;\tk = 91;\tdo\t&#123;\t\tdo\t\t&#123;\t\t\twhile (--k);\t\t&#125; while (--j);\t&#125; while (--i);&#125;void main()&#123;\twhile(1)\t&#123;\t\tP2=0xFE;          \t\tDelay250ms();\t\tP2=0xFD;          \t\tDelay250ms();\t\tP2=0xFB;\t\tDelay250ms();\t\tP2=0xF7;\t\tDelay250ms();\t\tP2=0xEF;\t\tDelay250ms();\t\tP2=0xDF;\t\tDelay250ms();\t\tP2=0xBF;\t\tDelay250ms();\t\tP2=0x7F;\t\tDelay250ms();\t&#125;&#125;\n\n\n\nPro版本：\n#include &lt;REGX52.H&gt;int n=50;void Delay1ms(unsigned int xms)    //@12.000MHz&#123;\tunsigned char i,j;\twhile(xms)\t&#123;\t\ti=2;\t  j=239;\t\tdo\t\t&#123;\t\t\twhile(--j);\t\t&#125; while(--i);\t\txms--;\t&#125;&#125;void main()&#123;\twhile(1)\t&#123;\t\tP2=0xFE;          \t\tDelay1ms(n);\t\tP2=0xFD;          \t\tDelay1ms(n);\t\tP2=0xFB;\t    Delay1ms(n);\t\tP2=0xF7;\t\tDelay1ms(n);\t\tP2=0xEF;\t\tDelay1ms(n);\t\tP2=0xDF;\t\tDelay1ms(n);\t\tP2=0xBF;\t\tDelay1ms(n);\t\tP2=0x7F;\t\tDelay1ms(n);\t&#125;&#125;\n\n\n\n\n\n\n\n\n\n\n\n二、Individual key\n\nC51上的独立按键：底座+金属弹片+   +\n不按下时4个引脚两两连接，按下去时4个引脚同时连接\n\n\n独立按键：\n\n\n4个独立按键一端接 -极，另一端接I&#x2F;O口（I&#x2F;O口默认高电平）\n寄存器检测I&#x2F;O口电平\n1. 独立按键控制LED亮灭sfr：整个8位的寄存器         \n 寄存器中P2表示8位一体，不可单独控制单独位次\n\n\n发现sbit可控制单独位次\n\n\n\n\n\n\n\n\n#include &lt;REGX52.H&gt; void main() &#123;\t//P2=0xFE;\t\t    \t   \twhile(1)  //单独控制P2的第0根管脚\t&#123;\t\tif(P3_1==0)\t\t&#123;\t\t\tP2_0=0;     //读取K1口寄存器\t\t&#125;\t\t\t\telse\t\t\t&#123;\t\t\tP2_0=1;\t\t&#125;\t\t\t\t&#125; &#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2. 独立按键控制LED状态\n\n\n\n\n\n#include &lt;REGX52.H&gt;void Delay(unsigned int xms)\t\t//@12.000MHz&#123;\tunsigned char i, j;\twhile(xms)\t&#123;\t\ti = 2;\t\tj = 239;\t\tdo\t\t&#123;\t\t\twhile (--j);\t\t&#125; while (--i);\t\txms--;\t&#125;&#125;void main()&#123;\twhile(1)\t&#123;\t\tif(P3_1==0)   //检测按键是否按下，按下不操作，松手才开始操作（类比于电脑主表操作原理）\t\t&#123;\t\t\tDelay(20);  \t\t\twhile(P3_1==0);\t\t\tDelay(20);\t\t\t\t\t\t\tP2_0=~P2_0;  //按位取反 P2_0只有一位，按位取反在0,1间变化\t\t&#125;\t&#125;&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n3. 独立按键控制LED显示二进制项目的创建以及准备工作就不再赘述\n主要是利用 unsigned char 类型（0—255）与寄存器同样为8位的特性，来间接表示LED二进制\n#include &lt;REGX52.H&gt;void Delay(unsigned int xms)\t\t//@12.000MHz&#123;\tunsigned char i, j;\twhile(xms--)\t&#123;\t\ti = 12;\t\tj = 169;  \t\tdo\t\t&#123;\t\t\twhile (--j);\t\t&#125; while (--i);\t&#125;&#125;void main()&#123;\tunsigned char LEDNum=0;\twhile(1)\t&#123;\t\tif(P3_1==0)\t\t&#123;\t\t\tDelay(20);\t\t\twhile(P3_1==0);\t\t\tDelay(20);\t\t\t\tLEDNum++;   //P2++;不行\t\t\tP2=~LEDNum;\t\t&#125;\t&#125;\t&#125;\n\nP2&#x3D;1111 1111     &#x2F;&#x2F;P2口默认高电平\nP2++  会使端口溢出，P2变成 0000 0000\n再次取反P2将保持原样，即P2&#x3D;1111 1111 ，表现为D1—D8全灭      \n4. 独立按键控制LED移位\n\n项目预期：按下P3_1（左1），实现LED从左向右移位1\n​                    按下P3_0（左2)，实现LED从右向左移位1                             \n\n\n[^如图所示]: \n\n\n实现移位的代码如下，主要使用C语言中的位运算：**&lt;&lt; 按位左移** 与 &gt;&gt;按位右移\nP3_1口闭合，左移\n#include &lt;REGX52.H&gt;void Delay(unsigned int xms);unsigned char LEDNum=0;  void main()&#123;\t\twhile(1)\t&#123;\t\tif(P3_1==0)\t\t&#123;\t\t\tDelay(20);\t\t\twhile(P3_1==0);\t\t\tDelay(20);\t\t\t\t\t\tif(LEDNum&gt;7)\t\t\t&#123;\t\t\t\tLEDNum=0;\t\t\t&#125;\t\t\tP2=~(0x01&lt;&lt;LEDNum);    \t\t\tLEDNum++;\t\t&#125;\t&#125;&#125;void Delay(unsigned int xms)\t\t//@12.000MHz&#123;\tunsigned char i, j;\twhile(xms--)\t&#123;\t\ti = 12;\t\tj = 169;  \t\tdo\t\t&#123;\t\t\twhile (--j);\t\t&#125; while (--i);\t&#125;&#125;\n\n与左移逻辑一样，加上右移，完善代码，实现项目预期\n#include &lt;REGX52.H&gt;void Delay(unsigned int xms);   //申明函数unsigned char LEDNum=0;   //8位的全局变量void main()&#123;\tP2=~0x01;        //点亮D1\twhile(1)\t&#123;\t\tif(P3_1==0)    //判断按键是否按下\t\t&#123;\t\t\tDelay(20);             //检测按键状态，即手是否在按下按键后抬起。若未抬起，则按键处于闭合状态，执行while死循环，防止误触\t\t\twhile(P3_1==0);  \t\t\tDelay(20);\t\t\t\t\t\tLEDNum++;\t\t\tif(LEDNum&gt;=8)\t\t\t&#123;\t\t\t\tLEDNum=0;\t\t\t&#125;\t\t\tP2=~(0x01&lt;&lt;LEDNum);\t\t&#125;\t\t\t\tif(P3_0==0)      //判断按键是否按下\t\t&#123;\t\t\tDelay(20);\t\t\twhile(P3_0==0);\t\t\tDelay(20);\t\t\t\t\t\tif(LEDNum==0)\t\t\t&#123;\t\t\t\tLEDNum=7;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\tLEDNum--;  //自减，实现右移\t\t\t&#125;\t\t\tP2=~(0x01&lt;&lt;LEDNum);\t\t&#125;\t&#125;&#125;//延时函数void Delay(unsigned int xms)\t\t//@12.000MHz&#123;\tunsigned char i, j;\twhile(xms--)\t&#123;\t\ti = 12;\t\tj = 169;  \t\tdo\t\t&#123;\t\t\twhile (--j);\t\t&#125; while (--i);\t&#125;&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n三、Static digitron display(1)数码管介绍\n\n\n控制数码管显示：\n138译码器和数码管，两者共同作用下控制数码管的显示\n\n\n\n\n(2)数码管引脚定义：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["MCU"]}]